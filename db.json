{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/proxy.pac","path":"proxy.pac","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"54735b4b06c1a145cd4ba0ecb1ce8147d94f85cc","modified":1534903881338},{"_id":"source/proxy.pac","hash":"22eb9c7dabf87da364301df511d7b28c69b5253a","modified":1534903881352},{"_id":"source/favicon.ico","hash":"f5c47ad31dc1e6003379c88b562786bc7e2d114f","modified":1534903881352},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1534903881353},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1534903881353},{"_id":"themes/next/.DS_Store","hash":"f39d74071f6f79a6a42dd14ac9be2cf1bbf4d4f2","modified":1534903881353},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1534903881353},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1534903881353},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1534903881353},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1534903881354},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1534903881354},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1534903881354},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1534903881354},{"_id":"themes/next/_config.yml","hash":"8703cf1076078ca00e6c0488f278a0aed654cf62","modified":1560318414993},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1534903881364},{"_id":"source/_posts/Flutter-基础知识.md","hash":"3ff8145d2dae509658ac1af965d26007088de43d","modified":1560234739615},{"_id":"source/_posts/NSNotificationCenter小结.md","hash":"50200c3e13fcc8edbbd0ad8ed35a185924dd7f7c","modified":1552296792377},{"_id":"source/_posts/.DS_Store","hash":"55ab2ee9e5f2637822c723d9ec8f4b389ffc8573","modified":1558702562333},{"_id":"source/_posts/Runtime-ivar.md","hash":"2c77f5503e097ea9cdec7dc9dc1e7dd688238096","modified":1559985553032},{"_id":"source/_posts/Runtime-OC对象创建和销毁过程.md","hash":"f8763e65fdaafeb7c34032488fc912aea3dd9d5f","modified":1559983388184},{"_id":"source/_posts/Objective-C基础知识小结.md","hash":"0918c3d52e29864180a83bc6beda51a46e876d17","modified":1559024832984},{"_id":"source/_posts/Runtime-load和initialize.md","hash":"37c1258fced45d7e9cc6ea76288c6459cb238618","modified":1559889878729},{"_id":"source/_posts/Runtime-引用计数和Weak表.md","hash":"932aa355f8147ef67a9539a15ce4fff151f99e59","modified":1559980686991},{"_id":"source/_posts/UISwitch在iOS 10中的BUG.md","hash":"5277c16f674a89645353025937e0e9210077d95b","modified":1560318378088},{"_id":"source/_posts/iOS基础：UIControlState.md","hash":"c9d40a6b19a4f6774baca3ac76dc362a5a0dc86c","modified":1552296780937},{"_id":"source/_posts/iOS基础：GCD.md","hash":"1eaa90b846c57b10a3f17adc2c60de2f41b4f38f","modified":1558950025570},{"_id":"source/_posts/iOS基础：UIViewController生命周期.md","hash":"d51cf7b8a4c60f139dafa26d223e417fc92d8d12","modified":1552296784077},{"_id":"source/_posts/iOS常见warning梳理.md","hash":"21cbbd172417335ea1991bb9301a040af0bc8101","modified":1552296807027},{"_id":"source/_posts/iOS基础：类、对象和方法.md","hash":"f70a44e1e3f44ae3b6a6aa1b113a4dced244e8d3","modified":1558950020012},{"_id":"source/_posts/iOS基础知识面归纳.md","hash":"e97ab61b479c0c5da1578038df1f4654ae6aed6a","modified":1560253273841},{"_id":"source/_posts/初学Objective-C.md","hash":"ab63c9db336dcaf35d85c3d791a60fc7a214e681","modified":1552296733740},{"_id":"source/_posts/开发笔记：iOS中踩过的坑.md","hash":"1228b1c80a589982fb4c5a5037a0b787f13bc634","modified":1559024975679},{"_id":"source/_posts/测试：属性变量、实例变量、成员变量的内存泄漏.md","hash":"22c44f238d5c7dc1d12e4b99aee6d9d47f84d46c","modified":1559890193708},{"_id":"source/_posts/开源库阅读笔记：YYKit-YYModel.md","hash":"65d3cea2e8ba8918586dc6ba485f220a5a5751da","modified":1559890227661},{"_id":"source/_posts/配置：Sublime-Text3.md","hash":"42d09e90209937562c6d0ebb108dc1811d6bd74d","modified":1552297122978},{"_id":"source/_posts/开发笔记：flutter中踩过的坑.md","hash":"a698e94403a10308f4e2ae5757dfa29bf4bd4bbc","modified":1558337702508},{"_id":"source/_posts/配置：Xcode快捷键配置.md","hash":"13b78907fdb56bf5dd00326d79e55fd27d2cd85e","modified":1552296770730},{"_id":"source/_posts/配置：迁移hexo.md","hash":"17970c73b6ba5de2ecbc2b5fafc0ce087038bacb","modified":1558948677552},{"_id":"source/categories/index.md","hash":"acfa5cd4303e752e19079750e81b72ebc81a0013","modified":1534903881352},{"_id":"source/_posts/配置：Vim-Git-SVN.md","hash":"77211fa98f88671592772ad56f10907dd8ff10d7","modified":1552296766753},{"_id":"source/tags/index.md","hash":"17c523c2eac460241f5623b04b7a1ceb02e62c08","modified":1534903881352},{"_id":"themes/next/layout/_layout.swig","hash":"dd5ffebbf9bf09d3f0326110f4b796d4743a2e89","modified":1534903881356},{"_id":"themes/next/layout/archive.swig","hash":"c9383f8b1dd07a1018ce11a9884b9c51e0731525","modified":1534903881363},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1534903881363},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1534903881364},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1534903881364},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1534903881364},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1534903881363},{"_id":"themes/next/scripts/.DS_Store","hash":"de653034730e766ecdf333bb705d0bec0dbb123e","modified":1534903881364},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1534903881354},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1534903881354},{"_id":"themes/next/languages/en.yml","hash":"6fb5375936d6943bbda0a5272297d1b725ba9471","modified":1534903881354},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1534903881355},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1534903881355},{"_id":"themes/next/layout/index.swig","hash":"e4da19270fd7d53d1ae345d14ea35f84fd9853e5","modified":1534903881363},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1534903881355},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1534903881355},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1534903881355},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1534903881355},{"_id":"themes/next/languages/zh-Hans.yml","hash":"69ac1d5dfa02d91b6cc4d881d86a68336c08e731","modified":1534903881355},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1534903881356},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1534903881356},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1534903881407},{"_id":"themes/next/test/.DS_Store","hash":"86aaef889514f63213877b6166c2177fd70fc322","modified":1534903881407},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1534903881407},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1534903881407},{"_id":"themes/next/source/.DS_Store","hash":"6d85854ca2216dd3fd326ce5e834a6a7ed8cc8e8","modified":1534903881365},{"_id":"source/_posts/Flutter-基础知识/Widget生命周期.png","hash":"e0551eae54b6cf7d62c4595dcc2dd4dd44d47303","modified":1560234681156},{"_id":"source/_posts/Flutter-基础知识/架构.jpeg","hash":"dfb9cba724e06719c97b0267329541ed1400d6e9","modified":1560232349507},{"_id":"source/_posts/Flutter-基础知识/线程模型.png","hash":"a717da38d2c9bb020489c2f9b064a8ed4e6f57c2","modified":1560234387526},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881384},{"_id":"source/_posts/Objective-C基础知识小结/内存空间.png","hash":"226115752acce15576132ce87ebbe837c82ba9d3","modified":1534903881346},{"_id":"source/_posts/Objective-C基础知识小结/调试01.png","hash":"f2ef6cf8a42ac2d08c22ca8d3f80eba65933b107","modified":1534903881346},{"_id":"source/_posts/开源库阅读笔记：YYKit-YYModel/对象模型图.png","hash":"d01543706db03c16aa6ebd09c3f631429cfc4d77","modified":1534903881351},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1534903881356},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1534903881356},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1534903881357},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1534903881357},{"_id":"themes/next/layout/_macro/post.swig","hash":"f3e7b2ac16c431f9e836f80259e06354b3637fc2","modified":1534903881356},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1534903881357},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1534903881357},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1534903881357},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1534903881357},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1534903881358},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1534903881358},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1534903881358},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1534903881360},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1534903881360},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1534903881360},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1534903881363},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1534903881365},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1534903881365},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1534903881365},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1534903881384},{"_id":"themes/next/source/images/avatar.gif","hash":"f5c47ad31dc1e6003379c88b562786bc7e2d114f","modified":1534903881385},{"_id":"themes/next/source/images/.DS_Store","hash":"58244c2df0bdade6749a9c1493dedfd6dad142ce","modified":1534903881384},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1534903881385},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1534903881385},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1534903881385},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1534903881385},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1534903881385},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1534903881385},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1534903881386},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1534903881386},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1534903881386},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1534903881387},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1534903881387},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1534903881387},{"_id":"source/_posts/Objective-C基础知识小结/GCD03.png","hash":"59085025d36af03f694f6d71f5924b8ed67d8146","modified":1534903881345},{"_id":"source/_posts/Objective-C基础知识小结/调试02.png","hash":"60697049b326a1bb58b9105fdbe9689b0cfdde68","modified":1534903881347},{"_id":"source/_posts/iOS基础知识面归纳/RunLoop.png","hash":"e553eba74426abb91aaab3b7f64bd9c808418ccc","modified":1559630336787},{"_id":"source/_posts/iOS基础知识面归纳/load和initialize.png","hash":"26cf375f1a57d5411572fbc28299d17a9da00b8d","modified":1559635836958},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881360},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881360},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881376},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881376},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881376},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881383},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881384},{"_id":"source/_posts/iOS基础知识面归纳/isa.png","hash":"0c90195f414366097cd98312ed20937385786c74","modified":1559618603338},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1534903881357},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1534903881358},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1534903881358},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1534903881359},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1534903881359},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1534903881359},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1534903881359},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1534903881359},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1534903881360},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1534903881363},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1534903881363},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1534903881363},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1534903881360},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"656c60c7d93f110a9e941a5fca617ee277fed707","modified":1534903881376},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1534903881376},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1534903881376},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e2ff8aab16ce9b5282c4cdf6375c152466fb804c","modified":1534903881384},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f5a47ced09d79389ac8c682b925914c5e43b868c","modified":1534903881383},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1534903881383},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1534903881388},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1534903881389},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1534903881388},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1534903881389},{"_id":"themes/next/source/js/src/post-details.js","hash":"cd067c34beb799df5ee8736352786f8fffe15ae5","modified":1534903881389},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1534903881390},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1534903881390},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1534903881390},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1534903881390},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1534903881395},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1534903881395},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1534903881395},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1534903881395},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1534903881397},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1534903881397},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1534903881397},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1534903881397},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1534903881398},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1534903881403},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1534903881405},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1534903881405},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1534903881405},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1534903881406},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1534903881406},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1534903881406},{"_id":"source/_posts/Objective-C基础知识小结/GCD02.png","hash":"c880d194ae36e56673eedb6b1b15022df7cbb66d","modified":1534903881344},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1534903881404},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1534903881362},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1534903881366},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1534903881366},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1534903881365},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1534903881366},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1534903881373},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1534903881375},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1534903881375},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1534903881375},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1534903881376},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1534903881376},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1534903881375},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"399f896e6c0d8adbfc870cc5284eddf4b557e783","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"7eb54d3b01c704797ef048401da40dbe1dcc02e7","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1534903881378},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1534903881379},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1534903881378},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1534903881380},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1534903881380},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1534903881382},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1534903881383},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1534903881389},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1534903881391},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1534903881391},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1534903881393},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1534903881392},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1534903881392},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1534903881392},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1534903881394},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1534903881395},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1534903881394},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1534903881396},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1534903881396},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1534903881399},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1534903881398},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1534903881399},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1534903881405},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1534903881405},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1534903881403},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1534903881401},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1534903881400},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1534903881403},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1534903881406},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1534903881368},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1534903881368},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1534903881366},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d8d28120ee267f12d576577164b259b7fc7abc8d","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1534903881375},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1534903881375},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1534903881374},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1534903881378},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1534903881378},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1534903881380},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1534903881393},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1534903881393},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1534903881393},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1534903881394},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1534903881394},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1534903881394},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1534903881402},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1534903881401},{"_id":"source/_posts/Objective-C基础知识小结/GCD01.png","hash":"923d04db1606dcad66289c1675af1a06b89dcac8","modified":1534903881343},{"_id":"public/baidusitemap.xml","hash":"ec21876a44ae1a294ab693d45726383bf488b424","modified":1560318422076},{"_id":"public/sitemap.xml","hash":"e4c252b0a627e52e2ddd52ebdb6c3e91f6e81c54","modified":1560318422076},{"_id":"public/categories/index.html","hash":"2367f1c56d407cb8203b9a1398e6da767bedf568","modified":1560318422112},{"_id":"public/tags/index.html","hash":"821f978c0f78ce44dd6ffe430f5ee41c0816c6dd","modified":1560318422112},{"_id":"public/archives/page/3/index.html","hash":"8a544315c27c882ddc005cb30196ac1d90e80dd2","modified":1560318422112},{"_id":"public/archives/2016/page/2/index.html","hash":"658905cdf5e622f89556bdfb0dca088fb89055f5","modified":1560318422112},{"_id":"public/archives/2016/08/index.html","hash":"5c78a5d714edb09b1add893da0227d7f46f53ec6","modified":1560318422112},{"_id":"public/archives/2016/09/index.html","hash":"bfd8a6eaaa2e973eff95092fd45c62048b19a629","modified":1560318422112},{"_id":"public/archives/2016/10/index.html","hash":"65c2a7627d31bdf8e4203ce24965954912ef9559","modified":1560318422112},{"_id":"public/archives/2016/12/index.html","hash":"ac58fc87e7562b062244aaf2e1f66eb981ca2985","modified":1560318422112},{"_id":"public/archives/2017/index.html","hash":"0953f7e2609f8bcfd2caa959bce6efb92e793549","modified":1560318422113},{"_id":"public/archives/2017/01/index.html","hash":"91ff7208ac1252da36355b8e974a1b9109291aa2","modified":1560318422113},{"_id":"public/archives/2017/03/index.html","hash":"9798d9b2d5e81c8d625b0e56b0e5b120f626b962","modified":1560318422113},{"_id":"public/archives/2018/index.html","hash":"8cf1aa78fcbd38dacef5975d4f890dd0fb295e44","modified":1560318422113},{"_id":"public/archives/2018/01/index.html","hash":"4d02855fb3d4040ea28f9fb7fe0afcc598f6bb63","modified":1560318422113},{"_id":"public/archives/2018/07/index.html","hash":"1457f5cfa4f7a5797ba39cb1efb81275c7c23ccd","modified":1560318422113},{"_id":"public/archives/2019/index.html","hash":"f91a580867c707155aed270ce31d5d0ca371e1db","modified":1560318422113},{"_id":"public/archives/2019/04/index.html","hash":"a9b0eeb5ba86df45526ee3df73d4c03b9edadbb9","modified":1560318422113},{"_id":"public/archives/2019/05/index.html","hash":"224b97a8a27bcbd35a216a02b7aa21b18f0dbabc","modified":1560318422113},{"_id":"public/archives/2019/06/index.html","hash":"f3887005fc1265ed26a43084bbeae6e289bae113","modified":1560318422113},{"_id":"public/categories/Runtime/index.html","hash":"835f93de5c5f8cef65652e0729fe8d2ba33979cd","modified":1560318422116},{"_id":"public/categories/iOS基础知识/index.html","hash":"dbe088e4ab46dd73967381fa8532023531e1128b","modified":1560318422116},{"_id":"public/categories/笔记/index.html","hash":"89802719481ef258bb2f737d7e781e311dd17ac9","modified":1560318422116},{"_id":"public/categories/开发配置/index.html","hash":"ea0b1bd28c9da4d38056b8f216e63e93179f9818","modified":1560234783131},{"_id":"public/tags/Flutter/index.html","hash":"0e11664b6bd3435ffd263876b485c2620348c83c","modified":1560318422113},{"_id":"public/tags/ivar/index.html","hash":"5a618bd42e920fa53e0894c526cb63699ce9dc31","modified":1560318422113},{"_id":"public/tags/Objective-C/index.html","hash":"91cb0783d7452aed7c6fef0f93a6ddf53776acce","modified":1560318422114},{"_id":"public/tags/NSNotificationCenter/index.html","hash":"6a2db0595989313fa23afce04524123c16f61bf4","modified":1560318422114},{"_id":"public/tags/OC对象/index.html","hash":"cc376c3cf6ed4a6c11bf3b4a9110d44d6e7548f4","modified":1560318422114},{"_id":"public/tags/load/index.html","hash":"e0b7095c03426ff63c10682896f8036e9836a204","modified":1560318422114},{"_id":"public/tags/initialize/index.html","hash":"e34c42a3f57ab5ae824b49b7c71d3dc0b5e5acb4","modified":1560318422114},{"_id":"public/tags/引用计数/index.html","hash":"6a44f1523bdc55b5d39db3a7dec123f48954bdf8","modified":1560318422114},{"_id":"public/tags/Weak表/index.html","hash":"462cfe28da20bd47ec6a1c10c7321036dc83199e","modified":1560318422114},{"_id":"public/tags/iOS/index.html","hash":"e29374b743a7b2cdfd666a2f75f2e2851a656d01","modified":1560234783131},{"_id":"public/tags/iOS-10/index.html","hash":"b4de8bd77ec79d9314e8c87c0f793f669f380e5d","modified":1560318422114},{"_id":"public/tags/BUG/index.html","hash":"ce9a675b5227e59be7e71cf02416aca5ec7ab701","modified":1560318422114},{"_id":"public/tags/多线程/index.html","hash":"7759720782dfa93afa75d13198a05f72d4ab1f1d","modified":1560318422114},{"_id":"public/tags/GCD/index.html","hash":"3e292184d59f16b7068125017b4b2c8101170d8b","modified":1560318422114},{"_id":"public/tags/UIControl/index.html","hash":"fcd3043a8a80e1d81d4c098f841de558a1ab87a3","modified":1560316563391},{"_id":"public/tags/UIControlState/index.html","hash":"8e758ac05d6889df427f5560732f02810bc28c34","modified":1560318422114},{"_id":"public/tags/UIViewController/index.html","hash":"2a0bda1d0f73b9993ef0d01505220a217b56cfbd","modified":1560318422114},{"_id":"public/tags/warning/index.html","hash":"36a94c0aa46ec2792cf10e98ebddefae73e6bb99","modified":1560318422114},{"_id":"public/tags/类/index.html","hash":"c25404b82d5a0690471ea295276709d5e400510d","modified":1560318422115},{"_id":"public/tags/对象/index.html","hash":"7776fa41c8c3f93c6b70c259254d444003224a8c","modified":1560318422115},{"_id":"public/tags/方法/index.html","hash":"beefe1a6f8154e27ecc9280840c367ce9b79f702","modified":1560318422115},{"_id":"public/tags/autoreleasepool/index.html","hash":"f2f9807e6cab0787da59a24a2cb6d577e75f7037","modified":1560318422115},{"_id":"public/tags/属性/index.html","hash":"4f705e66b0553832c1bfa0bca4eb486f5c43ecf6","modified":1560318422115},{"_id":"public/tags/惰性实例化/index.html","hash":"fb3abc6f9fea83b711197cdaae53bba963af97b2","modified":1560318422115},{"_id":"public/tags/iOS基础知识/index.html","hash":"e9b8f825209c6c9159322074e7b961cba0ae4c4c","modified":1560318422115},{"_id":"public/tags/笔记/index.html","hash":"cd7a3f7d6de11e807c70a400eef425f5e4c1e128","modified":1560318422115},{"_id":"public/tags/内存泄漏/index.html","hash":"3ba0d39a705aeb66ac4b37494adaa70df5fd1b94","modified":1560318422115},{"_id":"public/tags/开源库阅读笔记/index.html","hash":"4ac5316bf2ade0844cd67407cd64851228658a67","modified":1560234783132},{"_id":"public/tags/开发环境配置/index.html","hash":"29cefcd9a8408ead17bf8983c24bdbdc67faf56e","modified":1560234783132},{"_id":"public/tags/Xcode/index.html","hash":"7ac08a9561c409dd790949796926b98d131a13c7","modified":1560318422115},{"_id":"public/tags/Sublime-Text/index.html","hash":"58744b169c3d3d0ae8816132290871ddd5878348","modified":1560318422115},{"_id":"public/tags/flutter/index.html","hash":"0114a31acfc248bdf63fcc2f57d3ee92c7d6d0ac","modified":1560234783133},{"_id":"public/tags/hexo/index.html","hash":"d8ea6c565b7e88af234582208ae6eed63eade7b5","modified":1560318422115},{"_id":"public/tags/bash/index.html","hash":"4c8289dbc7a9ef6bb45fe673eb2dbc2c56054c62","modified":1560318422116},{"_id":"public/tags/Vim/index.html","hash":"8aea234f1331da54dfc9cd607c638acd982c4b38","modified":1560318422116},{"_id":"public/tags/SVN/index.html","hash":"3c9d371c651f9a4152e03f5b03667319d94e9223","modified":1560318422116},{"_id":"public/tags/Git/index.html","hash":"c7ca733ee67b819ca52e45872e85294598d95420","modified":1560318422116},{"_id":"public/2019/06/08/Runtime-ivar/index.html","hash":"9284419fab2dfbb53341b440379534df19d695ac","modified":1560318422116},{"_id":"public/2019/06/08/Runtime-OC对象创建和销毁过程/index.html","hash":"e9bc8d6d0d37cdce30cb8b956ba9a24072b37f41","modified":1560318422116},{"_id":"public/2019/06/07/Runtime-引用计数和Weak表/index.html","hash":"9815aaa772aacbdc053c3ed77ef2f9cced3cbbd8","modified":1560318422116},{"_id":"public/2019/06/07/Runtime-load和initialize/index.html","hash":"ffa66740e56801041015c6ad6de702b4a5913960","modified":1560318422117},{"_id":"public/2019/05/27/iOS基础知识面归纳/index.html","hash":"32b26ad9eecf10f6eae491b773f6dfe074e1be50","modified":1560253287490},{"_id":"public/2019/04/10/开发笔记：flutter中踩过的坑/index.html","hash":"c3afd9b7de330d9e782af0fb630bc86a78bae9a3","modified":1560234783133},{"_id":"public/2018/07/26/iOS常见warning梳理/index.html","hash":"f37bdfbb4409e968797a1a62e5066e4e8243c91f","modified":1560234783133},{"_id":"public/2018/07/18/测试：属性变量、实例变量、成员变量的内存泄漏/index.html","hash":"a604fb6a2c966cc1fa795bddede02821d86504bd","modified":1560234783133},{"_id":"public/2018/01/02/NSNotificationCenter小结/index.html","hash":"b17397cbd252802bc8d6e6e31fe972e3cf405aec","modified":1560234783133},{"_id":"public/2017/03/13/开源库阅读笔记：YYKit-YYModel/index.html","hash":"3c4269cea8ec30e1a9c910a44b85d73867af9070","modified":1560234783133},{"_id":"public/2017/01/04/iOS基础：UIViewController生命周期/index.html","hash":"833b4f3db10502d96bd309c9670fcffe48d6c4d4","modified":1560234783134},{"_id":"public/2016/12/19/开发笔记：iOS中踩过的坑/index.html","hash":"a22a6329ba432a57de9dd05e8016c0839d89db1a","modified":1560234783134},{"_id":"public/2016/10/08/iOS基础：UIControlState/index.html","hash":"b8c8296a693e67c90ee1830cad874dad6edd4cf4","modified":1560234783134},{"_id":"public/2016/09/29/UISwitch在iOS 10中的BUG/index.html","hash":"0aa98e17e25543d9c29f6a456aeffa90596d121f","modified":1560318422117},{"_id":"public/2016/09/21/配置：Sublime-Text3/index.html","hash":"1ed8faff548db0d46c80bd408f0c55e44adcd692","modified":1560234783134},{"_id":"public/2016/09/21/配置：Vim-Git-SVN/index.html","hash":"1d809b2f40e551587165a9c464f8598c14e2c5e9","modified":1560234783134},{"_id":"public/2016/09/21/配置：Xcode快捷键配置/index.html","hash":"bb0077af7dd27a8b0dcb660486ecab24ed4834eb","modified":1560234783134},{"_id":"public/2016/09/17/Objective-C基础知识小结/index.html","hash":"9ad60b1ec3c201151db4df2af90123a21aedd9c5","modified":1560234783134},{"_id":"public/2016/09/03/配置：迁移hexo/index.html","hash":"b8f2efbc435e0b9702f1e6dcd41b80c7b302c0d9","modified":1560234783134},{"_id":"public/2016/08/16/初学Objective-C/index.html","hash":"88b7adb8dccdaf9c46be2a560463e53dae6ff0b4","modified":1560234783134},{"_id":"public/2016/08/14/iOS基础：类、对象和方法/index.html","hash":"80739508037ee42d251bdde105d32b34acb645a1","modified":1560234783134},{"_id":"public/2016/08/11/iOS基础：GCD/index.html","hash":"0ab69aa5787f49fded902758ccc5887c07bf985a","modified":1560234783134},{"_id":"public/archives/index.html","hash":"c1bfbc40f93d1d54d1a19d46d62705f8caa0f13b","modified":1560318422118},{"_id":"public/archives/page/2/index.html","hash":"48385dcf07749394302a88c9632a75a97497519a","modified":1560318422118},{"_id":"public/archives/2016/index.html","hash":"a2591f587276309e90adbe06bf679176e494cbee","modified":1560318422112},{"_id":"public/index.html","hash":"63984550362ed3f44b73a8de99a61359de1c6640","modified":1560318422118},{"_id":"public/page/2/index.html","hash":"4820f9fdee737a3c259a2a711482875248f7031f","modified":1560318422118},{"_id":"public/page/3/index.html","hash":"7ec238ebcbf86f3a4579f0af50c9d8384dc0967f","modified":1560318422118},{"_id":"public/2019/06/11/Flutter-基础知识/index.html","hash":"9d4f58c6e41ddd420da15c7401e7e658484d4ee1","modified":1560318422112},{"_id":"public/categories/Flutter/index.html","hash":"0d666f1d8ea2870570862698301b0f7700e7b3be","modified":1560318422116},{"_id":"public/CNAME","hash":"54735b4b06c1a145cd4ba0ecb1ce8147d94f85cc","modified":1560234783150},{"_id":"public/proxy.pac","hash":"22eb9c7dabf87da364301df511d7b28c69b5253a","modified":1560234783150},{"_id":"public/favicon.ico","hash":"f5c47ad31dc1e6003379c88b562786bc7e2d114f","modified":1560234783150},{"_id":"public/images/avatar.gif","hash":"f5c47ad31dc1e6003379c88b562786bc7e2d114f","modified":1560234783150},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1560234783150},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1560234783150},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1560234783150},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1560234783150},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1560234783150},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1560234783150},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1560234783150},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1560234783150},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1560234783150},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1560234783150},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1560234783151},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1560234783151},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1560234783151},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1560234783151},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1560234783151},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1560234783151},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1560234783151},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1560234783151},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1560234783151},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1560234783151},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1560234783151},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1560234783151},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1560234783151},{"_id":"public/2019/06/11/Flutter-基础知识/Widget生命周期.png","hash":"e0551eae54b6cf7d62c4595dcc2dd4dd44d47303","modified":1560234783151},{"_id":"public/2019/06/11/Flutter-基础知识/架构.jpeg","hash":"dfb9cba724e06719c97b0267329541ed1400d6e9","modified":1560234783152},{"_id":"public/2019/06/11/Flutter-基础知识/线程模型.png","hash":"a717da38d2c9bb020489c2f9b064a8ed4e6f57c2","modified":1560234783152},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1560234783559},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1560234783566},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1560234783567},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1560234783573},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1560234783573},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1560234783573},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1560234783573},{"_id":"public/js/src/post-details.js","hash":"cd067c34beb799df5ee8736352786f8fffe15ae5","modified":1560234783573},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1560234783573},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1560234783573},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1560234783573},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1560234783573},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1560234783573},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1560234783574},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1560234783574},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1560234783574},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1560234783574},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1560234783574},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1560234783574},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1560234783574},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1560234783574},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1560234783574},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1560234783574},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1560234783575},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1560234783575},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1560234783575},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1560234783575},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1560234783575},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1560234783575},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1560234783575},{"_id":"public/css/main.css","hash":"cc835eef046f3e83b60bfd34e2dd4d7f6d0c3829","modified":1560234783575},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1560234783575},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1560234783575},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1560234783575},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1560234783575},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1560234783575},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1560234783575},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1560234783575},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1560234783575},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1560234783575},{"_id":"public/2017/03/13/开源库阅读笔记：YYKit-YYModel/对象模型图.png","hash":"d01543706db03c16aa6ebd09c3f631429cfc4d77","modified":1560234783576},{"_id":"public/2016/09/17/Objective-C基础知识小结/内存空间.png","hash":"226115752acce15576132ce87ebbe837c82ba9d3","modified":1560234783576},{"_id":"public/2016/09/17/Objective-C基础知识小结/调试01.png","hash":"f2ef6cf8a42ac2d08c22ca8d3f80eba65933b107","modified":1560234783576},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1560234783576},{"_id":"public/2016/09/17/Objective-C基础知识小结/调试02.png","hash":"60697049b326a1bb58b9105fdbe9689b0cfdde68","modified":1560234783584},{"_id":"public/2019/05/27/iOS基础知识面归纳/load和initialize.png","hash":"26cf375f1a57d5411572fbc28299d17a9da00b8d","modified":1560234783584},{"_id":"public/2019/05/27/iOS基础知识面归纳/RunLoop.png","hash":"e553eba74426abb91aaab3b7f64bd9c808418ccc","modified":1560234783584},{"_id":"public/2016/09/17/Objective-C基础知识小结/GCD03.png","hash":"59085025d36af03f694f6d71f5924b8ed67d8146","modified":1560234783584},{"_id":"public/2019/05/27/iOS基础知识面归纳/isa.png","hash":"0c90195f414366097cd98312ed20937385786c74","modified":1560234783586},{"_id":"public/2016/09/17/Objective-C基础知识小结/GCD02.png","hash":"c880d194ae36e56673eedb6b1b15022df7cbb66d","modified":1560234783588},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1560234783592},{"_id":"public/2016/09/17/Objective-C基础知识小结/GCD01.png","hash":"923d04db1606dcad66289c1675af1a06b89dcac8","modified":1560234783598},{"_id":"source/_posts/Flutter-踩坑记录.md","hash":"5848e68add1a09ee406678c2259f9ae651026ae5","modified":1560316186359},{"_id":"source/_posts/iOS基础-UIControlState.md","hash":"ebe64ceba1ba0941d4a16f3bbe59edf512a4f57b","modified":1560318371538},{"_id":"source/_posts/iOS基础-NSNotificationCenter小结.md","hash":"6f1495056ff0605a8bdf18182b97366362974cab","modified":1560316204368},{"_id":"source/_posts/iOS基础-GCD.md","hash":"f6dd764958f37d9c7df504c161273dbd63dee9d9","modified":1560318329175},{"_id":"source/_posts/iOS基础-UIViewController生命周期.md","hash":"670c38acfdda78168ce24ec4d2e014c312f9ed6b","modified":1560318374928},{"_id":"source/_posts/iOS基础-知识面归纳.md","hash":"287461bfcf1ebe2bbf40421f68a94428111a25a9","modified":1560316020964},{"_id":"source/_posts/iOS基础-OC基础知识小结.md","hash":"a8cc0fbaa24bfa060835dfa0e5a4c104da0ae1de","modified":1560318368296},{"_id":"source/_posts/iOS基础-初学OC.md","hash":"bcf8a0ce7c6ea89152f8f02f7ec54d25b9f5c509","modified":1560318355320},{"_id":"source/_posts/iOS基础-类、对象和方法.md","hash":"2d32c0cd8972cfc0906966b569c0b738675a4891","modified":1560318365244},{"_id":"source/_posts/iOS基础-属性变量、实例变量、成员变量的内存泄漏.md","hash":"b36e36973f987c0ed809c83a6a9e8fa76b008530","modified":1560316013665},{"_id":"source/_posts/研发效率-iOS常见warning梳理.md","hash":"f04fbc7d1a8a8bf609dc8c2663803c0648eefda6","modified":1560316334041},{"_id":"source/_posts/开源库阅读笔记-YYModel.md","hash":"0d33f9aeaca456725b9779409383b6eb0fee1f52","modified":1560318326829},{"_id":"source/_posts/笔记-iOS中踩坑记录.md","hash":"8109510bd383811ae88fdcbd16e8aa1828783174","modified":1560316305950},{"_id":"source/_posts/配置-SublimeText.md","hash":"0fd9709af7a50e91518599871708d159cb1b960b","modified":1560318338248},{"_id":"source/_posts/配置-Xcode快捷键.md","hash":"c840079dc71d8274ae315a23cae1584967f00ebb","modified":1560318347193},{"_id":"source/_posts/配置-Vim、Git、SVN.md","hash":"d8d67f89251534dedd49952559d6283a657e3e20","modified":1560318342768},{"_id":"source/_posts/配置-迁移hexo.md","hash":"b0e58e7c7dfcfcc5443500c23f00a0dddfddb4d8","modified":1560318334705},{"_id":"public/categories/开源库阅读笔记/index.html","hash":"c661811316a9eb8236199d6320e2a0605873d641","modified":1560318422116},{"_id":"public/categories/研发效率/index.html","hash":"026572410f60b4351ce918d707772946ee462251","modified":1560318422116},{"_id":"public/categories/配置/index.html","hash":"409281f094f7ac0e35ff21ffb525d5e4130ce99f","modified":1560318422116},{"_id":"public/tags/踩坑记录/index.html","hash":"e8d230f2dd548651fa60312ba349d7f65150c2fb","modified":1560318422116},{"_id":"public/tags/YYModel/index.html","hash":"81a46d6ed5971fe3b6c523880ba3781660f4e383","modified":1560318422116},{"_id":"public/2018/07/26/研发效率-iOS常见warning梳理/index.html","hash":"61954562cf4231e47876d752431314bf3a88b446","modified":1560318422117},{"_id":"public/2019/05/27/iOS基础-知识面归纳/index.html","hash":"403bc68763cc4c0405cf88786063417b952bc7ff","modified":1560318422117},{"_id":"public/2019/04/10/Flutter-踩坑记录/index.html","hash":"0e385a62ea7878b43797b8153bcc11d420a6d984","modified":1560318422117},{"_id":"public/2018/07/18/iOS基础-属性变量、实例变量、成员变量的内存泄漏/index.html","hash":"e800e1f1829e2c4dbe196ecfc9eff9d10e1dac98","modified":1560318422117},{"_id":"public/2018/01/02/iOS基础-NSNotificationCenter小结/index.html","hash":"73135808cdaa3ebbdfa26fbe9640864ef31a9594","modified":1560318422117},{"_id":"public/2017/03/13/开源库阅读笔记-YYModel/index.html","hash":"8f002bf02f730150fb80306e650a0941c3f19f27","modified":1560318422117},{"_id":"public/2017/01/04/iOS基础-UIViewController生命周期/index.html","hash":"85e6bca120206b24194c9152a77f2bf196540e45","modified":1560318422117},{"_id":"public/2016/12/19/笔记-iOS中踩坑记录/index.html","hash":"e969a076213b0ae5c46c6ba14815d8960ecc92df","modified":1560318422117},{"_id":"public/2016/10/08/iOS基础-UIControlState/index.html","hash":"ae52602d8da27b48fff0b9a05b45ed84ffb1ebf4","modified":1560318422112},{"_id":"public/2016/09/21/配置-SublimeText/index.html","hash":"2ef324b5fde5807ea68204615c4bf42cead4d282","modified":1560318422117},{"_id":"public/2016/09/21/配置-Vim、Git、SVN/index.html","hash":"eda6ae216d2465e16913e40aa727536756182de4","modified":1560318422117},{"_id":"public/2016/09/17/iOS基础-OC基础知识小结/index.html","hash":"572f7fea5ed218174f00cc87a064aba2a57541b0","modified":1560318422117},{"_id":"public/2016/09/03/配置-迁移hexo/index.html","hash":"511b705995f89ebd37c4ac4052f15285f41b1192","modified":1560318422118},{"_id":"public/2016/09/21/配置-Xcode快捷键/index.html","hash":"225beab61ab5649e7d261b4b115b265f0e8a2951","modified":1560318422117},{"_id":"public/2016/08/16/iOS基础-初学OC/index.html","hash":"6b3ee9b09b31c33418e7586e8540159132e071ec","modified":1560318422118},{"_id":"public/2016/08/14/iOS基础-类、对象和方法/index.html","hash":"db75739392d21e0082da89da82b6e635e90aa22d","modified":1560318422118},{"_id":"public/2016/08/11/iOS基础-GCD/index.html","hash":"3a40e5ce717abc4ee1dc34e9d3d181decbf763da","modified":1560318422118}],"Category":[{"name":"Flutter","_id":"cjwrfi4wt0003rrlw7hdnzttp"},{"name":"Runtime","_id":"cjwrfi4wx0008rrlw1j26l2is"},{"name":"iOS基础知识","_id":"cjwrfi4x1000errlwdf6jw445"},{"name":"笔记","_id":"cjwrfi4xc000xrrlwfswiydih"},{"name":"开发配置","_id":"cjwrfi4xk001krrlw2vhr7q9k"},{"name":"研发效率","_id":"cjwss6z6b000v5mlwglb1ejfl"},{"name":"开源库阅读笔记","_id":"cjwss6z6d00145mlw0h6e0m8j"},{"name":"配置","_id":"cjwss6z6e00185mlwfmvm35ev"}],"Data":[],"Page":[{"title":"categories","date":"2016-08-13T04:06:11.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-08-13 12:06:11\ntype: \"categories\"\n---\n","updated":"2018-08-22T02:11:21.352Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjwrfi4wq0001rrlwecmzgwnk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-08-13T04:06:24.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-08-13 12:06:24\ntype: \"tags\"\n---\n","updated":"2018-08-22T02:11:21.352Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjwrfi52x004crrlwo7m7rm7p","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Flutter-基础知识","date":"2019-06-11T05:37:30.000Z","_content":"# Flutter的架构\n{% asset_img 架构.jpeg Flutter架构 %}\n- Framework：日常开发中直接接触的一层，包括UI组件、动画等。\n- Engine：基于C/C++的引擎，包括绘制引擎skia，Dart VM，Platform Channel。\n- Embedder：嵌入层，将Flutter嵌入到各平台。做原生Plugin、线程管理等。\n\n# 线程模型\n{% asset_img 线程模型.png 线程模型 %}\n参考\n[Flutter Engine线程管理与Dart Isolate机制](https://www.jianshu.com/p/aaa6a8b1d6b0)\n[Flutter Engine 线程模型](https://zhuanlan.zhihu.com/p/64034467)\n\n# Widget生命周期\n{% asset_img Widget生命周期.png Widget生命周期 %}\n参考[flutter中的生命周期](https://segmentfault.com/a/1190000015211309?utm_source=tag-newest)\n\n\n","source":"_posts/Flutter-基础知识.md","raw":"---\ntitle: Flutter-基础知识\ndate: 2019-06-11 13:37:30\ncategories: Flutter\ntags:\n    - Flutter\n---\n# Flutter的架构\n{% asset_img 架构.jpeg Flutter架构 %}\n- Framework：日常开发中直接接触的一层，包括UI组件、动画等。\n- Engine：基于C/C++的引擎，包括绘制引擎skia，Dart VM，Platform Channel。\n- Embedder：嵌入层，将Flutter嵌入到各平台。做原生Plugin、线程管理等。\n\n# 线程模型\n{% asset_img 线程模型.png 线程模型 %}\n参考\n[Flutter Engine线程管理与Dart Isolate机制](https://www.jianshu.com/p/aaa6a8b1d6b0)\n[Flutter Engine 线程模型](https://zhuanlan.zhihu.com/p/64034467)\n\n# Widget生命周期\n{% asset_img Widget生命周期.png Widget生命周期 %}\n参考[flutter中的生命周期](https://segmentfault.com/a/1190000015211309?utm_source=tag-newest)\n\n\n","slug":"Flutter-基础知识","published":1,"updated":"2019-06-11T06:32:19.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwrfi4wn0000rrlwon0uo3oi","content":"<h1 id=\"Flutter的架构\"><a href=\"#Flutter的架构\" class=\"headerlink\" title=\"Flutter的架构\"></a>Flutter的架构</h1><img src=\"/2019/06/11/Flutter-基础知识/架构.jpeg\" title=\"Flutter架构\">\n<ul>\n<li>Framework：日常开发中直接接触的一层，包括UI组件、动画等。</li>\n<li>Engine：基于C/C++的引擎，包括绘制引擎skia，Dart VM，Platform Channel。</li>\n<li>Embedder：嵌入层，将Flutter嵌入到各平台。做原生Plugin、线程管理等。</li>\n</ul>\n<h1 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h1><img src=\"/2019/06/11/Flutter-基础知识/线程模型.png\" title=\"线程模型\">\n<p>参考<br><a href=\"https://www.jianshu.com/p/aaa6a8b1d6b0\" target=\"_blank\" rel=\"noopener\">Flutter Engine线程管理与Dart Isolate机制</a><br><a href=\"https://zhuanlan.zhihu.com/p/64034467\" target=\"_blank\" rel=\"noopener\">Flutter Engine 线程模型</a></p>\n<h1 id=\"Widget生命周期\"><a href=\"#Widget生命周期\" class=\"headerlink\" title=\"Widget生命周期\"></a>Widget生命周期</h1><img src=\"/2019/06/11/Flutter-基础知识/Widget生命周期.png\" title=\"Widget生命周期\">\n<p>参考<a href=\"https://segmentfault.com/a/1190000015211309?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">flutter中的生命周期</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flutter的架构\"><a href=\"#Flutter的架构\" class=\"headerlink\" title=\"Flutter的架构\"></a>Flutter的架构</h1><img src=\"/2019/06/11/Flutter-基础知识/架构.jpeg\" title=\"Flutter架构\">\n<ul>\n<li>Framework：日常开发中直接接触的一层，包括UI组件、动画等。</li>\n<li>Engine：基于C/C++的引擎，包括绘制引擎skia，Dart VM，Platform Channel。</li>\n<li>Embedder：嵌入层，将Flutter嵌入到各平台。做原生Plugin、线程管理等。</li>\n</ul>\n<h1 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h1><img src=\"/2019/06/11/Flutter-基础知识/线程模型.png\" title=\"线程模型\">\n<p>参考<br><a href=\"https://www.jianshu.com/p/aaa6a8b1d6b0\" target=\"_blank\" rel=\"noopener\">Flutter Engine线程管理与Dart Isolate机制</a><br><a href=\"https://zhuanlan.zhihu.com/p/64034467\" target=\"_blank\" rel=\"noopener\">Flutter Engine 线程模型</a></p>\n<h1 id=\"Widget生命周期\"><a href=\"#Widget生命周期\" class=\"headerlink\" title=\"Widget生命周期\"></a>Widget生命周期</h1><img src=\"/2019/06/11/Flutter-基础知识/Widget生命周期.png\" title=\"Widget生命周期\">\n<p>参考<a href=\"https://segmentfault.com/a/1190000015211309?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">flutter中的生命周期</a></p>\n"},{"title":"Runtime-ivar","date":"2019-06-08T08:51:05.000Z","_content":"# ivar本质\n```\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n} OBJC2_UNAVAILABLE;\n/* Use `Class` instead of `struct objc_class *` */\n\nstruct objc_ivar_list {\n    int ivar_count                                           OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n    /* variable length structure */\n    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;\n}                                                            OBJC2_UNAVAILABLE;\n\nstruct objc_ivar {\n    char *ivar_name                                          OBJC2_UNAVAILABLE;\n    char *ivar_type                                          OBJC2_UNAVAILABLE;\n    int ivar_offset                                          OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n}                                                            OBJC2_UNAVAILABLE;\n```\n`objc_class`中包含一个`objc_ivar_list`类型的`ivars`，管理了一个class中所有的成员变量，`objc_ivar_list`中包含`ivar_count`(ivar数量)、`space`(占用内存空间)、`ivar_list`(变长结构体)。\n`objc_ivar`中包含着`ivar_name`(ivar名)、`ivar_type`(ivar类型)、`ivar_offset`(基地址偏移字节)、`space`(占用内存空间)。\n# 变长结构体\n要理解`ivar_list`要首先理解C语言中变长结构体的概念。\n变长结构体最后一个元素是一个没有元素的数组，因此我们可以动态开辟一个比结构体更大的空间，让数组指针指向这块空间。\n需要注意的是`ivar_list`与整个数据结构的内存地址是连续的，若是链表则是不连续的内存地址，连续内存有助于减少内存的碎片化，简化内存管理。\n# 怎么添加ivar\n我们常说OC是一门运行时语言，它有一部分东西是runtime时才决定的，但我们在常规开发中，很少去动态添加ivar。动态添加ivar主要有两种方式：\n1. runtime动态关联对象。\n2. `class_addIvar`，但是它只能在`objc_allocateClassPair`和`objc_allocateClassPair`两个函数之间调用，因此只有在runtime中动态创建class时才能动态添加ivar。\n## 关联对象原理\n其实关联对象的原理与我们在分类中添加一个全局变量的get\\set方法类似，关联对象并没有直接加在class中，而是添加在`AssociationsManager`的hash map里与class关联了起来。\n可以参考[iOS底层原理总结 - 关联对象实现原理](https://blog.csdn.net/olsq93038o99s/article/details/80878983)","source":"_posts/Runtime-ivar.md","raw":"---\ntitle: Runtime-ivar\ndate: 2019-06-08 16:51:05\ncategories: Runtime\ntags:\n    - ivar\n---\n# ivar本质\n```\nstruct objc_class {\n    Class isa  OBJC_ISA_AVAILABILITY;\n\n#if !__OBJC2__\n    Class super_class                                        OBJC2_UNAVAILABLE;\n    const char *name                                         OBJC2_UNAVAILABLE;\n    long version                                             OBJC2_UNAVAILABLE;\n    long info                                                OBJC2_UNAVAILABLE;\n    long instance_size                                       OBJC2_UNAVAILABLE;\n    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;\n    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;\n    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;\n    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;\n#endif\n} OBJC2_UNAVAILABLE;\n/* Use `Class` instead of `struct objc_class *` */\n\nstruct objc_ivar_list {\n    int ivar_count                                           OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n    /* variable length structure */\n    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;\n}                                                            OBJC2_UNAVAILABLE;\n\nstruct objc_ivar {\n    char *ivar_name                                          OBJC2_UNAVAILABLE;\n    char *ivar_type                                          OBJC2_UNAVAILABLE;\n    int ivar_offset                                          OBJC2_UNAVAILABLE;\n#ifdef __LP64__\n    int space                                                OBJC2_UNAVAILABLE;\n#endif\n}                                                            OBJC2_UNAVAILABLE;\n```\n`objc_class`中包含一个`objc_ivar_list`类型的`ivars`，管理了一个class中所有的成员变量，`objc_ivar_list`中包含`ivar_count`(ivar数量)、`space`(占用内存空间)、`ivar_list`(变长结构体)。\n`objc_ivar`中包含着`ivar_name`(ivar名)、`ivar_type`(ivar类型)、`ivar_offset`(基地址偏移字节)、`space`(占用内存空间)。\n# 变长结构体\n要理解`ivar_list`要首先理解C语言中变长结构体的概念。\n变长结构体最后一个元素是一个没有元素的数组，因此我们可以动态开辟一个比结构体更大的空间，让数组指针指向这块空间。\n需要注意的是`ivar_list`与整个数据结构的内存地址是连续的，若是链表则是不连续的内存地址，连续内存有助于减少内存的碎片化，简化内存管理。\n# 怎么添加ivar\n我们常说OC是一门运行时语言，它有一部分东西是runtime时才决定的，但我们在常规开发中，很少去动态添加ivar。动态添加ivar主要有两种方式：\n1. runtime动态关联对象。\n2. `class_addIvar`，但是它只能在`objc_allocateClassPair`和`objc_allocateClassPair`两个函数之间调用，因此只有在runtime中动态创建class时才能动态添加ivar。\n## 关联对象原理\n其实关联对象的原理与我们在分类中添加一个全局变量的get\\set方法类似，关联对象并没有直接加在class中，而是添加在`AssociationsManager`的hash map里与class关联了起来。\n可以参考[iOS底层原理总结 - 关联对象实现原理](https://blog.csdn.net/olsq93038o99s/article/details/80878983)","slug":"Runtime-ivar","published":1,"updated":"2019-06-08T09:19:13.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwrfi4wr0002rrlw6hajc2h5","content":"<h1 id=\"ivar本质\"><a href=\"#ivar本质\" class=\"headerlink\" title=\"ivar本质\"></a>ivar本质</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class &#123;</span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\"></span><br><span class=\"line\">#if !__OBJC2__</span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br><span class=\"line\">/* Use `Class` instead of `struct objc_class *` */</span><br><span class=\"line\"></span><br><span class=\"line\">struct objc_ivar_list &#123;</span><br><span class=\"line\">    int ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#ifdef __LP64__</span><br><span class=\"line\">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    /* variable length structure */</span><br><span class=\"line\">    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br><span class=\"line\">struct objc_ivar &#123;</span><br><span class=\"line\">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#ifdef __LP64__</span><br><span class=\"line\">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>\n<p><code>objc_class</code>中包含一个<code>objc_ivar_list</code>类型的<code>ivars</code>，管理了一个class中所有的成员变量，<code>objc_ivar_list</code>中包含<code>ivar_count</code>(ivar数量)、<code>space</code>(占用内存空间)、<code>ivar_list</code>(变长结构体)。<br><code>objc_ivar</code>中包含着<code>ivar_name</code>(ivar名)、<code>ivar_type</code>(ivar类型)、<code>ivar_offset</code>(基地址偏移字节)、<code>space</code>(占用内存空间)。</p>\n<h1 id=\"变长结构体\"><a href=\"#变长结构体\" class=\"headerlink\" title=\"变长结构体\"></a>变长结构体</h1><p>要理解<code>ivar_list</code>要首先理解C语言中变长结构体的概念。<br>变长结构体最后一个元素是一个没有元素的数组，因此我们可以动态开辟一个比结构体更大的空间，让数组指针指向这块空间。<br>需要注意的是<code>ivar_list</code>与整个数据结构的内存地址是连续的，若是链表则是不连续的内存地址，连续内存有助于减少内存的碎片化，简化内存管理。</p>\n<h1 id=\"怎么添加ivar\"><a href=\"#怎么添加ivar\" class=\"headerlink\" title=\"怎么添加ivar\"></a>怎么添加ivar</h1><p>我们常说OC是一门运行时语言，它有一部分东西是runtime时才决定的，但我们在常规开发中，很少去动态添加ivar。动态添加ivar主要有两种方式：</p>\n<ol>\n<li>runtime动态关联对象。</li>\n<li><code>class_addIvar</code>，但是它只能在<code>objc_allocateClassPair</code>和<code>objc_allocateClassPair</code>两个函数之间调用，因此只有在runtime中动态创建class时才能动态添加ivar。<h2 id=\"关联对象原理\"><a href=\"#关联对象原理\" class=\"headerlink\" title=\"关联对象原理\"></a>关联对象原理</h2>其实关联对象的原理与我们在分类中添加一个全局变量的get\\set方法类似，关联对象并没有直接加在class中，而是添加在<code>AssociationsManager</code>的hash map里与class关联了起来。<br>可以参考<a href=\"https://blog.csdn.net/olsq93038o99s/article/details/80878983\" target=\"_blank\" rel=\"noopener\">iOS底层原理总结 - 关联对象实现原理</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ivar本质\"><a href=\"#ivar本质\" class=\"headerlink\" title=\"ivar本质\"></a>ivar本质</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class &#123;</span><br><span class=\"line\">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\"></span><br><span class=\"line\">#if !__OBJC2__</span><br><span class=\"line\">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125; OBJC2_UNAVAILABLE;</span><br><span class=\"line\">/* Use `Class` instead of `struct objc_class *` */</span><br><span class=\"line\"></span><br><span class=\"line\">struct objc_ivar_list &#123;</span><br><span class=\"line\">    int ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#ifdef __LP64__</span><br><span class=\"line\">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    /* variable length structure */</span><br><span class=\"line\">    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br><span class=\"line\">struct objc_ivar &#123;</span><br><span class=\"line\">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#ifdef __LP64__</span><br><span class=\"line\">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>\n<p><code>objc_class</code>中包含一个<code>objc_ivar_list</code>类型的<code>ivars</code>，管理了一个class中所有的成员变量，<code>objc_ivar_list</code>中包含<code>ivar_count</code>(ivar数量)、<code>space</code>(占用内存空间)、<code>ivar_list</code>(变长结构体)。<br><code>objc_ivar</code>中包含着<code>ivar_name</code>(ivar名)、<code>ivar_type</code>(ivar类型)、<code>ivar_offset</code>(基地址偏移字节)、<code>space</code>(占用内存空间)。</p>\n<h1 id=\"变长结构体\"><a href=\"#变长结构体\" class=\"headerlink\" title=\"变长结构体\"></a>变长结构体</h1><p>要理解<code>ivar_list</code>要首先理解C语言中变长结构体的概念。<br>变长结构体最后一个元素是一个没有元素的数组，因此我们可以动态开辟一个比结构体更大的空间，让数组指针指向这块空间。<br>需要注意的是<code>ivar_list</code>与整个数据结构的内存地址是连续的，若是链表则是不连续的内存地址，连续内存有助于减少内存的碎片化，简化内存管理。</p>\n<h1 id=\"怎么添加ivar\"><a href=\"#怎么添加ivar\" class=\"headerlink\" title=\"怎么添加ivar\"></a>怎么添加ivar</h1><p>我们常说OC是一门运行时语言，它有一部分东西是runtime时才决定的，但我们在常规开发中，很少去动态添加ivar。动态添加ivar主要有两种方式：</p>\n<ol>\n<li>runtime动态关联对象。</li>\n<li><code>class_addIvar</code>，但是它只能在<code>objc_allocateClassPair</code>和<code>objc_allocateClassPair</code>两个函数之间调用，因此只有在runtime中动态创建class时才能动态添加ivar。<h2 id=\"关联对象原理\"><a href=\"#关联对象原理\" class=\"headerlink\" title=\"关联对象原理\"></a>关联对象原理</h2>其实关联对象的原理与我们在分类中添加一个全局变量的get\\set方法类似，关联对象并没有直接加在class中，而是添加在<code>AssociationsManager</code>的hash map里与class关联了起来。<br>可以参考<a href=\"https://blog.csdn.net/olsq93038o99s/article/details/80878983\" target=\"_blank\" rel=\"noopener\">iOS底层原理总结 - 关联对象实现原理</a></li>\n</ol>\n"},{"title":"Runtime-OC对象创建和销毁过程","date":"2019-06-08T07:59:08.000Z","_content":"# 对象创建\nOC的创建对象，如`[[MyClass alloc] init]`，从消息发送角度说，就是给MyClass类对象发了两个消息，逐层lookup找到NSObject中的这两个方法，随后根据MyClass所需内存空间大小分配内存，然后把isa指针指向MyClass，最后将这两个方法加入缓存方法列表。\n那么再往底层看，Runtime具体做了些什么呢，\n## + (id)alloc\n```\n+ (id)alloc {\n    return _objc_rootAlloc(self);\n}\n\nid _objc_rootAlloc(Class cls)\n{\n    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);\n}\n\n// Call [cls alloc] or [cls allocWithZone:nil], with appropriate \n// shortcutting optimizations.\nstatic ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)\n{\n    // 做类型检查\n    if (checkNil && !cls) return nil;\n\n#if __OBJC2__\n    // 若没有实现allocWithZone方法\n    if (! cls->ISA()->hasCustomAWZ()) {\n        // No alloc/allocWithZone implementation. Go straight to the allocator.\n        // fixme store hasCustomAWZ in the non-meta class and \n        // add it to canAllocFast's summary\n        // canAllocFast默认返回false，应该是有一些类做了系统优化直接放到bits里了\n        if (cls->canAllocFast()) {\n            // No ctors, raw isa, etc. Go straight to the metal.\n            bool dtor = cls->hasCxxDtor();\n            id obj = (id)calloc(1, cls->bits.fastInstanceSize());\n            if (!obj) return callBadAllocHandler(cls);\n            obj->initInstanceIsa(cls, dtor);\n            return obj;\n        } else {\n            // Has ctor or raw isa or something. Use the slower path.\n            id obj = class_createInstance(cls, 0);\n            if (!obj) return callBadAllocHandler(cls);\n            return obj;\n        }\n    }\n#endif\n\n    // No shortcuts available.\n    if (allocWithZone) return [cls allocWithZone:nil];\n    return [cls alloc];\n}\n```\n可以看到我们最关心最常用的是`class_createInstance`方法，接下来看看这里面干了些啥。\n```\nid class_createInstance(Class cls, size_t extraBytes)\n{\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n}\n\nstatic __attribute__((always_inline)) id\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct = true, \n                              size_t *outAllocatedSize = nil)\n{\n    if (!cls) return nil;\n\n    assert(cls->isRealized());\n\n    // Read class's info bits all at once for performance\n    bool hasCxxCtor = cls->hasCxxCtor();\n    bool hasCxxDtor = cls->hasCxxDtor();\n    bool fast = cls->canAllocIndexed();\n\n    // 字节对齐，OC对象16字节对齐，一个对象最少16字节，isa 8字节。一个对象的内存地址从其第一个成员开始，也就是从isa指针开始。\n    size_t size = cls->instanceSize(extraBytes);\n    if (outAllocatedSize) *outAllocatedSize = size;\n\n    // 分配内存空间，创建对象\n    id obj;\n    if (!UseGC  &&  !zone  &&  fast) {\n        obj = (id)calloc(1, size);\n        if (!obj) return nil;\n        obj->initInstanceIsa(cls, hasCxxDtor);\n    } else {\n#if SUPPORT_GC\n        if (UseGC) {\n            obj = (id)auto_zone_allocate_object(gc_zone, size,\n                                                AUTO_OBJECT_SCANNED, 0, 1);\n        } else \n#endif\n        if (zone) {\n            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);\n        } else {\n            obj = (id)calloc(1, size);\n        }\n        if (!obj) return nil;\n\n        // Use non-indexed isa on the assumption that they might be \n        // doing something weird with the zone or RR.\n        obj->initIsa(cls);\n    }\n\n    if (cxxConstruct && hasCxxCtor) {\n        obj = _objc_constructOrFree(obj, cls);\n    }\n\n    return obj;\n}\n```\n## + (id)init\n```\n// Replaced by CF (throws an NSException)\n+ (id)init {\n    return (id)self;\n}\n\n- (id)init {\n    return _objc_rootInit(self);\n}\n\nid _objc_rootInit(id obj)\n{\n    // In practice, it will be hard to rely on this function.\n    // Many classes do not properly chain -init calls.\n    return obj;\n}\n```\n苹果并没有做什么事情，让人觉得其实只需要写`[MyClass alloc]`就好了，不过你要是真写出如下代码，是会抛出`EXC_BAD_ACCESS (code=1, address=0x0)`Crash的。\n```\nself.testView = [UIView alloc];\nself.testView.frame = CGRectMake(50, 50, 100, 100);\nself.testView.backgroundColor = [UIColor blueColor];\n[self.view addSubview:self.testView];\n```\n\n# 对象销毁\n```\n// Replaced by NSZombies\n// 应该是与debug时的僵尸对象有关，苹果可能是通过类似方法交换的黑魔法对dealloc做了一些事情。\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid _objc_rootDealloc(id obj) {\n    assert(obj);\n\n    obj->rootDealloc();\n}\n\ninline void objc_object::rootDealloc() {\n    assert(!UseGC);\n    if (isTaggedPointer()) return;\n\n    // 如果没有weak引用 && 没有关联对象 && 没有c++析构 && 没有side table借位\n    // 释放内存空间\n    if (isa.indexed  &&  \n        !isa.weakly_referenced  &&  \n        !isa.has_assoc  &&  \n        !isa.has_cxx_dtor  &&  \n        !isa.has_sidetable_rc) {\n        assert(!sidetable_present());\n        free(this);\n    } else {\n        object_dispose((id)this);\n    }\n}\n```\n再继续看object_dispose方法\n```\nid object_dispose(id obj) {\n    if (!obj) return nil;\n\n    objc_destructInstance(obj);\n    \n#if SUPPORT_GC\n    if (UseGC) {\n        auto_zone_retain(gc_zone, obj); // gc free expects rc==1\n    }\n#endif\n\n    free(obj);\n\n    return nil;\n}\n\n/***********************************************************************\n* objc_destructInstance\n* Destroys an instance without freeing memory. \n* Calls C++ destructors.\n* Calls ARR ivar cleanup.\n* Removes associative references.\n* Returns `obj`. Does nothing if `obj` is nil.\n* Be warned that GC DOES NOT CALL THIS. If you edit this, also edit finalize.\n* CoreFoundation and other clients do call this under GC.\n**********************************************************************/\nvoid *objc_destructInstance(id obj) {\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = !UseGC && obj->hasAssociatedObjects();\n        bool dealloc = !UseGC;\n\n        // This order is important.\n        // 特别强调了这里的时序很重要\n        if (cxx) object_cxxDestruct(obj);               // C++析构函数\n        if (assoc) _object_remove_assocations(obj);     // 移除关联对象\n        if (dealloc) obj->clearDeallocating();          // 清理引用\n    }\n\n    return obj;\n}\n\ninline void objc_object::clearDeallocating() {\n    if (!isa.indexed) {\n        // Slow path for raw pointer isa.\n        // 清理sideTable中的引用计数表\n        sidetable_clearDeallocating();\n    } else if (isa.weakly_referenced  ||  isa.has_sidetable_rc) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        // 清理sideTable中的weak表\n        clearDeallocating_slow();\n    }\n\n    assert(!sidetable_present());\n}\n```","source":"_posts/Runtime-OC对象创建和销毁过程.md","raw":"---\ntitle: Runtime-OC对象创建和销毁过程\ndate: 2019-06-08 15:59:08\ncategories: Runtime\ntags:\n    - OC对象\n---\n# 对象创建\nOC的创建对象，如`[[MyClass alloc] init]`，从消息发送角度说，就是给MyClass类对象发了两个消息，逐层lookup找到NSObject中的这两个方法，随后根据MyClass所需内存空间大小分配内存，然后把isa指针指向MyClass，最后将这两个方法加入缓存方法列表。\n那么再往底层看，Runtime具体做了些什么呢，\n## + (id)alloc\n```\n+ (id)alloc {\n    return _objc_rootAlloc(self);\n}\n\nid _objc_rootAlloc(Class cls)\n{\n    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);\n}\n\n// Call [cls alloc] or [cls allocWithZone:nil], with appropriate \n// shortcutting optimizations.\nstatic ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)\n{\n    // 做类型检查\n    if (checkNil && !cls) return nil;\n\n#if __OBJC2__\n    // 若没有实现allocWithZone方法\n    if (! cls->ISA()->hasCustomAWZ()) {\n        // No alloc/allocWithZone implementation. Go straight to the allocator.\n        // fixme store hasCustomAWZ in the non-meta class and \n        // add it to canAllocFast's summary\n        // canAllocFast默认返回false，应该是有一些类做了系统优化直接放到bits里了\n        if (cls->canAllocFast()) {\n            // No ctors, raw isa, etc. Go straight to the metal.\n            bool dtor = cls->hasCxxDtor();\n            id obj = (id)calloc(1, cls->bits.fastInstanceSize());\n            if (!obj) return callBadAllocHandler(cls);\n            obj->initInstanceIsa(cls, dtor);\n            return obj;\n        } else {\n            // Has ctor or raw isa or something. Use the slower path.\n            id obj = class_createInstance(cls, 0);\n            if (!obj) return callBadAllocHandler(cls);\n            return obj;\n        }\n    }\n#endif\n\n    // No shortcuts available.\n    if (allocWithZone) return [cls allocWithZone:nil];\n    return [cls alloc];\n}\n```\n可以看到我们最关心最常用的是`class_createInstance`方法，接下来看看这里面干了些啥。\n```\nid class_createInstance(Class cls, size_t extraBytes)\n{\n    return _class_createInstanceFromZone(cls, extraBytes, nil);\n}\n\nstatic __attribute__((always_inline)) id\n_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, \n                              bool cxxConstruct = true, \n                              size_t *outAllocatedSize = nil)\n{\n    if (!cls) return nil;\n\n    assert(cls->isRealized());\n\n    // Read class's info bits all at once for performance\n    bool hasCxxCtor = cls->hasCxxCtor();\n    bool hasCxxDtor = cls->hasCxxDtor();\n    bool fast = cls->canAllocIndexed();\n\n    // 字节对齐，OC对象16字节对齐，一个对象最少16字节，isa 8字节。一个对象的内存地址从其第一个成员开始，也就是从isa指针开始。\n    size_t size = cls->instanceSize(extraBytes);\n    if (outAllocatedSize) *outAllocatedSize = size;\n\n    // 分配内存空间，创建对象\n    id obj;\n    if (!UseGC  &&  !zone  &&  fast) {\n        obj = (id)calloc(1, size);\n        if (!obj) return nil;\n        obj->initInstanceIsa(cls, hasCxxDtor);\n    } else {\n#if SUPPORT_GC\n        if (UseGC) {\n            obj = (id)auto_zone_allocate_object(gc_zone, size,\n                                                AUTO_OBJECT_SCANNED, 0, 1);\n        } else \n#endif\n        if (zone) {\n            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);\n        } else {\n            obj = (id)calloc(1, size);\n        }\n        if (!obj) return nil;\n\n        // Use non-indexed isa on the assumption that they might be \n        // doing something weird with the zone or RR.\n        obj->initIsa(cls);\n    }\n\n    if (cxxConstruct && hasCxxCtor) {\n        obj = _objc_constructOrFree(obj, cls);\n    }\n\n    return obj;\n}\n```\n## + (id)init\n```\n// Replaced by CF (throws an NSException)\n+ (id)init {\n    return (id)self;\n}\n\n- (id)init {\n    return _objc_rootInit(self);\n}\n\nid _objc_rootInit(id obj)\n{\n    // In practice, it will be hard to rely on this function.\n    // Many classes do not properly chain -init calls.\n    return obj;\n}\n```\n苹果并没有做什么事情，让人觉得其实只需要写`[MyClass alloc]`就好了，不过你要是真写出如下代码，是会抛出`EXC_BAD_ACCESS (code=1, address=0x0)`Crash的。\n```\nself.testView = [UIView alloc];\nself.testView.frame = CGRectMake(50, 50, 100, 100);\nself.testView.backgroundColor = [UIColor blueColor];\n[self.view addSubview:self.testView];\n```\n\n# 对象销毁\n```\n// Replaced by NSZombies\n// 应该是与debug时的僵尸对象有关，苹果可能是通过类似方法交换的黑魔法对dealloc做了一些事情。\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid _objc_rootDealloc(id obj) {\n    assert(obj);\n\n    obj->rootDealloc();\n}\n\ninline void objc_object::rootDealloc() {\n    assert(!UseGC);\n    if (isTaggedPointer()) return;\n\n    // 如果没有weak引用 && 没有关联对象 && 没有c++析构 && 没有side table借位\n    // 释放内存空间\n    if (isa.indexed  &&  \n        !isa.weakly_referenced  &&  \n        !isa.has_assoc  &&  \n        !isa.has_cxx_dtor  &&  \n        !isa.has_sidetable_rc) {\n        assert(!sidetable_present());\n        free(this);\n    } else {\n        object_dispose((id)this);\n    }\n}\n```\n再继续看object_dispose方法\n```\nid object_dispose(id obj) {\n    if (!obj) return nil;\n\n    objc_destructInstance(obj);\n    \n#if SUPPORT_GC\n    if (UseGC) {\n        auto_zone_retain(gc_zone, obj); // gc free expects rc==1\n    }\n#endif\n\n    free(obj);\n\n    return nil;\n}\n\n/***********************************************************************\n* objc_destructInstance\n* Destroys an instance without freeing memory. \n* Calls C++ destructors.\n* Calls ARR ivar cleanup.\n* Removes associative references.\n* Returns `obj`. Does nothing if `obj` is nil.\n* Be warned that GC DOES NOT CALL THIS. If you edit this, also edit finalize.\n* CoreFoundation and other clients do call this under GC.\n**********************************************************************/\nvoid *objc_destructInstance(id obj) {\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = !UseGC && obj->hasAssociatedObjects();\n        bool dealloc = !UseGC;\n\n        // This order is important.\n        // 特别强调了这里的时序很重要\n        if (cxx) object_cxxDestruct(obj);               // C++析构函数\n        if (assoc) _object_remove_assocations(obj);     // 移除关联对象\n        if (dealloc) obj->clearDeallocating();          // 清理引用\n    }\n\n    return obj;\n}\n\ninline void objc_object::clearDeallocating() {\n    if (!isa.indexed) {\n        // Slow path for raw pointer isa.\n        // 清理sideTable中的引用计数表\n        sidetable_clearDeallocating();\n    } else if (isa.weakly_referenced  ||  isa.has_sidetable_rc) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        // 清理sideTable中的weak表\n        clearDeallocating_slow();\n    }\n\n    assert(!sidetable_present());\n}\n```","slug":"Runtime-OC对象创建和销毁过程","published":1,"updated":"2019-06-08T08:43:08.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwrfi4ww0006rrlwcadjivze","content":"<h1 id=\"对象创建\"><a href=\"#对象创建\" class=\"headerlink\" title=\"对象创建\"></a>对象创建</h1><p>OC的创建对象，如<code>[[MyClass alloc] init]</code>，从消息发送角度说，就是给MyClass类对象发了两个消息，逐层lookup找到NSObject中的这两个方法，随后根据MyClass所需内存空间大小分配内存，然后把isa指针指向MyClass，最后将这两个方法加入缓存方法列表。<br>那么再往底层看，Runtime具体做了些什么呢，</p>\n<h2 id=\"id-alloc\"><a href=\"#id-alloc\" class=\"headerlink\" title=\"+ (id)alloc\"></a>+ (id)alloc</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (id)alloc &#123;</span><br><span class=\"line\">    return _objc_rootAlloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">id _objc_rootAlloc(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span><br><span class=\"line\">// shortcutting optimizations.</span><br><span class=\"line\">static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 做类型检查</span><br><span class=\"line\">    if (checkNil &amp;&amp; !cls) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">#if __OBJC2__</span><br><span class=\"line\">    // 若没有实现allocWithZone方法</span><br><span class=\"line\">    if (! cls-&gt;ISA()-&gt;hasCustomAWZ()) &#123;</span><br><span class=\"line\">        // No alloc/allocWithZone implementation. Go straight to the allocator.</span><br><span class=\"line\">        // fixme store hasCustomAWZ in the non-meta class and </span><br><span class=\"line\">        // add it to canAllocFast&apos;s summary</span><br><span class=\"line\">        // canAllocFast默认返回false，应该是有一些类做了系统优化直接放到bits里了</span><br><span class=\"line\">        if (cls-&gt;canAllocFast()) &#123;</span><br><span class=\"line\">            // No ctors, raw isa, etc. Go straight to the metal.</span><br><span class=\"line\">            bool dtor = cls-&gt;hasCxxDtor();</span><br><span class=\"line\">            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span><br><span class=\"line\">            if (!obj) return callBadAllocHandler(cls);</span><br><span class=\"line\">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class=\"line\">            return obj;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // Has ctor or raw isa or something. Use the slower path.</span><br><span class=\"line\">            id obj = class_createInstance(cls, 0);</span><br><span class=\"line\">            if (!obj) return callBadAllocHandler(cls);</span><br><span class=\"line\">            return obj;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    // No shortcuts available.</span><br><span class=\"line\">    if (allocWithZone) return [cls allocWithZone:nil];</span><br><span class=\"line\">    return [cls alloc];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到我们最关心最常用的是<code>class_createInstance</code>方法，接下来看看这里面干了些啥。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id class_createInstance(Class cls, size_t extraBytes)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static __attribute__((always_inline)) id</span><br><span class=\"line\">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class=\"line\">                              bool cxxConstruct = true, </span><br><span class=\"line\">                              size_t *outAllocatedSize = nil)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!cls) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(cls-&gt;isRealized());</span><br><span class=\"line\"></span><br><span class=\"line\">    // Read class&apos;s info bits all at once for performance</span><br><span class=\"line\">    bool hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class=\"line\">    bool hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class=\"line\">    bool fast = cls-&gt;canAllocIndexed();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 字节对齐，OC对象16字节对齐，一个对象最少16字节，isa 8字节。一个对象的内存地址从其第一个成员开始，也就是从isa指针开始。</span><br><span class=\"line\">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class=\"line\">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 分配内存空间，创建对象</span><br><span class=\"line\">    id obj;</span><br><span class=\"line\">    if (!UseGC  &amp;&amp;  !zone  &amp;&amp;  fast) &#123;</span><br><span class=\"line\">        obj = (id)calloc(1, size);</span><br><span class=\"line\">        if (!obj) return nil;</span><br><span class=\"line\">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">#if SUPPORT_GC</span><br><span class=\"line\">        if (UseGC) &#123;</span><br><span class=\"line\">            obj = (id)auto_zone_allocate_object(gc_zone, size,</span><br><span class=\"line\">                                                AUTO_OBJECT_SCANNED, 0, 1);</span><br><span class=\"line\">        &#125; else </span><br><span class=\"line\">#endif</span><br><span class=\"line\">        if (zone) &#123;</span><br><span class=\"line\">            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            obj = (id)calloc(1, size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (!obj) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Use non-indexed isa on the assumption that they might be </span><br><span class=\"line\">        // doing something weird with the zone or RR.</span><br><span class=\"line\">        obj-&gt;initIsa(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class=\"line\">        obj = _objc_constructOrFree(obj, cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"id-init\"><a href=\"#id-init\" class=\"headerlink\" title=\"+ (id)init\"></a>+ (id)init</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Replaced by CF (throws an NSException)</span><br><span class=\"line\">+ (id)init &#123;</span><br><span class=\"line\">    return (id)self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)init &#123;</span><br><span class=\"line\">    return _objc_rootInit(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">id _objc_rootInit(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // In practice, it will be hard to rely on this function.</span><br><span class=\"line\">    // Many classes do not properly chain -init calls.</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>苹果并没有做什么事情，让人觉得其实只需要写<code>[MyClass alloc]</code>就好了，不过你要是真写出如下代码，是会抛出<code>EXC_BAD_ACCESS (code=1, address=0x0)</code>Crash的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.testView = [UIView alloc];</span><br><span class=\"line\">self.testView.frame = CGRectMake(50, 50, 100, 100);</span><br><span class=\"line\">self.testView.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">[self.view addSubview:self.testView];</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"对象销毁\"><a href=\"#对象销毁\" class=\"headerlink\" title=\"对象销毁\"></a>对象销毁</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Replaced by NSZombies</span><br><span class=\"line\">// 应该是与debug时的僵尸对象有关，苹果可能是通过类似方法交换的黑魔法对dealloc做了一些事情。</span><br><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    _objc_rootDealloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _objc_rootDealloc(id obj) &#123;</span><br><span class=\"line\">    assert(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    obj-&gt;rootDealloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void objc_object::rootDealloc() &#123;</span><br><span class=\"line\">    assert(!UseGC);</span><br><span class=\"line\">    if (isTaggedPointer()) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果没有weak引用 &amp;&amp; 没有关联对象 &amp;&amp; 没有c++析构 &amp;&amp; 没有side table借位</span><br><span class=\"line\">    // 释放内存空间</span><br><span class=\"line\">    if (isa.indexed  &amp;&amp;  </span><br><span class=\"line\">        !isa.weakly_referenced  &amp;&amp;  </span><br><span class=\"line\">        !isa.has_assoc  &amp;&amp;  </span><br><span class=\"line\">        !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class=\"line\">        !isa.has_sidetable_rc) &#123;</span><br><span class=\"line\">        assert(!sidetable_present());</span><br><span class=\"line\">        free(this);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        object_dispose((id)this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再继续看object_dispose方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id object_dispose(id obj) &#123;</span><br><span class=\"line\">    if (!obj) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_destructInstance(obj);</span><br><span class=\"line\">    </span><br><span class=\"line\">#if SUPPORT_GC</span><br><span class=\"line\">    if (UseGC) &#123;</span><br><span class=\"line\">        auto_zone_retain(gc_zone, obj); // gc free expects rc==1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    free(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/***********************************************************************</span><br><span class=\"line\">* objc_destructInstance</span><br><span class=\"line\">* Destroys an instance without freeing memory. </span><br><span class=\"line\">* Calls C++ destructors.</span><br><span class=\"line\">* Calls ARR ivar cleanup.</span><br><span class=\"line\">* Removes associative references.</span><br><span class=\"line\">* Returns `obj`. Does nothing if `obj` is nil.</span><br><span class=\"line\">* Be warned that GC DOES NOT CALL THIS. If you edit this, also edit finalize.</span><br><span class=\"line\">* CoreFoundation and other clients do call this under GC.</span><br><span class=\"line\">**********************************************************************/</span><br><span class=\"line\">void *objc_destructInstance(id obj) &#123;</span><br><span class=\"line\">    if (obj) &#123;</span><br><span class=\"line\">        // Read all of the flags at once for performance.</span><br><span class=\"line\">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class=\"line\">        bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class=\"line\">        bool dealloc = !UseGC;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This order is important.</span><br><span class=\"line\">        // 特别强调了这里的时序很重要</span><br><span class=\"line\">        if (cxx) object_cxxDestruct(obj);               // C++析构函数</span><br><span class=\"line\">        if (assoc) _object_remove_assocations(obj);     // 移除关联对象</span><br><span class=\"line\">        if (dealloc) obj-&gt;clearDeallocating();          // 清理引用</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void objc_object::clearDeallocating() &#123;</span><br><span class=\"line\">    if (!isa.indexed) &#123;</span><br><span class=\"line\">        // Slow path for raw pointer isa.</span><br><span class=\"line\">        // 清理sideTable中的引用计数表</span><br><span class=\"line\">        sidetable_clearDeallocating();</span><br><span class=\"line\">    &#125; else if (isa.weakly_referenced  ||  isa.has_sidetable_rc) &#123;</span><br><span class=\"line\">        // Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class=\"line\">        // 清理sideTable中的weak表</span><br><span class=\"line\">        clearDeallocating_slow();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(!sidetable_present());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"对象创建\"><a href=\"#对象创建\" class=\"headerlink\" title=\"对象创建\"></a>对象创建</h1><p>OC的创建对象，如<code>[[MyClass alloc] init]</code>，从消息发送角度说，就是给MyClass类对象发了两个消息，逐层lookup找到NSObject中的这两个方法，随后根据MyClass所需内存空间大小分配内存，然后把isa指针指向MyClass，最后将这两个方法加入缓存方法列表。<br>那么再往底层看，Runtime具体做了些什么呢，</p>\n<h2 id=\"id-alloc\"><a href=\"#id-alloc\" class=\"headerlink\" title=\"+ (id)alloc\"></a>+ (id)alloc</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (id)alloc &#123;</span><br><span class=\"line\">    return _objc_rootAlloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">id _objc_rootAlloc(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span><br><span class=\"line\">// shortcutting optimizations.</span><br><span class=\"line\">static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 做类型检查</span><br><span class=\"line\">    if (checkNil &amp;&amp; !cls) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">#if __OBJC2__</span><br><span class=\"line\">    // 若没有实现allocWithZone方法</span><br><span class=\"line\">    if (! cls-&gt;ISA()-&gt;hasCustomAWZ()) &#123;</span><br><span class=\"line\">        // No alloc/allocWithZone implementation. Go straight to the allocator.</span><br><span class=\"line\">        // fixme store hasCustomAWZ in the non-meta class and </span><br><span class=\"line\">        // add it to canAllocFast&apos;s summary</span><br><span class=\"line\">        // canAllocFast默认返回false，应该是有一些类做了系统优化直接放到bits里了</span><br><span class=\"line\">        if (cls-&gt;canAllocFast()) &#123;</span><br><span class=\"line\">            // No ctors, raw isa, etc. Go straight to the metal.</span><br><span class=\"line\">            bool dtor = cls-&gt;hasCxxDtor();</span><br><span class=\"line\">            id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize());</span><br><span class=\"line\">            if (!obj) return callBadAllocHandler(cls);</span><br><span class=\"line\">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class=\"line\">            return obj;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            // Has ctor or raw isa or something. Use the slower path.</span><br><span class=\"line\">            id obj = class_createInstance(cls, 0);</span><br><span class=\"line\">            if (!obj) return callBadAllocHandler(cls);</span><br><span class=\"line\">            return obj;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    // No shortcuts available.</span><br><span class=\"line\">    if (allocWithZone) return [cls allocWithZone:nil];</span><br><span class=\"line\">    return [cls alloc];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到我们最关心最常用的是<code>class_createInstance</code>方法，接下来看看这里面干了些啥。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id class_createInstance(Class cls, size_t extraBytes)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return _class_createInstanceFromZone(cls, extraBytes, nil);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static __attribute__((always_inline)) id</span><br><span class=\"line\">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, </span><br><span class=\"line\">                              bool cxxConstruct = true, </span><br><span class=\"line\">                              size_t *outAllocatedSize = nil)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!cls) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(cls-&gt;isRealized());</span><br><span class=\"line\"></span><br><span class=\"line\">    // Read class&apos;s info bits all at once for performance</span><br><span class=\"line\">    bool hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class=\"line\">    bool hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class=\"line\">    bool fast = cls-&gt;canAllocIndexed();</span><br><span class=\"line\"></span><br><span class=\"line\">    // 字节对齐，OC对象16字节对齐，一个对象最少16字节，isa 8字节。一个对象的内存地址从其第一个成员开始，也就是从isa指针开始。</span><br><span class=\"line\">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class=\"line\">    if (outAllocatedSize) *outAllocatedSize = size;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 分配内存空间，创建对象</span><br><span class=\"line\">    id obj;</span><br><span class=\"line\">    if (!UseGC  &amp;&amp;  !zone  &amp;&amp;  fast) &#123;</span><br><span class=\"line\">        obj = (id)calloc(1, size);</span><br><span class=\"line\">        if (!obj) return nil;</span><br><span class=\"line\">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">#if SUPPORT_GC</span><br><span class=\"line\">        if (UseGC) &#123;</span><br><span class=\"line\">            obj = (id)auto_zone_allocate_object(gc_zone, size,</span><br><span class=\"line\">                                                AUTO_OBJECT_SCANNED, 0, 1);</span><br><span class=\"line\">        &#125; else </span><br><span class=\"line\">#endif</span><br><span class=\"line\">        if (zone) &#123;</span><br><span class=\"line\">            obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            obj = (id)calloc(1, size);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (!obj) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Use non-indexed isa on the assumption that they might be </span><br><span class=\"line\">        // doing something weird with the zone or RR.</span><br><span class=\"line\">        obj-&gt;initIsa(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class=\"line\">        obj = _objc_constructOrFree(obj, cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"id-init\"><a href=\"#id-init\" class=\"headerlink\" title=\"+ (id)init\"></a>+ (id)init</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Replaced by CF (throws an NSException)</span><br><span class=\"line\">+ (id)init &#123;</span><br><span class=\"line\">    return (id)self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (id)init &#123;</span><br><span class=\"line\">    return _objc_rootInit(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">id _objc_rootInit(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // In practice, it will be hard to rely on this function.</span><br><span class=\"line\">    // Many classes do not properly chain -init calls.</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>苹果并没有做什么事情，让人觉得其实只需要写<code>[MyClass alloc]</code>就好了，不过你要是真写出如下代码，是会抛出<code>EXC_BAD_ACCESS (code=1, address=0x0)</code>Crash的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.testView = [UIView alloc];</span><br><span class=\"line\">self.testView.frame = CGRectMake(50, 50, 100, 100);</span><br><span class=\"line\">self.testView.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">[self.view addSubview:self.testView];</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"对象销毁\"><a href=\"#对象销毁\" class=\"headerlink\" title=\"对象销毁\"></a>对象销毁</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Replaced by NSZombies</span><br><span class=\"line\">// 应该是与debug时的僵尸对象有关，苹果可能是通过类似方法交换的黑魔法对dealloc做了一些事情。</span><br><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    _objc_rootDealloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _objc_rootDealloc(id obj) &#123;</span><br><span class=\"line\">    assert(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    obj-&gt;rootDealloc();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void objc_object::rootDealloc() &#123;</span><br><span class=\"line\">    assert(!UseGC);</span><br><span class=\"line\">    if (isTaggedPointer()) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 如果没有weak引用 &amp;&amp; 没有关联对象 &amp;&amp; 没有c++析构 &amp;&amp; 没有side table借位</span><br><span class=\"line\">    // 释放内存空间</span><br><span class=\"line\">    if (isa.indexed  &amp;&amp;  </span><br><span class=\"line\">        !isa.weakly_referenced  &amp;&amp;  </span><br><span class=\"line\">        !isa.has_assoc  &amp;&amp;  </span><br><span class=\"line\">        !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class=\"line\">        !isa.has_sidetable_rc) &#123;</span><br><span class=\"line\">        assert(!sidetable_present());</span><br><span class=\"line\">        free(this);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        object_dispose((id)this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再继续看object_dispose方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id object_dispose(id obj) &#123;</span><br><span class=\"line\">    if (!obj) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_destructInstance(obj);</span><br><span class=\"line\">    </span><br><span class=\"line\">#if SUPPORT_GC</span><br><span class=\"line\">    if (UseGC) &#123;</span><br><span class=\"line\">        auto_zone_retain(gc_zone, obj); // gc free expects rc==1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    free(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/***********************************************************************</span><br><span class=\"line\">* objc_destructInstance</span><br><span class=\"line\">* Destroys an instance without freeing memory. </span><br><span class=\"line\">* Calls C++ destructors.</span><br><span class=\"line\">* Calls ARR ivar cleanup.</span><br><span class=\"line\">* Removes associative references.</span><br><span class=\"line\">* Returns `obj`. Does nothing if `obj` is nil.</span><br><span class=\"line\">* Be warned that GC DOES NOT CALL THIS. If you edit this, also edit finalize.</span><br><span class=\"line\">* CoreFoundation and other clients do call this under GC.</span><br><span class=\"line\">**********************************************************************/</span><br><span class=\"line\">void *objc_destructInstance(id obj) &#123;</span><br><span class=\"line\">    if (obj) &#123;</span><br><span class=\"line\">        // Read all of the flags at once for performance.</span><br><span class=\"line\">        bool cxx = obj-&gt;hasCxxDtor();</span><br><span class=\"line\">        bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects();</span><br><span class=\"line\">        bool dealloc = !UseGC;</span><br><span class=\"line\"></span><br><span class=\"line\">        // This order is important.</span><br><span class=\"line\">        // 特别强调了这里的时序很重要</span><br><span class=\"line\">        if (cxx) object_cxxDestruct(obj);               // C++析构函数</span><br><span class=\"line\">        if (assoc) _object_remove_assocations(obj);     // 移除关联对象</span><br><span class=\"line\">        if (dealloc) obj-&gt;clearDeallocating();          // 清理引用</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">inline void objc_object::clearDeallocating() &#123;</span><br><span class=\"line\">    if (!isa.indexed) &#123;</span><br><span class=\"line\">        // Slow path for raw pointer isa.</span><br><span class=\"line\">        // 清理sideTable中的引用计数表</span><br><span class=\"line\">        sidetable_clearDeallocating();</span><br><span class=\"line\">    &#125; else if (isa.weakly_referenced  ||  isa.has_sidetable_rc) &#123;</span><br><span class=\"line\">        // Slow path for non-pointer isa with weak refs and/or side table data.</span><br><span class=\"line\">        // 清理sideTable中的weak表</span><br><span class=\"line\">        clearDeallocating_slow();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    assert(!sidetable_present());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Runtime-load和initialize","date":"2019-06-07T06:02:55.000Z","_content":"[Load和Initialize往死了问是一种怎样的体验？](https://www.jianshu.com/p/bd82ef5ea186)这篇blog有很好的参考价值，不过有一些细节仍然存在错误。\n\n`+ load()`方法，顾名思义是类的加载方法，在`main()`函数之前调用，其官方文档如下：\n```\nInvoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.\n\n当类（Class）或者类别（Category）加入Runtime中时（就是被引用的时候）。\n实现该方法，可以在加载时做一些类特有的操作。\n\nDiscussion\n\nThe load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.\n\nThe order of initialization is as follows:\n\nAll initializers in any framework you link to.\n调用所有的Framework中的初始化方法\n\nAll +load methods in your image.\n调用所有的+load方法\n\nAll C++ static initializers and C/C++ attribute(constructor) functions in your image.\n调用C++的静态初始化方及C/C++中的attribute(constructor)函数\n\nAll initializers in frameworks that link to you.\n调用所有链接到目标文件的framework中的初始化方法\n\nIn addition:\n\nA class’s +load method is called after all of its superclasses’ +load methods.\n一个类的+load方法在其父类的+load方法后调用\n\nA category +load method is called after the class’s own +load method.\n一个Category的+load方法在被其扩展的类的自有+load方法后调用\n\nIn a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.\n在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。\n```\n\n`+ initialize()`方法，顾名思义即类的初始化方法，其官方文档如下：\n```\nInitializes the class before it receives its first message.\n\n在这个类接收第一条消息之前调用。\n\nDiscussion\n\nThe runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.\n\nRuntime在一个程序中每一个类的一个程序中发送一个初始化一次，或是从它继承的任何类中，都是在程序中发送第一条消息。（因此，当该类不使用时，该方法可能永远不会被调用。）运行时发送一个线程安全的方式初始化消息。父类的调用一定在子类之前。\n```\n\n其基础特征及调用时序可以在文档中有一个大概的了解，然后我们在这个基础上提出问题。\n前提：A类、B类，均实现其load及initialize方法，B为A的子类，另外C1、C2为A的分类。\n1. 不做任何操作，求时序。\n2. 对A类发消息，求时序。\n3. 对B类发消息，求时序。\n此后问题删除分类。\n4. 先对A类发消息，再对B类发消息，求时序。\n5. 先对B类发消息，再对A类发消息，求时序。\n6. 删除B类initialize方法，先对A类发消息，再对B类发消息，求时序。\n7. 在A类的load方法中对B类发消息，此外对A类发消息，求时序。\n8. 取消B类和A类的继承关系，改为继承NSObject，条件同问题7，求时序。\n\n输入如下：\n```\n问题1：\n2019-06-07 14:25:28.996053+0800 LKTestOC[59335:5384227] A: father load\n2019-06-07 14:25:28.996694+0800 LKTestOC[59335:5384227] B: son load\n2019-06-07 14:25:28.996812+0800 LKTestOC[59335:5384227] C1: category load\n2019-06-07 14:25:28.996881+0800 LKTestOC[59335:5384227] C2: category load\n结论：load方法时序 父类->子类->分类，不会覆盖，且与消息发送无关。\n\n问题2：\n2019-06-07 14:26:33.960364+0800 LKTestOC[59510:5385993] A: father load\n2019-06-07 14:26:33.960938+0800 LKTestOC[59510:5385993] B: son load\n2019-06-07 14:26:33.961009+0800 LKTestOC[59510:5385993] C1: category load\n2019-06-07 14:26:33.961078+0800 LKTestOC[59510:5385993] C2: category load\n2019-06-07 14:26:34.069072+0800 LKTestOC[59510:5385993] C2: category initialize\n结论：initialize方法在消息发送后调用，会覆盖，分类时序最后，且与主类是否import分类无关。\n\n问题3：\n2019-06-07 14:32:15.164806+0800 LKTestOC[60397:5393459] A: father load\n2019-06-07 14:32:15.165367+0800 LKTestOC[60397:5393459] B: son load\n2019-06-07 14:32:15.165457+0800 LKTestOC[60397:5393459] C1: category load\n2019-06-07 14:32:15.165530+0800 LKTestOC[60397:5393459] C2: category load\n2019-06-07 14:32:15.269258+0800 LKTestOC[60397:5393459] C2: category initialize\n2019-06-07 14:32:15.269361+0800 LKTestOC[60397:5393459] B: son initialize\n结论：initialize方法时序 父类->分类->子类。\n\n问题4、5：\n2019-06-07 14:33:54.319935+0800 LKTestOC[60679:5396081] A: father load\n2019-06-07 14:33:54.320518+0800 LKTestOC[60679:5396081] B: son load\n2019-06-07 14:33:54.466408+0800 LKTestOC[60679:5396081] A: father initialize\n2019-06-07 14:33:54.466562+0800 LKTestOC[60679:5396081] B: son initialize\n结论：子类的initliaze会自动调用父类方法，且每个类初始化时只会调用一次initliaze。\n\n问题6：\n2019-06-07 14:38:39.735874+0800 LKTestOC[61421:5403318] A: father load\n2019-06-07 14:38:39.736519+0800 LKTestOC[61421:5403318] B: son load\n2019-06-07 14:38:39.921747+0800 LKTestOC[61421:5403318] A: father initialize\n2019-06-07 14:38:39.921889+0800 LKTestOC[61421:5403318] A: father initialize\n结论：如官方文档所说，子类未实现intialize时父类会调用多次，此处要重点注意，如果想利用initialize做懒加载，需防止调用多次，可利用(self == [ClassName self])做判断。\n\n问题7：\n2019-06-07 14:43:10.949354+0800 LKTestOC[62160:5409931] A: father initialize\n2019-06-07 14:43:10.949928+0800 LKTestOC[62160:5409931] B: son initialize\n2019-06-07 14:43:11.008578+0800 LKTestOC[62160:5409931] A: father load\n2019-06-07 14:43:11.008811+0800 LKTestOC[62160:5409931] B: son load\n结论：initialize方法不一定在main()之后，严格遵循发送消息时调用。\n\n问题8：\n2019-06-07 14:44:12.102702+0800 LKTestOC[62327:5411529] B: son initialize\n2019-06-07 14:44:12.105044+0800 LKTestOC[62327:5411529] A: father load\n2019-06-07 14:44:12.105306+0800 LKTestOC[62327:5411529] B: son load\n结论：符合预期。\n```\n","source":"_posts/Runtime-load和initialize.md","raw":"---\ntitle: Runtime-load和initialize\ndate: 2019-06-07 14:02:55\ncategories: Runtime\ntags:\n    - load\n    - initialize\n---\n[Load和Initialize往死了问是一种怎样的体验？](https://www.jianshu.com/p/bd82ef5ea186)这篇blog有很好的参考价值，不过有一些细节仍然存在错误。\n\n`+ load()`方法，顾名思义是类的加载方法，在`main()`函数之前调用，其官方文档如下：\n```\nInvoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.\n\n当类（Class）或者类别（Category）加入Runtime中时（就是被引用的时候）。\n实现该方法，可以在加载时做一些类特有的操作。\n\nDiscussion\n\nThe load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.\n\nThe order of initialization is as follows:\n\nAll initializers in any framework you link to.\n调用所有的Framework中的初始化方法\n\nAll +load methods in your image.\n调用所有的+load方法\n\nAll C++ static initializers and C/C++ attribute(constructor) functions in your image.\n调用C++的静态初始化方及C/C++中的attribute(constructor)函数\n\nAll initializers in frameworks that link to you.\n调用所有链接到目标文件的framework中的初始化方法\n\nIn addition:\n\nA class’s +load method is called after all of its superclasses’ +load methods.\n一个类的+load方法在其父类的+load方法后调用\n\nA category +load method is called after the class’s own +load method.\n一个Category的+load方法在被其扩展的类的自有+load方法后调用\n\nIn a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.\n在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。\n```\n\n`+ initialize()`方法，顾名思义即类的初始化方法，其官方文档如下：\n```\nInitializes the class before it receives its first message.\n\n在这个类接收第一条消息之前调用。\n\nDiscussion\n\nThe runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.\n\nRuntime在一个程序中每一个类的一个程序中发送一个初始化一次，或是从它继承的任何类中，都是在程序中发送第一条消息。（因此，当该类不使用时，该方法可能永远不会被调用。）运行时发送一个线程安全的方式初始化消息。父类的调用一定在子类之前。\n```\n\n其基础特征及调用时序可以在文档中有一个大概的了解，然后我们在这个基础上提出问题。\n前提：A类、B类，均实现其load及initialize方法，B为A的子类，另外C1、C2为A的分类。\n1. 不做任何操作，求时序。\n2. 对A类发消息，求时序。\n3. 对B类发消息，求时序。\n此后问题删除分类。\n4. 先对A类发消息，再对B类发消息，求时序。\n5. 先对B类发消息，再对A类发消息，求时序。\n6. 删除B类initialize方法，先对A类发消息，再对B类发消息，求时序。\n7. 在A类的load方法中对B类发消息，此外对A类发消息，求时序。\n8. 取消B类和A类的继承关系，改为继承NSObject，条件同问题7，求时序。\n\n输入如下：\n```\n问题1：\n2019-06-07 14:25:28.996053+0800 LKTestOC[59335:5384227] A: father load\n2019-06-07 14:25:28.996694+0800 LKTestOC[59335:5384227] B: son load\n2019-06-07 14:25:28.996812+0800 LKTestOC[59335:5384227] C1: category load\n2019-06-07 14:25:28.996881+0800 LKTestOC[59335:5384227] C2: category load\n结论：load方法时序 父类->子类->分类，不会覆盖，且与消息发送无关。\n\n问题2：\n2019-06-07 14:26:33.960364+0800 LKTestOC[59510:5385993] A: father load\n2019-06-07 14:26:33.960938+0800 LKTestOC[59510:5385993] B: son load\n2019-06-07 14:26:33.961009+0800 LKTestOC[59510:5385993] C1: category load\n2019-06-07 14:26:33.961078+0800 LKTestOC[59510:5385993] C2: category load\n2019-06-07 14:26:34.069072+0800 LKTestOC[59510:5385993] C2: category initialize\n结论：initialize方法在消息发送后调用，会覆盖，分类时序最后，且与主类是否import分类无关。\n\n问题3：\n2019-06-07 14:32:15.164806+0800 LKTestOC[60397:5393459] A: father load\n2019-06-07 14:32:15.165367+0800 LKTestOC[60397:5393459] B: son load\n2019-06-07 14:32:15.165457+0800 LKTestOC[60397:5393459] C1: category load\n2019-06-07 14:32:15.165530+0800 LKTestOC[60397:5393459] C2: category load\n2019-06-07 14:32:15.269258+0800 LKTestOC[60397:5393459] C2: category initialize\n2019-06-07 14:32:15.269361+0800 LKTestOC[60397:5393459] B: son initialize\n结论：initialize方法时序 父类->分类->子类。\n\n问题4、5：\n2019-06-07 14:33:54.319935+0800 LKTestOC[60679:5396081] A: father load\n2019-06-07 14:33:54.320518+0800 LKTestOC[60679:5396081] B: son load\n2019-06-07 14:33:54.466408+0800 LKTestOC[60679:5396081] A: father initialize\n2019-06-07 14:33:54.466562+0800 LKTestOC[60679:5396081] B: son initialize\n结论：子类的initliaze会自动调用父类方法，且每个类初始化时只会调用一次initliaze。\n\n问题6：\n2019-06-07 14:38:39.735874+0800 LKTestOC[61421:5403318] A: father load\n2019-06-07 14:38:39.736519+0800 LKTestOC[61421:5403318] B: son load\n2019-06-07 14:38:39.921747+0800 LKTestOC[61421:5403318] A: father initialize\n2019-06-07 14:38:39.921889+0800 LKTestOC[61421:5403318] A: father initialize\n结论：如官方文档所说，子类未实现intialize时父类会调用多次，此处要重点注意，如果想利用initialize做懒加载，需防止调用多次，可利用(self == [ClassName self])做判断。\n\n问题7：\n2019-06-07 14:43:10.949354+0800 LKTestOC[62160:5409931] A: father initialize\n2019-06-07 14:43:10.949928+0800 LKTestOC[62160:5409931] B: son initialize\n2019-06-07 14:43:11.008578+0800 LKTestOC[62160:5409931] A: father load\n2019-06-07 14:43:11.008811+0800 LKTestOC[62160:5409931] B: son load\n结论：initialize方法不一定在main()之后，严格遵循发送消息时调用。\n\n问题8：\n2019-06-07 14:44:12.102702+0800 LKTestOC[62327:5411529] B: son initialize\n2019-06-07 14:44:12.105044+0800 LKTestOC[62327:5411529] A: father load\n2019-06-07 14:44:12.105306+0800 LKTestOC[62327:5411529] B: son load\n结论：符合预期。\n```\n","slug":"Runtime-load和initialize","published":1,"updated":"2019-06-07T06:44:38.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwrfi4wz000brrlwm8jz8xq5","content":"<p><a href=\"https://www.jianshu.com/p/bd82ef5ea186\" target=\"_blank\" rel=\"noopener\">Load和Initialize往死了问是一种怎样的体验？</a>这篇blog有很好的参考价值，不过有一些细节仍然存在错误。</p>\n<p><code>+ load()</code>方法，顾名思义是类的加载方法，在<code>main()</code>函数之前调用，其官方文档如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</span><br><span class=\"line\"></span><br><span class=\"line\">当类（Class）或者类别（Category）加入Runtime中时（就是被引用的时候）。</span><br><span class=\"line\">实现该方法，可以在加载时做一些类特有的操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Discussion</span><br><span class=\"line\"></span><br><span class=\"line\">The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</span><br><span class=\"line\"></span><br><span class=\"line\">The order of initialization is as follows:</span><br><span class=\"line\"></span><br><span class=\"line\">All initializers in any framework you link to.</span><br><span class=\"line\">调用所有的Framework中的初始化方法</span><br><span class=\"line\"></span><br><span class=\"line\">All +load methods in your image.</span><br><span class=\"line\">调用所有的+load方法</span><br><span class=\"line\"></span><br><span class=\"line\">All C++ static initializers and C/C++ attribute(constructor) functions in your image.</span><br><span class=\"line\">调用C++的静态初始化方及C/C++中的attribute(constructor)函数</span><br><span class=\"line\"></span><br><span class=\"line\">All initializers in frameworks that link to you.</span><br><span class=\"line\">调用所有链接到目标文件的framework中的初始化方法</span><br><span class=\"line\"></span><br><span class=\"line\">In addition:</span><br><span class=\"line\"></span><br><span class=\"line\">A class’s +load method is called after all of its superclasses’ +load methods.</span><br><span class=\"line\">一个类的+load方法在其父类的+load方法后调用</span><br><span class=\"line\"></span><br><span class=\"line\">A category +load method is called after the class’s own +load method.</span><br><span class=\"line\">一个Category的+load方法在被其扩展的类的自有+load方法后调用</span><br><span class=\"line\"></span><br><span class=\"line\">In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</span><br><span class=\"line\">在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。</span><br></pre></td></tr></table></figure></p>\n<p><code>+ initialize()</code>方法，顾名思义即类的初始化方法，其官方文档如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Initializes the class before it receives its first message.</span><br><span class=\"line\"></span><br><span class=\"line\">在这个类接收第一条消息之前调用。</span><br><span class=\"line\"></span><br><span class=\"line\">Discussion</span><br><span class=\"line\"></span><br><span class=\"line\">The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.</span><br><span class=\"line\"></span><br><span class=\"line\">Runtime在一个程序中每一个类的一个程序中发送一个初始化一次，或是从它继承的任何类中，都是在程序中发送第一条消息。（因此，当该类不使用时，该方法可能永远不会被调用。）运行时发送一个线程安全的方式初始化消息。父类的调用一定在子类之前。</span><br></pre></td></tr></table></figure></p>\n<p>其基础特征及调用时序可以在文档中有一个大概的了解，然后我们在这个基础上提出问题。<br>前提：A类、B类，均实现其load及initialize方法，B为A的子类，另外C1、C2为A的分类。</p>\n<ol>\n<li>不做任何操作，求时序。</li>\n<li>对A类发消息，求时序。</li>\n<li>对B类发消息，求时序。<br>此后问题删除分类。</li>\n<li>先对A类发消息，再对B类发消息，求时序。</li>\n<li>先对B类发消息，再对A类发消息，求时序。</li>\n<li>删除B类initialize方法，先对A类发消息，再对B类发消息，求时序。</li>\n<li>在A类的load方法中对B类发消息，此外对A类发消息，求时序。</li>\n<li>取消B类和A类的继承关系，改为继承NSObject，条件同问题7，求时序。</li>\n</ol>\n<p>输入如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题1：</span><br><span class=\"line\">2019-06-07 14:25:28.996053+0800 LKTestOC[59335:5384227] A: father load</span><br><span class=\"line\">2019-06-07 14:25:28.996694+0800 LKTestOC[59335:5384227] B: son load</span><br><span class=\"line\">2019-06-07 14:25:28.996812+0800 LKTestOC[59335:5384227] C1: category load</span><br><span class=\"line\">2019-06-07 14:25:28.996881+0800 LKTestOC[59335:5384227] C2: category load</span><br><span class=\"line\">结论：load方法时序 父类-&gt;子类-&gt;分类，不会覆盖，且与消息发送无关。</span><br><span class=\"line\"></span><br><span class=\"line\">问题2：</span><br><span class=\"line\">2019-06-07 14:26:33.960364+0800 LKTestOC[59510:5385993] A: father load</span><br><span class=\"line\">2019-06-07 14:26:33.960938+0800 LKTestOC[59510:5385993] B: son load</span><br><span class=\"line\">2019-06-07 14:26:33.961009+0800 LKTestOC[59510:5385993] C1: category load</span><br><span class=\"line\">2019-06-07 14:26:33.961078+0800 LKTestOC[59510:5385993] C2: category load</span><br><span class=\"line\">2019-06-07 14:26:34.069072+0800 LKTestOC[59510:5385993] C2: category initialize</span><br><span class=\"line\">结论：initialize方法在消息发送后调用，会覆盖，分类时序最后，且与主类是否import分类无关。</span><br><span class=\"line\"></span><br><span class=\"line\">问题3：</span><br><span class=\"line\">2019-06-07 14:32:15.164806+0800 LKTestOC[60397:5393459] A: father load</span><br><span class=\"line\">2019-06-07 14:32:15.165367+0800 LKTestOC[60397:5393459] B: son load</span><br><span class=\"line\">2019-06-07 14:32:15.165457+0800 LKTestOC[60397:5393459] C1: category load</span><br><span class=\"line\">2019-06-07 14:32:15.165530+0800 LKTestOC[60397:5393459] C2: category load</span><br><span class=\"line\">2019-06-07 14:32:15.269258+0800 LKTestOC[60397:5393459] C2: category initialize</span><br><span class=\"line\">2019-06-07 14:32:15.269361+0800 LKTestOC[60397:5393459] B: son initialize</span><br><span class=\"line\">结论：initialize方法时序 父类-&gt;分类-&gt;子类。</span><br><span class=\"line\"></span><br><span class=\"line\">问题4、5：</span><br><span class=\"line\">2019-06-07 14:33:54.319935+0800 LKTestOC[60679:5396081] A: father load</span><br><span class=\"line\">2019-06-07 14:33:54.320518+0800 LKTestOC[60679:5396081] B: son load</span><br><span class=\"line\">2019-06-07 14:33:54.466408+0800 LKTestOC[60679:5396081] A: father initialize</span><br><span class=\"line\">2019-06-07 14:33:54.466562+0800 LKTestOC[60679:5396081] B: son initialize</span><br><span class=\"line\">结论：子类的initliaze会自动调用父类方法，且每个类初始化时只会调用一次initliaze。</span><br><span class=\"line\"></span><br><span class=\"line\">问题6：</span><br><span class=\"line\">2019-06-07 14:38:39.735874+0800 LKTestOC[61421:5403318] A: father load</span><br><span class=\"line\">2019-06-07 14:38:39.736519+0800 LKTestOC[61421:5403318] B: son load</span><br><span class=\"line\">2019-06-07 14:38:39.921747+0800 LKTestOC[61421:5403318] A: father initialize</span><br><span class=\"line\">2019-06-07 14:38:39.921889+0800 LKTestOC[61421:5403318] A: father initialize</span><br><span class=\"line\">结论：如官方文档所说，子类未实现intialize时父类会调用多次，此处要重点注意，如果想利用initialize做懒加载，需防止调用多次，可利用(self == [ClassName self])做判断。</span><br><span class=\"line\"></span><br><span class=\"line\">问题7：</span><br><span class=\"line\">2019-06-07 14:43:10.949354+0800 LKTestOC[62160:5409931] A: father initialize</span><br><span class=\"line\">2019-06-07 14:43:10.949928+0800 LKTestOC[62160:5409931] B: son initialize</span><br><span class=\"line\">2019-06-07 14:43:11.008578+0800 LKTestOC[62160:5409931] A: father load</span><br><span class=\"line\">2019-06-07 14:43:11.008811+0800 LKTestOC[62160:5409931] B: son load</span><br><span class=\"line\">结论：initialize方法不一定在main()之后，严格遵循发送消息时调用。</span><br><span class=\"line\"></span><br><span class=\"line\">问题8：</span><br><span class=\"line\">2019-06-07 14:44:12.102702+0800 LKTestOC[62327:5411529] B: son initialize</span><br><span class=\"line\">2019-06-07 14:44:12.105044+0800 LKTestOC[62327:5411529] A: father load</span><br><span class=\"line\">2019-06-07 14:44:12.105306+0800 LKTestOC[62327:5411529] B: son load</span><br><span class=\"line\">结论：符合预期。</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.jianshu.com/p/bd82ef5ea186\" target=\"_blank\" rel=\"noopener\">Load和Initialize往死了问是一种怎样的体验？</a>这篇blog有很好的参考价值，不过有一些细节仍然存在错误。</p>\n<p><code>+ load()</code>方法，顾名思义是类的加载方法，在<code>main()</code>函数之前调用，其官方文档如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.</span><br><span class=\"line\"></span><br><span class=\"line\">当类（Class）或者类别（Category）加入Runtime中时（就是被引用的时候）。</span><br><span class=\"line\">实现该方法，可以在加载时做一些类特有的操作。</span><br><span class=\"line\"></span><br><span class=\"line\">Discussion</span><br><span class=\"line\"></span><br><span class=\"line\">The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</span><br><span class=\"line\"></span><br><span class=\"line\">The order of initialization is as follows:</span><br><span class=\"line\"></span><br><span class=\"line\">All initializers in any framework you link to.</span><br><span class=\"line\">调用所有的Framework中的初始化方法</span><br><span class=\"line\"></span><br><span class=\"line\">All +load methods in your image.</span><br><span class=\"line\">调用所有的+load方法</span><br><span class=\"line\"></span><br><span class=\"line\">All C++ static initializers and C/C++ attribute(constructor) functions in your image.</span><br><span class=\"line\">调用C++的静态初始化方及C/C++中的attribute(constructor)函数</span><br><span class=\"line\"></span><br><span class=\"line\">All initializers in frameworks that link to you.</span><br><span class=\"line\">调用所有链接到目标文件的framework中的初始化方法</span><br><span class=\"line\"></span><br><span class=\"line\">In addition:</span><br><span class=\"line\"></span><br><span class=\"line\">A class’s +load method is called after all of its superclasses’ +load methods.</span><br><span class=\"line\">一个类的+load方法在其父类的+load方法后调用</span><br><span class=\"line\"></span><br><span class=\"line\">A category +load method is called after the class’s own +load method.</span><br><span class=\"line\">一个Category的+load方法在被其扩展的类的自有+load方法后调用</span><br><span class=\"line\"></span><br><span class=\"line\">In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</span><br><span class=\"line\">在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。</span><br></pre></td></tr></table></figure></p>\n<p><code>+ initialize()</code>方法，顾名思义即类的初始化方法，其官方文档如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Initializes the class before it receives its first message.</span><br><span class=\"line\"></span><br><span class=\"line\">在这个类接收第一条消息之前调用。</span><br><span class=\"line\"></span><br><span class=\"line\">Discussion</span><br><span class=\"line\"></span><br><span class=\"line\">The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.</span><br><span class=\"line\"></span><br><span class=\"line\">Runtime在一个程序中每一个类的一个程序中发送一个初始化一次，或是从它继承的任何类中，都是在程序中发送第一条消息。（因此，当该类不使用时，该方法可能永远不会被调用。）运行时发送一个线程安全的方式初始化消息。父类的调用一定在子类之前。</span><br></pre></td></tr></table></figure></p>\n<p>其基础特征及调用时序可以在文档中有一个大概的了解，然后我们在这个基础上提出问题。<br>前提：A类、B类，均实现其load及initialize方法，B为A的子类，另外C1、C2为A的分类。</p>\n<ol>\n<li>不做任何操作，求时序。</li>\n<li>对A类发消息，求时序。</li>\n<li>对B类发消息，求时序。<br>此后问题删除分类。</li>\n<li>先对A类发消息，再对B类发消息，求时序。</li>\n<li>先对B类发消息，再对A类发消息，求时序。</li>\n<li>删除B类initialize方法，先对A类发消息，再对B类发消息，求时序。</li>\n<li>在A类的load方法中对B类发消息，此外对A类发消息，求时序。</li>\n<li>取消B类和A类的继承关系，改为继承NSObject，条件同问题7，求时序。</li>\n</ol>\n<p>输入如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">问题1：</span><br><span class=\"line\">2019-06-07 14:25:28.996053+0800 LKTestOC[59335:5384227] A: father load</span><br><span class=\"line\">2019-06-07 14:25:28.996694+0800 LKTestOC[59335:5384227] B: son load</span><br><span class=\"line\">2019-06-07 14:25:28.996812+0800 LKTestOC[59335:5384227] C1: category load</span><br><span class=\"line\">2019-06-07 14:25:28.996881+0800 LKTestOC[59335:5384227] C2: category load</span><br><span class=\"line\">结论：load方法时序 父类-&gt;子类-&gt;分类，不会覆盖，且与消息发送无关。</span><br><span class=\"line\"></span><br><span class=\"line\">问题2：</span><br><span class=\"line\">2019-06-07 14:26:33.960364+0800 LKTestOC[59510:5385993] A: father load</span><br><span class=\"line\">2019-06-07 14:26:33.960938+0800 LKTestOC[59510:5385993] B: son load</span><br><span class=\"line\">2019-06-07 14:26:33.961009+0800 LKTestOC[59510:5385993] C1: category load</span><br><span class=\"line\">2019-06-07 14:26:33.961078+0800 LKTestOC[59510:5385993] C2: category load</span><br><span class=\"line\">2019-06-07 14:26:34.069072+0800 LKTestOC[59510:5385993] C2: category initialize</span><br><span class=\"line\">结论：initialize方法在消息发送后调用，会覆盖，分类时序最后，且与主类是否import分类无关。</span><br><span class=\"line\"></span><br><span class=\"line\">问题3：</span><br><span class=\"line\">2019-06-07 14:32:15.164806+0800 LKTestOC[60397:5393459] A: father load</span><br><span class=\"line\">2019-06-07 14:32:15.165367+0800 LKTestOC[60397:5393459] B: son load</span><br><span class=\"line\">2019-06-07 14:32:15.165457+0800 LKTestOC[60397:5393459] C1: category load</span><br><span class=\"line\">2019-06-07 14:32:15.165530+0800 LKTestOC[60397:5393459] C2: category load</span><br><span class=\"line\">2019-06-07 14:32:15.269258+0800 LKTestOC[60397:5393459] C2: category initialize</span><br><span class=\"line\">2019-06-07 14:32:15.269361+0800 LKTestOC[60397:5393459] B: son initialize</span><br><span class=\"line\">结论：initialize方法时序 父类-&gt;分类-&gt;子类。</span><br><span class=\"line\"></span><br><span class=\"line\">问题4、5：</span><br><span class=\"line\">2019-06-07 14:33:54.319935+0800 LKTestOC[60679:5396081] A: father load</span><br><span class=\"line\">2019-06-07 14:33:54.320518+0800 LKTestOC[60679:5396081] B: son load</span><br><span class=\"line\">2019-06-07 14:33:54.466408+0800 LKTestOC[60679:5396081] A: father initialize</span><br><span class=\"line\">2019-06-07 14:33:54.466562+0800 LKTestOC[60679:5396081] B: son initialize</span><br><span class=\"line\">结论：子类的initliaze会自动调用父类方法，且每个类初始化时只会调用一次initliaze。</span><br><span class=\"line\"></span><br><span class=\"line\">问题6：</span><br><span class=\"line\">2019-06-07 14:38:39.735874+0800 LKTestOC[61421:5403318] A: father load</span><br><span class=\"line\">2019-06-07 14:38:39.736519+0800 LKTestOC[61421:5403318] B: son load</span><br><span class=\"line\">2019-06-07 14:38:39.921747+0800 LKTestOC[61421:5403318] A: father initialize</span><br><span class=\"line\">2019-06-07 14:38:39.921889+0800 LKTestOC[61421:5403318] A: father initialize</span><br><span class=\"line\">结论：如官方文档所说，子类未实现intialize时父类会调用多次，此处要重点注意，如果想利用initialize做懒加载，需防止调用多次，可利用(self == [ClassName self])做判断。</span><br><span class=\"line\"></span><br><span class=\"line\">问题7：</span><br><span class=\"line\">2019-06-07 14:43:10.949354+0800 LKTestOC[62160:5409931] A: father initialize</span><br><span class=\"line\">2019-06-07 14:43:10.949928+0800 LKTestOC[62160:5409931] B: son initialize</span><br><span class=\"line\">2019-06-07 14:43:11.008578+0800 LKTestOC[62160:5409931] A: father load</span><br><span class=\"line\">2019-06-07 14:43:11.008811+0800 LKTestOC[62160:5409931] B: son load</span><br><span class=\"line\">结论：initialize方法不一定在main()之后，严格遵循发送消息时调用。</span><br><span class=\"line\"></span><br><span class=\"line\">问题8：</span><br><span class=\"line\">2019-06-07 14:44:12.102702+0800 LKTestOC[62327:5411529] B: son initialize</span><br><span class=\"line\">2019-06-07 14:44:12.105044+0800 LKTestOC[62327:5411529] A: father load</span><br><span class=\"line\">2019-06-07 14:44:12.105306+0800 LKTestOC[62327:5411529] B: son load</span><br><span class=\"line\">结论：符合预期。</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Runtime-引用计数和Weak表","date":"2019-06-07T06:52:34.000Z","_content":"retainCount(引用计数)可以说是iOS内存管理的基础，当一个对象的retianCount为0时，没有任何地方引用，该对象的内存就会被释放。iOS进入ARC时代后RD们已经很少看和写`retain release`这些操作引用计数的代码，那么我们进入Runtime看看底层都做了些什么。\n# SideTables\n```\nstatic StripedMap<SideTable>& SideTables() {\n    return *reinterpret_cast<StripedMap<SideTable>*>(SideTableBuf);\n}\n```\n在iOS中StripedMap管理着一个长度64(StripeCount)的数组，其本身是一个`void * -> T`的map，通过`indexForPointer`方法找到对应的数组下标，在hash过程中通过取余StripeCount来防止数组越界。\nStripedMap的作用不仅限于管理SideTable，还可以用来管理spinlock_t(自旋锁)或其他包含着自旋锁的数据结构。\n\n# SideTable\n```\nstruct SideTable {\n    spinlock_t slock;           // 自旋锁，防止多线程访问冲突。\n    RefcountMap refcnts;        // 引用计数Map\n    weak_table_t weak_table;    // 弱引用Map\n\n    SideTable() {\n        memset(&weak_table, 0, sizeof(weak_table));\n    }\n\n    ~SideTable() {\n        _objc_fatal(\"Do not delete SideTable.\");\n    }\n\n    void lock() { slock.lock(); }\n    void unlock() { slock.unlock(); }\n    bool trylock() { return slock.trylock(); }\n\n    // Address-ordered lock discipline for a pair of side tables.\n\n    template<bool HaveOld, bool HaveNew>\n    static void lockTwo(SideTable *lock1, SideTable *lock2);\n    template<bool HaveOld, bool HaveNew>\n    static void unlockTwo(SideTable *lock1, SideTable *lock2);\n};\n```\n\n## spinlock_t\n自旋锁，是为了解决多线程资源互斥利用提出的一种机制。是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。\n优点：不会产生线程状态的切换，线程始终active，处于用户态。相对于其他的锁，会频繁在用户态和内核态之间切换，带来极大的性能损耗。\n\n# RefcountMap\n```\n// RefcountMap disguises its pointers because we \n// don't want the table to act as a root for `leaks`.\ntypedef objc::DenseMap<DisguisedPtr<objc_object>,size_t,true> RefcountMap;\n```\n这里的三个入参`DisguisedPtr<objc_object>,size_t,true`分别表示hash key、value、value==0时是否自动释放hash节点。实际上key就是OC对象，value是引用计数。\n\n# weak_table_t\n```\n/**\n * The global weak references table. Stores object ids as keys,\n * and weak_entry_t structs as their values.\n */\nstruct weak_table_t {\n    weak_entry_t *weak_entries;         // hash数组\n    size_t    num_entries;              // 数组中存放的元素个数\n    uintptr_t mask;                     // 数组长度，防止数组越界\n    uintptr_t max_hash_displacement;    // hash冲突的最大次数\n};\n```\n\n## weak_entry_t\n```\n#define WEAK_INLINE_COUNT 4\nstruct weak_entry_t {\n    DisguisedPtr<objc_object> referent;     // 被弱引用的对象\n    union {\n        // 动态数组\n        struct {\n            weak_referrer_t *referrers;                 // 指向referent内存地址的指针的地址的hash数组\n            uintptr_t        out_of_line : 1;           // 是否使用动态hash数组标记为\n            uintptr_t        num_refs : PTR_MINUS_1;    // 数组中元素个数\n            uintptr_t        mask;                      // 数组长度\n            uintptr_t        max_hash_displacement;     // hash冲突的最大次数\n        };\n        // 定长数组\n        struct {\n            // out_of_line=0 is LSB of one of these (don't care which)\n            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];\n        };\n    };\n};\n```\n注意WEAK_INLINE_COUNT，引用指针数量小于等于WEAK_INLINE_COUNT为定长数组，超过后就始终使用动态数组。\n\n\n","source":"_posts/Runtime-引用计数和Weak表.md","raw":"---\ntitle: Runtime-引用计数和Weak表\ndate: 2019-06-07 14:52:34\ncategories: Runtime\ntags:\n    - 引用计数\n    - Weak表\n---\nretainCount(引用计数)可以说是iOS内存管理的基础，当一个对象的retianCount为0时，没有任何地方引用，该对象的内存就会被释放。iOS进入ARC时代后RD们已经很少看和写`retain release`这些操作引用计数的代码，那么我们进入Runtime看看底层都做了些什么。\n# SideTables\n```\nstatic StripedMap<SideTable>& SideTables() {\n    return *reinterpret_cast<StripedMap<SideTable>*>(SideTableBuf);\n}\n```\n在iOS中StripedMap管理着一个长度64(StripeCount)的数组，其本身是一个`void * -> T`的map，通过`indexForPointer`方法找到对应的数组下标，在hash过程中通过取余StripeCount来防止数组越界。\nStripedMap的作用不仅限于管理SideTable，还可以用来管理spinlock_t(自旋锁)或其他包含着自旋锁的数据结构。\n\n# SideTable\n```\nstruct SideTable {\n    spinlock_t slock;           // 自旋锁，防止多线程访问冲突。\n    RefcountMap refcnts;        // 引用计数Map\n    weak_table_t weak_table;    // 弱引用Map\n\n    SideTable() {\n        memset(&weak_table, 0, sizeof(weak_table));\n    }\n\n    ~SideTable() {\n        _objc_fatal(\"Do not delete SideTable.\");\n    }\n\n    void lock() { slock.lock(); }\n    void unlock() { slock.unlock(); }\n    bool trylock() { return slock.trylock(); }\n\n    // Address-ordered lock discipline for a pair of side tables.\n\n    template<bool HaveOld, bool HaveNew>\n    static void lockTwo(SideTable *lock1, SideTable *lock2);\n    template<bool HaveOld, bool HaveNew>\n    static void unlockTwo(SideTable *lock1, SideTable *lock2);\n};\n```\n\n## spinlock_t\n自旋锁，是为了解决多线程资源互斥利用提出的一种机制。是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。\n优点：不会产生线程状态的切换，线程始终active，处于用户态。相对于其他的锁，会频繁在用户态和内核态之间切换，带来极大的性能损耗。\n\n# RefcountMap\n```\n// RefcountMap disguises its pointers because we \n// don't want the table to act as a root for `leaks`.\ntypedef objc::DenseMap<DisguisedPtr<objc_object>,size_t,true> RefcountMap;\n```\n这里的三个入参`DisguisedPtr<objc_object>,size_t,true`分别表示hash key、value、value==0时是否自动释放hash节点。实际上key就是OC对象，value是引用计数。\n\n# weak_table_t\n```\n/**\n * The global weak references table. Stores object ids as keys,\n * and weak_entry_t structs as their values.\n */\nstruct weak_table_t {\n    weak_entry_t *weak_entries;         // hash数组\n    size_t    num_entries;              // 数组中存放的元素个数\n    uintptr_t mask;                     // 数组长度，防止数组越界\n    uintptr_t max_hash_displacement;    // hash冲突的最大次数\n};\n```\n\n## weak_entry_t\n```\n#define WEAK_INLINE_COUNT 4\nstruct weak_entry_t {\n    DisguisedPtr<objc_object> referent;     // 被弱引用的对象\n    union {\n        // 动态数组\n        struct {\n            weak_referrer_t *referrers;                 // 指向referent内存地址的指针的地址的hash数组\n            uintptr_t        out_of_line : 1;           // 是否使用动态hash数组标记为\n            uintptr_t        num_refs : PTR_MINUS_1;    // 数组中元素个数\n            uintptr_t        mask;                      // 数组长度\n            uintptr_t        max_hash_displacement;     // hash冲突的最大次数\n        };\n        // 定长数组\n        struct {\n            // out_of_line=0 is LSB of one of these (don't care which)\n            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];\n        };\n    };\n};\n```\n注意WEAK_INLINE_COUNT，引用指针数量小于等于WEAK_INLINE_COUNT为定长数组，超过后就始终使用动态数组。\n\n\n","slug":"Runtime-引用计数和Weak表","published":1,"updated":"2019-06-08T07:58:06.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwrfi4x0000crrlw7xbioenp","content":"<p>retainCount(引用计数)可以说是iOS内存管理的基础，当一个对象的retianCount为0时，没有任何地方引用，该对象的内存就会被释放。iOS进入ARC时代后RD们已经很少看和写<code>retain release</code>这些操作引用计数的代码，那么我们进入Runtime看看底层都做了些什么。</p>\n<h1 id=\"SideTables\"><a href=\"#SideTables\" class=\"headerlink\" title=\"SideTables\"></a>SideTables</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class=\"line\">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在iOS中StripedMap管理着一个长度64(StripeCount)的数组，其本身是一个<code>void * -&gt; T</code>的map，通过<code>indexForPointer</code>方法找到对应的数组下标，在hash过程中通过取余StripeCount来防止数组越界。<br>StripedMap的作用不仅限于管理SideTable，还可以用来管理spinlock_t(自旋锁)或其他包含着自旋锁的数据结构。</p>\n<h1 id=\"SideTable\"><a href=\"#SideTable\" class=\"headerlink\" title=\"SideTable\"></a>SideTable</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct SideTable &#123;</span><br><span class=\"line\">    spinlock_t slock;           // 自旋锁，防止多线程访问冲突。</span><br><span class=\"line\">    RefcountMap refcnts;        // 引用计数Map</span><br><span class=\"line\">    weak_table_t weak_table;    // 弱引用Map</span><br><span class=\"line\"></span><br><span class=\"line\">    SideTable() &#123;</span><br><span class=\"line\">        memset(&amp;weak_table, 0, sizeof(weak_table));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~SideTable() &#123;</span><br><span class=\"line\">        _objc_fatal(&quot;Do not delete SideTable.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void lock() &#123; slock.lock(); &#125;</span><br><span class=\"line\">    void unlock() &#123; slock.unlock(); &#125;</span><br><span class=\"line\">    bool trylock() &#123; return slock.trylock(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Address-ordered lock discipline for a pair of side tables.</span><br><span class=\"line\"></span><br><span class=\"line\">    template&lt;bool HaveOld, bool HaveNew&gt;</span><br><span class=\"line\">    static void lockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class=\"line\">    template&lt;bool HaveOld, bool HaveNew&gt;</span><br><span class=\"line\">    static void unlockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"spinlock-t\"><a href=\"#spinlock-t\" class=\"headerlink\" title=\"spinlock_t\"></a>spinlock_t</h2><p>自旋锁，是为了解决多线程资源互斥利用提出的一种机制。是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<br>优点：不会产生线程状态的切换，线程始终active，处于用户态。相对于其他的锁，会频繁在用户态和内核态之间切换，带来极大的性能损耗。</p>\n<h1 id=\"RefcountMap\"><a href=\"#RefcountMap\" class=\"headerlink\" title=\"RefcountMap\"></a>RefcountMap</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RefcountMap disguises its pointers because we </span><br><span class=\"line\">// don&apos;t want the table to act as a root for `leaks`.</span><br><span class=\"line\">typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap;</span><br></pre></td></tr></table></figure>\n<p>这里的三个入参<code>DisguisedPtr&lt;objc_object&gt;,size_t,true</code>分别表示hash key、value、value==0时是否自动释放hash节点。实际上key就是OC对象，value是引用计数。</p>\n<h1 id=\"weak-table-t\"><a href=\"#weak-table-t\" class=\"headerlink\" title=\"weak_table_t\"></a>weak_table_t</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * The global weak references table. Stores object ids as keys,</span><br><span class=\"line\"> * and weak_entry_t structs as their values.</span><br><span class=\"line\"> */</span><br><span class=\"line\">struct weak_table_t &#123;</span><br><span class=\"line\">    weak_entry_t *weak_entries;         // hash数组</span><br><span class=\"line\">    size_t    num_entries;              // 数组中存放的元素个数</span><br><span class=\"line\">    uintptr_t mask;                     // 数组长度，防止数组越界</span><br><span class=\"line\">    uintptr_t max_hash_displacement;    // hash冲突的最大次数</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"weak-entry-t\"><a href=\"#weak-entry-t\" class=\"headerlink\" title=\"weak_entry_t\"></a>weak_entry_t</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define WEAK_INLINE_COUNT 4</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    DisguisedPtr&lt;objc_object&gt; referent;     // 被弱引用的对象</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        // 动态数组</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            weak_referrer_t *referrers;                 // 指向referent内存地址的指针的地址的hash数组</span><br><span class=\"line\">            uintptr_t        out_of_line : 1;           // 是否使用动态hash数组标记为</span><br><span class=\"line\">            uintptr_t        num_refs : PTR_MINUS_1;    // 数组中元素个数</span><br><span class=\"line\">            uintptr_t        mask;                      // 数组长度</span><br><span class=\"line\">            uintptr_t        max_hash_displacement;     // hash冲突的最大次数</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        // 定长数组</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            // out_of_line=0 is LSB of one of these (don&apos;t care which)</span><br><span class=\"line\">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意WEAK_INLINE_COUNT，引用指针数量小于等于WEAK_INLINE_COUNT为定长数组，超过后就始终使用动态数组。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>retainCount(引用计数)可以说是iOS内存管理的基础，当一个对象的retianCount为0时，没有任何地方引用，该对象的内存就会被释放。iOS进入ARC时代后RD们已经很少看和写<code>retain release</code>这些操作引用计数的代码，那么我们进入Runtime看看底层都做了些什么。</p>\n<h1 id=\"SideTables\"><a href=\"#SideTables\" class=\"headerlink\" title=\"SideTables\"></a>SideTables</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class=\"line\">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在iOS中StripedMap管理着一个长度64(StripeCount)的数组，其本身是一个<code>void * -&gt; T</code>的map，通过<code>indexForPointer</code>方法找到对应的数组下标，在hash过程中通过取余StripeCount来防止数组越界。<br>StripedMap的作用不仅限于管理SideTable，还可以用来管理spinlock_t(自旋锁)或其他包含着自旋锁的数据结构。</p>\n<h1 id=\"SideTable\"><a href=\"#SideTable\" class=\"headerlink\" title=\"SideTable\"></a>SideTable</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct SideTable &#123;</span><br><span class=\"line\">    spinlock_t slock;           // 自旋锁，防止多线程访问冲突。</span><br><span class=\"line\">    RefcountMap refcnts;        // 引用计数Map</span><br><span class=\"line\">    weak_table_t weak_table;    // 弱引用Map</span><br><span class=\"line\"></span><br><span class=\"line\">    SideTable() &#123;</span><br><span class=\"line\">        memset(&amp;weak_table, 0, sizeof(weak_table));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~SideTable() &#123;</span><br><span class=\"line\">        _objc_fatal(&quot;Do not delete SideTable.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void lock() &#123; slock.lock(); &#125;</span><br><span class=\"line\">    void unlock() &#123; slock.unlock(); &#125;</span><br><span class=\"line\">    bool trylock() &#123; return slock.trylock(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Address-ordered lock discipline for a pair of side tables.</span><br><span class=\"line\"></span><br><span class=\"line\">    template&lt;bool HaveOld, bool HaveNew&gt;</span><br><span class=\"line\">    static void lockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class=\"line\">    template&lt;bool HaveOld, bool HaveNew&gt;</span><br><span class=\"line\">    static void unlockTwo(SideTable *lock1, SideTable *lock2);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"spinlock-t\"><a href=\"#spinlock-t\" class=\"headerlink\" title=\"spinlock_t\"></a>spinlock_t</h2><p>自旋锁，是为了解决多线程资源互斥利用提出的一种机制。是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。<br>优点：不会产生线程状态的切换，线程始终active，处于用户态。相对于其他的锁，会频繁在用户态和内核态之间切换，带来极大的性能损耗。</p>\n<h1 id=\"RefcountMap\"><a href=\"#RefcountMap\" class=\"headerlink\" title=\"RefcountMap\"></a>RefcountMap</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// RefcountMap disguises its pointers because we </span><br><span class=\"line\">// don&apos;t want the table to act as a root for `leaks`.</span><br><span class=\"line\">typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap;</span><br></pre></td></tr></table></figure>\n<p>这里的三个入参<code>DisguisedPtr&lt;objc_object&gt;,size_t,true</code>分别表示hash key、value、value==0时是否自动释放hash节点。实际上key就是OC对象，value是引用计数。</p>\n<h1 id=\"weak-table-t\"><a href=\"#weak-table-t\" class=\"headerlink\" title=\"weak_table_t\"></a>weak_table_t</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * The global weak references table. Stores object ids as keys,</span><br><span class=\"line\"> * and weak_entry_t structs as their values.</span><br><span class=\"line\"> */</span><br><span class=\"line\">struct weak_table_t &#123;</span><br><span class=\"line\">    weak_entry_t *weak_entries;         // hash数组</span><br><span class=\"line\">    size_t    num_entries;              // 数组中存放的元素个数</span><br><span class=\"line\">    uintptr_t mask;                     // 数组长度，防止数组越界</span><br><span class=\"line\">    uintptr_t max_hash_displacement;    // hash冲突的最大次数</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"weak-entry-t\"><a href=\"#weak-entry-t\" class=\"headerlink\" title=\"weak_entry_t\"></a>weak_entry_t</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define WEAK_INLINE_COUNT 4</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    DisguisedPtr&lt;objc_object&gt; referent;     // 被弱引用的对象</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        // 动态数组</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            weak_referrer_t *referrers;                 // 指向referent内存地址的指针的地址的hash数组</span><br><span class=\"line\">            uintptr_t        out_of_line : 1;           // 是否使用动态hash数组标记为</span><br><span class=\"line\">            uintptr_t        num_refs : PTR_MINUS_1;    // 数组中元素个数</span><br><span class=\"line\">            uintptr_t        mask;                      // 数组长度</span><br><span class=\"line\">            uintptr_t        max_hash_displacement;     // hash冲突的最大次数</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        // 定长数组</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            // out_of_line=0 is LSB of one of these (don&apos;t care which)</span><br><span class=\"line\">            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意WEAK_INLINE_COUNT，引用指针数量小于等于WEAK_INLINE_COUNT为定长数组，超过后就始终使用动态数组。</p>\n"},{"title":"笔记-UISwitch在iOS 10中的BUG","date":"2016-09-29T05:31:22.000Z","_content":"\n# UISwitch\nUISwitch是UIControl的子类，定义如下：\n```\n#import <Foundation/Foundation.h>\n#import <CoreGraphics/CoreGraphics.h>\n#import <UIKit/UIControl.h>\n#import <UIKit/UIKitDefines.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\nNS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl <NSCoding>\n\n@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;\n@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);\n@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n\n@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n\n@property(nonatomic,getter=isOn) BOOL on;\n\n- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;      // This class enforces a size appropriate for the control, and so the frame size is ignored.\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;\n\n- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action\n\n@end\n\nNS_ASSUME_NONNULL_END\n```\n\n方法定义中有一个`- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action`，如注释所说不发送action。\n\n# iOS 9下表现\n接下来在iOS 9中进行验证：\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@property (nonatomic, strong) UISwitch *lkSwitch;\n@property (nonatomic, strong) UISwitch *lkSwitch1;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)];\n    [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:_lkSwitch];\n    \n    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)];\n    [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside];\n    button.backgroundColor = [UIColor redColor];\n    [self.view addSubview:button];\n    \n    _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)];\n    [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:_lkSwitch1];\n    \n    UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)];\n    [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside];\n    button1.backgroundColor = [UIColor redColor];\n    [self.view addSubview:button1];\n}\n\n- (void)onSwitch:(UISwitch *)sender {\n    [sender setOn:!sender.isOn];\n}\n\n- (void)onButton:(UIButton *)sender {\n    [_lkSwitch setOn:!_lkSwitch.isOn];\n}\n\n- (void)onSwitch1:(UISwitch *)sender {\n    [sender setOn:!sender.isOn animated:YES];\n}\n\n- (void)onButton1:(UIButton *)sender {\n    [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];\n}\n\n@end\n```\n验证结果：无论是`setOn`方法还是`setOn:_animated:_`方法，都不会触发`onSwitch`。\n\n# iOS 10下表现\n然而，在iOS 10中，测试结果显示，在`onSwitch`方法中调用`setOn`或`setOn:_animated:_`，均会再次触发`onSwitch`。\n\n# 结论\n也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为`UIControlEventValueChanged`，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考...）。\n\n# 解决方案\n在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。\n\n曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写`setOn`和`setOn:_animated:_`方法，但是这样带来的风险是，dispatch queue以后的语句会先于`setOn`执行，若此时获取`isOn`，将无法得到预期的结果。\n\n因此最终决定在业务逻辑层局部进行修改。","source":"_posts/UISwitch在iOS 10中的BUG.md","raw":"---\ntitle: 笔记-UISwitch在iOS 10中的BUG\ndate: 2016-09-29 13:31:22\ncategories: 笔记\ntags: \n    - iOS 10\n    - BUG\n---\n\n# UISwitch\nUISwitch是UIControl的子类，定义如下：\n```\n#import <Foundation/Foundation.h>\n#import <CoreGraphics/CoreGraphics.h>\n#import <UIKit/UIControl.h>\n#import <UIKit/UIKitDefines.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\nNS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl <NSCoding>\n\n@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;\n@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);\n@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n\n@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n\n@property(nonatomic,getter=isOn) BOOL on;\n\n- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;      // This class enforces a size appropriate for the control, and so the frame size is ignored.\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;\n\n- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action\n\n@end\n\nNS_ASSUME_NONNULL_END\n```\n\n方法定义中有一个`- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action`，如注释所说不发送action。\n\n# iOS 9下表现\n接下来在iOS 9中进行验证：\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@property (nonatomic, strong) UISwitch *lkSwitch;\n@property (nonatomic, strong) UISwitch *lkSwitch1;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)];\n    [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:_lkSwitch];\n    \n    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)];\n    [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside];\n    button.backgroundColor = [UIColor redColor];\n    [self.view addSubview:button];\n    \n    _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)];\n    [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:_lkSwitch1];\n    \n    UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)];\n    [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside];\n    button1.backgroundColor = [UIColor redColor];\n    [self.view addSubview:button1];\n}\n\n- (void)onSwitch:(UISwitch *)sender {\n    [sender setOn:!sender.isOn];\n}\n\n- (void)onButton:(UIButton *)sender {\n    [_lkSwitch setOn:!_lkSwitch.isOn];\n}\n\n- (void)onSwitch1:(UISwitch *)sender {\n    [sender setOn:!sender.isOn animated:YES];\n}\n\n- (void)onButton1:(UIButton *)sender {\n    [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];\n}\n\n@end\n```\n验证结果：无论是`setOn`方法还是`setOn:_animated:_`方法，都不会触发`onSwitch`。\n\n# iOS 10下表现\n然而，在iOS 10中，测试结果显示，在`onSwitch`方法中调用`setOn`或`setOn:_animated:_`，均会再次触发`onSwitch`。\n\n# 结论\n也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为`UIControlEventValueChanged`，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考...）。\n\n# 解决方案\n在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。\n\n曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写`setOn`和`setOn:_animated:_`方法，但是这样带来的风险是，dispatch queue以后的语句会先于`setOn`执行，若此时获取`isOn`，将无法得到预期的结果。\n\n因此最终决定在业务逻辑层局部进行修改。","slug":"UISwitch在iOS 10中的BUG","published":1,"updated":"2019-06-12T05:46:18.088Z","_id":"cjwrfi4x1000grrlwudl95bby","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"UISwitch\"><a href=\"#UISwitch\" class=\"headerlink\" title=\"UISwitch\"></a>UISwitch</h1><p>UISwitch是UIControl的子类，定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;CoreGraphics/CoreGraphics.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIControl.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NS_ASSUME_NONNULL_BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl &lt;NSCoding&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\">@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);</span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nonatomic,getter=isOn) BOOL on;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;      // This class enforces a size appropriate for the control, and so the frame size is ignored.</span><br><span class=\"line\">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></p>\n<p>方法定义中有一个<code>- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action</code>，如注释所说不发送action。</p>\n<h1 id=\"iOS-9下表现\"><a href=\"#iOS-9下表现\" class=\"headerlink\" title=\"iOS 9下表现\"></a>iOS 9下表现</h1><p>接下来在iOS 9中进行验证：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) UISwitch *lkSwitch;</span><br><span class=\"line\">@property (nonatomic, strong) UISwitch *lkSwitch1;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)];</span><br><span class=\"line\">    [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged];</span><br><span class=\"line\">    [self.view addSubview:_lkSwitch];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)];</span><br><span class=\"line\">    [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    button.backgroundColor = [UIColor redColor];</span><br><span class=\"line\">    [self.view addSubview:button];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)];</span><br><span class=\"line\">    [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged];</span><br><span class=\"line\">    [self.view addSubview:_lkSwitch1];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)];</span><br><span class=\"line\">    [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    button1.backgroundColor = [UIColor redColor];</span><br><span class=\"line\">    [self.view addSubview:button1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onSwitch:(UISwitch *)sender &#123;</span><br><span class=\"line\">    [sender setOn:!sender.isOn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onButton:(UIButton *)sender &#123;</span><br><span class=\"line\">    [_lkSwitch setOn:!_lkSwitch.isOn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onSwitch1:(UISwitch *)sender &#123;</span><br><span class=\"line\">    [sender setOn:!sender.isOn animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onButton1:(UIButton *)sender &#123;</span><br><span class=\"line\">    [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>验证结果：无论是<code>setOn</code>方法还是<code>setOn:_animated:_</code>方法，都不会触发<code>onSwitch</code>。</p>\n<h1 id=\"iOS-10下表现\"><a href=\"#iOS-10下表现\" class=\"headerlink\" title=\"iOS 10下表现\"></a>iOS 10下表现</h1><p>然而，在iOS 10中，测试结果显示，在<code>onSwitch</code>方法中调用<code>setOn</code>或<code>setOn:_animated:_</code>，均会再次触发<code>onSwitch</code>。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为<code>UIControlEventValueChanged</code>，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考…）。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。</p>\n<p>曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写<code>setOn</code>和<code>setOn:_animated:_</code>方法，但是这样带来的风险是，dispatch queue以后的语句会先于<code>setOn</code>执行，若此时获取<code>isOn</code>，将无法得到预期的结果。</p>\n<p>因此最终决定在业务逻辑层局部进行修改。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UISwitch\"><a href=\"#UISwitch\" class=\"headerlink\" title=\"UISwitch\"></a>UISwitch</h1><p>UISwitch是UIControl的子类，定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;CoreGraphics/CoreGraphics.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIControl.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NS_ASSUME_NONNULL_BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl &lt;NSCoding&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\">@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);</span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nonatomic,getter=isOn) BOOL on;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;      // This class enforces a size appropriate for the control, and so the frame size is ignored.</span><br><span class=\"line\">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></p>\n<p>方法定义中有一个<code>- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action</code>，如注释所说不发送action。</p>\n<h1 id=\"iOS-9下表现\"><a href=\"#iOS-9下表现\" class=\"headerlink\" title=\"iOS 9下表现\"></a>iOS 9下表现</h1><p>接下来在iOS 9中进行验证：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) UISwitch *lkSwitch;</span><br><span class=\"line\">@property (nonatomic, strong) UISwitch *lkSwitch1;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)];</span><br><span class=\"line\">    [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged];</span><br><span class=\"line\">    [self.view addSubview:_lkSwitch];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)];</span><br><span class=\"line\">    [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    button.backgroundColor = [UIColor redColor];</span><br><span class=\"line\">    [self.view addSubview:button];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)];</span><br><span class=\"line\">    [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged];</span><br><span class=\"line\">    [self.view addSubview:_lkSwitch1];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)];</span><br><span class=\"line\">    [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    button1.backgroundColor = [UIColor redColor];</span><br><span class=\"line\">    [self.view addSubview:button1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onSwitch:(UISwitch *)sender &#123;</span><br><span class=\"line\">    [sender setOn:!sender.isOn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onButton:(UIButton *)sender &#123;</span><br><span class=\"line\">    [_lkSwitch setOn:!_lkSwitch.isOn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onSwitch1:(UISwitch *)sender &#123;</span><br><span class=\"line\">    [sender setOn:!sender.isOn animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onButton1:(UIButton *)sender &#123;</span><br><span class=\"line\">    [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>验证结果：无论是<code>setOn</code>方法还是<code>setOn:_animated:_</code>方法，都不会触发<code>onSwitch</code>。</p>\n<h1 id=\"iOS-10下表现\"><a href=\"#iOS-10下表现\" class=\"headerlink\" title=\"iOS 10下表现\"></a>iOS 10下表现</h1><p>然而，在iOS 10中，测试结果显示，在<code>onSwitch</code>方法中调用<code>setOn</code>或<code>setOn:_animated:_</code>，均会再次触发<code>onSwitch</code>。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为<code>UIControlEventValueChanged</code>，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考…）。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。</p>\n<p>曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写<code>setOn</code>和<code>setOn:_animated:_</code>方法，但是这样带来的风险是，dispatch queue以后的语句会先于<code>setOn</code>执行，若此时获取<code>isOn</code>，将无法得到预期的结果。</p>\n<p>因此最终决定在业务逻辑层局部进行修改。</p>\n"},{"title":"Flutter-踩坑记录","date":"2019-04-10T06:59:08.000Z","_content":"\n# Flutter 踩坑记录\n\n## 问题索引\n\n[TabBar及PageView状态保存](#q001)\n[ScrollView滚动进度保存](#q002)\n[ListView下拉刷新后数据已返回，UI未更新](#q003)\n[中文汉字变形](#q004)\n[热重载hot reload未生效](#q005)\n[转场动画在list内黑屏不生效](#q006)\n[Android plugin内不能使用AAR包](#q007)\n[Android plugin内AAR包内的so库加载不出来](#q008)\n[Json注解制动生成的解析文件解析数据失败](#q009)\n[加载更多后头像加载慢或不加载](#q010)\n[dio安卓上网络请求失败](#q011)\n[NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效](#q012)\n[枚举值需要取index，否则打印类名](#q013)\n[flutter动画不执行](#q014)\n[在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失](#q015)\n[dispose后不允许setState](#q016)\n[滑动冲突](#q017)\n[Row中的Text控件出现overflow警告](#q018)\n[webview无法连接网络](#q019)\n\n## q001\n\n**TabBar及PageView状态保存**\n\n*Flutter 1.2.1 statble*\n\n子页面离开屏幕时，state会被销毁引发的bug\nhttps://juejin.im/post/5b73c3b3f265da27d701473a\n\n## q002\n\n**ScrollView滚动进度保存**\n\n*Flutter 1.2.1 statble*\n\n进入其他页面返回后保存scrollView的offset\nhttps://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages\n\n## q003\n\n**ListView下拉刷新后数据已返回，UI未更新**\n\n*Flutter 1.2.1 statble*\n\nListView需要有Key，否则被复用引发的UI不立即更新bug\nhttps://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert\n\n## q004\n\n**中文汉字变形**\n\n*Flutter 1.2.1 statble*\n\n该问题发生在MaterialApp中，多数情况与fontfamily有关。\nhttps://github.com/flutter/flutter/issues/22966\nhttps://github.com/flutter/flutter/issues/26752\nhttps://github.com/flutter/flutter/issues/25726\n\n## q005\n\n**热重载hot reload未生效**\n\n*Flutter 1.2.1 statble*\n\n目前已知几种情况下，hot reload无法生效\n\n- 需要build_runner做代码生成部分的代码\n- 使用了新添加的资源\n\n发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。\n\n## q006\n**转场动画在list内黑屏不生效**\nHero转场动画在list内黑屏不生效\n原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素\n解决方案：tag随机生成，并通过参数传入下个页面\n\n## q007\n**Android plugin内不能使用AAR包**\nAndroid插件开发中，AAR包引用不到\n原因：flutter暂不支持AAR的引用，仅支持gradle方式引用\n解决方案：\n1. 放弃插件方案，直接在application工程下开发flutter与native的交互方案\n2. 百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。\nWIKI：http://wiki.baidu.com/pages/viewpage.action?pageId=465488650\nmaven库地址：http://maven.baidu-int.com/nexus/content/groups/public\n链接：http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/\n使用方法：compile 'com.baidu.bdpass:HWOpenSDK:3.3.3@aar'\n接口人：zhanghuaming@baidu.com\n\n## q008\n**Android plugin内AAR包内的so库加载不出来**\nAndroid 插件通过gradle方式引用AAR包，但是其中的so库load不出来\n原因：flutter对AAR包的引用支持不好\n解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代\n\n## q009\n**Json注解制动生成的解析文件解析数据失败**\n原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串\n解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null\n\n## q010\n**Json注解制动生成的解析文件解析数据失败**\n原因：View复用导致没有刷新\n解决方案：需要给头像控件增加一个单独的Key\n\n##q011\n原因：没有网络请求的权限\n解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限\n\n##q012\n原因：未知\n解决方案：改用NotificationListener\n\n## q014\n**flutter动画不执行**\n原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾\n方案：动画controller写成全局变量，执行动画前先调reset方法。\n\n## q015\n**在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失**\n原因不明。\n\n``` dart\nSliverAppBar(\n  flexibleSpace: FlexibleSpaceBar(\n    background: PageView.builder(\n      ... ...\n    )\n  )\n)\n\n```\n\nPageView若更换成其他非滑动型控件，则无此问题。\n\n## q016\n原因：内存泄漏\n方案：dispose时将callBack等异步操作取消或置null\n\n## q017\n**滑动冲突**\n原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件\n解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如\n```\nTabBarView(\n   children: children,\n   physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),\n),\n```\n\n## q018\n方案：将Text嵌套在Expanded中\n\n## q019\nInfo.plist中加入\n```\n<key>io.flutter.embedded_views_preview</key>\n<true/>\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n","source":"_posts/Flutter-踩坑记录.md","raw":"---\ntitle: Flutter-踩坑记录\ndate: 2019-04-10 14:59:08\ncategories: Flutter\ntags:\n    - Flutter\n    - 笔记\n    - 踩坑记录\n---\n\n# Flutter 踩坑记录\n\n## 问题索引\n\n[TabBar及PageView状态保存](#q001)\n[ScrollView滚动进度保存](#q002)\n[ListView下拉刷新后数据已返回，UI未更新](#q003)\n[中文汉字变形](#q004)\n[热重载hot reload未生效](#q005)\n[转场动画在list内黑屏不生效](#q006)\n[Android plugin内不能使用AAR包](#q007)\n[Android plugin内AAR包内的so库加载不出来](#q008)\n[Json注解制动生成的解析文件解析数据失败](#q009)\n[加载更多后头像加载慢或不加载](#q010)\n[dio安卓上网络请求失败](#q011)\n[NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效](#q012)\n[枚举值需要取index，否则打印类名](#q013)\n[flutter动画不执行](#q014)\n[在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失](#q015)\n[dispose后不允许setState](#q016)\n[滑动冲突](#q017)\n[Row中的Text控件出现overflow警告](#q018)\n[webview无法连接网络](#q019)\n\n## q001\n\n**TabBar及PageView状态保存**\n\n*Flutter 1.2.1 statble*\n\n子页面离开屏幕时，state会被销毁引发的bug\nhttps://juejin.im/post/5b73c3b3f265da27d701473a\n\n## q002\n\n**ScrollView滚动进度保存**\n\n*Flutter 1.2.1 statble*\n\n进入其他页面返回后保存scrollView的offset\nhttps://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages\n\n## q003\n\n**ListView下拉刷新后数据已返回，UI未更新**\n\n*Flutter 1.2.1 statble*\n\nListView需要有Key，否则被复用引发的UI不立即更新bug\nhttps://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert\n\n## q004\n\n**中文汉字变形**\n\n*Flutter 1.2.1 statble*\n\n该问题发生在MaterialApp中，多数情况与fontfamily有关。\nhttps://github.com/flutter/flutter/issues/22966\nhttps://github.com/flutter/flutter/issues/26752\nhttps://github.com/flutter/flutter/issues/25726\n\n## q005\n\n**热重载hot reload未生效**\n\n*Flutter 1.2.1 statble*\n\n目前已知几种情况下，hot reload无法生效\n\n- 需要build_runner做代码生成部分的代码\n- 使用了新添加的资源\n\n发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。\n\n## q006\n**转场动画在list内黑屏不生效**\nHero转场动画在list内黑屏不生效\n原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素\n解决方案：tag随机生成，并通过参数传入下个页面\n\n## q007\n**Android plugin内不能使用AAR包**\nAndroid插件开发中，AAR包引用不到\n原因：flutter暂不支持AAR的引用，仅支持gradle方式引用\n解决方案：\n1. 放弃插件方案，直接在application工程下开发flutter与native的交互方案\n2. 百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。\nWIKI：http://wiki.baidu.com/pages/viewpage.action?pageId=465488650\nmaven库地址：http://maven.baidu-int.com/nexus/content/groups/public\n链接：http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/\n使用方法：compile 'com.baidu.bdpass:HWOpenSDK:3.3.3@aar'\n接口人：zhanghuaming@baidu.com\n\n## q008\n**Android plugin内AAR包内的so库加载不出来**\nAndroid 插件通过gradle方式引用AAR包，但是其中的so库load不出来\n原因：flutter对AAR包的引用支持不好\n解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代\n\n## q009\n**Json注解制动生成的解析文件解析数据失败**\n原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串\n解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null\n\n## q010\n**Json注解制动生成的解析文件解析数据失败**\n原因：View复用导致没有刷新\n解决方案：需要给头像控件增加一个单独的Key\n\n##q011\n原因：没有网络请求的权限\n解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限\n\n##q012\n原因：未知\n解决方案：改用NotificationListener\n\n## q014\n**flutter动画不执行**\n原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾\n方案：动画controller写成全局变量，执行动画前先调reset方法。\n\n## q015\n**在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失**\n原因不明。\n\n``` dart\nSliverAppBar(\n  flexibleSpace: FlexibleSpaceBar(\n    background: PageView.builder(\n      ... ...\n    )\n  )\n)\n\n```\n\nPageView若更换成其他非滑动型控件，则无此问题。\n\n## q016\n原因：内存泄漏\n方案：dispose时将callBack等异步操作取消或置null\n\n## q017\n**滑动冲突**\n原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件\n解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如\n```\nTabBarView(\n   children: children,\n   physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),\n),\n```\n\n## q018\n方案：将Text嵌套在Expanded中\n\n## q019\nInfo.plist中加入\n```\n<key>io.flutter.embedded_views_preview</key>\n<true/>\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n","slug":"Flutter-踩坑记录","published":1,"updated":"2019-06-12T05:09:46.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwss6z5300005mlwh6hs4poc","content":"<h1 id=\"Flutter-踩坑记录\"><a href=\"#Flutter-踩坑记录\" class=\"headerlink\" title=\"Flutter 踩坑记录\"></a>Flutter 踩坑记录</h1><h2 id=\"问题索引\"><a href=\"#问题索引\" class=\"headerlink\" title=\"问题索引\"></a>问题索引</h2><p><a href=\"#q001\">TabBar及PageView状态保存</a><br><a href=\"#q002\">ScrollView滚动进度保存</a><br><a href=\"#q003\">ListView下拉刷新后数据已返回，UI未更新</a><br><a href=\"#q004\">中文汉字变形</a><br><a href=\"#q005\">热重载hot reload未生效</a><br><a href=\"#q006\">转场动画在list内黑屏不生效</a><br><a href=\"#q007\">Android plugin内不能使用AAR包</a><br><a href=\"#q008\">Android plugin内AAR包内的so库加载不出来</a><br><a href=\"#q009\">Json注解制动生成的解析文件解析数据失败</a><br><a href=\"#q010\">加载更多后头像加载慢或不加载</a><br><a href=\"#q011\">dio安卓上网络请求失败</a><br><a href=\"#q012\">NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效</a><br><a href=\"#q013\">枚举值需要取index，否则打印类名</a><br><a href=\"#q014\">flutter动画不执行</a><br><a href=\"#q015\">在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失</a><br><a href=\"#q016\">dispose后不允许setState</a><br><a href=\"#q017\">滑动冲突</a><br><a href=\"#q018\">Row中的Text控件出现overflow警告</a><br><a href=\"#q019\">webview无法连接网络</a></p>\n<h2 id=\"q001\"><a href=\"#q001\" class=\"headerlink\" title=\"q001\"></a>q001</h2><p><strong>TabBar及PageView状态保存</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>子页面离开屏幕时，state会被销毁引发的bug<br><a href=\"https://juejin.im/post/5b73c3b3f265da27d701473a\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5b73c3b3f265da27d701473a</a></p>\n<h2 id=\"q002\"><a href=\"#q002\" class=\"headerlink\" title=\"q002\"></a>q002</h2><p><strong>ScrollView滚动进度保存</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>进入其他页面返回后保存scrollView的offset<br><a href=\"https://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages</a></p>\n<h2 id=\"q003\"><a href=\"#q003\" class=\"headerlink\" title=\"q003\"></a>q003</h2><p><strong>ListView下拉刷新后数据已返回，UI未更新</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>ListView需要有Key，否则被复用引发的UI不立即更新bug<br><a href=\"https://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert</a></p>\n<h2 id=\"q004\"><a href=\"#q004\" class=\"headerlink\" title=\"q004\"></a>q004</h2><p><strong>中文汉字变形</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>该问题发生在MaterialApp中，多数情况与fontfamily有关。<br><a href=\"https://github.com/flutter/flutter/issues/22966\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/22966</a><br><a href=\"https://github.com/flutter/flutter/issues/26752\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/26752</a><br><a href=\"https://github.com/flutter/flutter/issues/25726\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/25726</a></p>\n<h2 id=\"q005\"><a href=\"#q005\" class=\"headerlink\" title=\"q005\"></a>q005</h2><p><strong>热重载hot reload未生效</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>目前已知几种情况下，hot reload无法生效</p>\n<ul>\n<li>需要build_runner做代码生成部分的代码</li>\n<li>使用了新添加的资源</li>\n</ul>\n<p>发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。</p>\n<h2 id=\"q006\"><a href=\"#q006\" class=\"headerlink\" title=\"q006\"></a>q006</h2><p><strong>转场动画在list内黑屏不生效</strong><br>Hero转场动画在list内黑屏不生效<br>原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素<br>解决方案：tag随机生成，并通过参数传入下个页面</p>\n<h2 id=\"q007\"><a href=\"#q007\" class=\"headerlink\" title=\"q007\"></a>q007</h2><p><strong>Android plugin内不能使用AAR包</strong><br>Android插件开发中，AAR包引用不到<br>原因：flutter暂不支持AAR的引用，仅支持gradle方式引用<br>解决方案：</p>\n<ol>\n<li>放弃插件方案，直接在application工程下开发flutter与native的交互方案</li>\n<li>百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。<br>WIKI：<a href=\"http://wiki.baidu.com/pages/viewpage.action?pageId=465488650\" target=\"_blank\" rel=\"noopener\">http://wiki.baidu.com/pages/viewpage.action?pageId=465488650</a><br>maven库地址：<a href=\"http://maven.baidu-int.com/nexus/content/groups/public\" target=\"_blank\" rel=\"noopener\">http://maven.baidu-int.com/nexus/content/groups/public</a><br>链接：<a href=\"http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/\" target=\"_blank\" rel=\"noopener\">http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/</a><br>使用方法：compile ‘com.baidu.bdpass:HWOpenSDK:3.3.3@aar’<br>接口人：<a href=\"mailto:zhanghuaming@baidu.com\" target=\"_blank\" rel=\"noopener\">zhanghuaming@baidu.com</a></li>\n</ol>\n<h2 id=\"q008\"><a href=\"#q008\" class=\"headerlink\" title=\"q008\"></a>q008</h2><p><strong>Android plugin内AAR包内的so库加载不出来</strong><br>Android 插件通过gradle方式引用AAR包，但是其中的so库load不出来<br>原因：flutter对AAR包的引用支持不好<br>解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代</p>\n<h2 id=\"q009\"><a href=\"#q009\" class=\"headerlink\" title=\"q009\"></a>q009</h2><p><strong>Json注解制动生成的解析文件解析数据失败</strong><br>原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串<br>解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null</p>\n<h2 id=\"q010\"><a href=\"#q010\" class=\"headerlink\" title=\"q010\"></a>q010</h2><p><strong>Json注解制动生成的解析文件解析数据失败</strong><br>原因：View复用导致没有刷新<br>解决方案：需要给头像控件增加一个单独的Key</p>\n<p>##q011<br>原因：没有网络请求的权限<br>解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限</p>\n<p>##q012<br>原因：未知<br>解决方案：改用NotificationListener</p>\n<h2 id=\"q014\"><a href=\"#q014\" class=\"headerlink\" title=\"q014\"></a>q014</h2><p><strong>flutter动画不执行</strong><br>原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾<br>方案：动画controller写成全局变量，执行动画前先调reset方法。</p>\n<h2 id=\"q015\"><a href=\"#q015\" class=\"headerlink\" title=\"q015\"></a>q015</h2><p><strong>在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失</strong><br>原因不明。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SliverAppBar(</span><br><span class=\"line\">  flexibleSpace: FlexibleSpaceBar(</span><br><span class=\"line\">    background: PageView.builder(</span><br><span class=\"line\">      ... ...</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>PageView若更换成其他非滑动型控件，则无此问题。</p>\n<h2 id=\"q016\"><a href=\"#q016\" class=\"headerlink\" title=\"q016\"></a>q016</h2><p>原因：内存泄漏<br>方案：dispose时将callBack等异步操作取消或置null</p>\n<h2 id=\"q017\"><a href=\"#q017\" class=\"headerlink\" title=\"q017\"></a>q017</h2><p><strong>滑动冲突</strong><br>原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件<br>解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TabBarView(</span><br><span class=\"line\">   children: children,</span><br><span class=\"line\">   physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),</span><br><span class=\"line\">),</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"q018\"><a href=\"#q018\" class=\"headerlink\" title=\"q018\"></a>q018</h2><p>方案：将Text嵌套在Expanded中</p>\n<h2 id=\"q019\"><a href=\"#q019\" class=\"headerlink\" title=\"q019\"></a>q019</h2><p>Info.plist中加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt;</span><br><span class=\"line\">&lt;true/&gt;</span><br><span class=\"line\">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flutter-踩坑记录\"><a href=\"#Flutter-踩坑记录\" class=\"headerlink\" title=\"Flutter 踩坑记录\"></a>Flutter 踩坑记录</h1><h2 id=\"问题索引\"><a href=\"#问题索引\" class=\"headerlink\" title=\"问题索引\"></a>问题索引</h2><p><a href=\"#q001\">TabBar及PageView状态保存</a><br><a href=\"#q002\">ScrollView滚动进度保存</a><br><a href=\"#q003\">ListView下拉刷新后数据已返回，UI未更新</a><br><a href=\"#q004\">中文汉字变形</a><br><a href=\"#q005\">热重载hot reload未生效</a><br><a href=\"#q006\">转场动画在list内黑屏不生效</a><br><a href=\"#q007\">Android plugin内不能使用AAR包</a><br><a href=\"#q008\">Android plugin内AAR包内的so库加载不出来</a><br><a href=\"#q009\">Json注解制动生成的解析文件解析数据失败</a><br><a href=\"#q010\">加载更多后头像加载慢或不加载</a><br><a href=\"#q011\">dio安卓上网络请求失败</a><br><a href=\"#q012\">NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效</a><br><a href=\"#q013\">枚举值需要取index，否则打印类名</a><br><a href=\"#q014\">flutter动画不执行</a><br><a href=\"#q015\">在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失</a><br><a href=\"#q016\">dispose后不允许setState</a><br><a href=\"#q017\">滑动冲突</a><br><a href=\"#q018\">Row中的Text控件出现overflow警告</a><br><a href=\"#q019\">webview无法连接网络</a></p>\n<h2 id=\"q001\"><a href=\"#q001\" class=\"headerlink\" title=\"q001\"></a>q001</h2><p><strong>TabBar及PageView状态保存</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>子页面离开屏幕时，state会被销毁引发的bug<br><a href=\"https://juejin.im/post/5b73c3b3f265da27d701473a\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5b73c3b3f265da27d701473a</a></p>\n<h2 id=\"q002\"><a href=\"#q002\" class=\"headerlink\" title=\"q002\"></a>q002</h2><p><strong>ScrollView滚动进度保存</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>进入其他页面返回后保存scrollView的offset<br><a href=\"https://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages</a></p>\n<h2 id=\"q003\"><a href=\"#q003\" class=\"headerlink\" title=\"q003\"></a>q003</h2><p><strong>ListView下拉刷新后数据已返回，UI未更新</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>ListView需要有Key，否则被复用引发的UI不立即更新bug<br><a href=\"https://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert</a></p>\n<h2 id=\"q004\"><a href=\"#q004\" class=\"headerlink\" title=\"q004\"></a>q004</h2><p><strong>中文汉字变形</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>该问题发生在MaterialApp中，多数情况与fontfamily有关。<br><a href=\"https://github.com/flutter/flutter/issues/22966\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/22966</a><br><a href=\"https://github.com/flutter/flutter/issues/26752\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/26752</a><br><a href=\"https://github.com/flutter/flutter/issues/25726\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/25726</a></p>\n<h2 id=\"q005\"><a href=\"#q005\" class=\"headerlink\" title=\"q005\"></a>q005</h2><p><strong>热重载hot reload未生效</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>目前已知几种情况下，hot reload无法生效</p>\n<ul>\n<li>需要build_runner做代码生成部分的代码</li>\n<li>使用了新添加的资源</li>\n</ul>\n<p>发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。</p>\n<h2 id=\"q006\"><a href=\"#q006\" class=\"headerlink\" title=\"q006\"></a>q006</h2><p><strong>转场动画在list内黑屏不生效</strong><br>Hero转场动画在list内黑屏不生效<br>原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素<br>解决方案：tag随机生成，并通过参数传入下个页面</p>\n<h2 id=\"q007\"><a href=\"#q007\" class=\"headerlink\" title=\"q007\"></a>q007</h2><p><strong>Android plugin内不能使用AAR包</strong><br>Android插件开发中，AAR包引用不到<br>原因：flutter暂不支持AAR的引用，仅支持gradle方式引用<br>解决方案：</p>\n<ol>\n<li>放弃插件方案，直接在application工程下开发flutter与native的交互方案</li>\n<li>百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。<br>WIKI：<a href=\"http://wiki.baidu.com/pages/viewpage.action?pageId=465488650\" target=\"_blank\" rel=\"noopener\">http://wiki.baidu.com/pages/viewpage.action?pageId=465488650</a><br>maven库地址：<a href=\"http://maven.baidu-int.com/nexus/content/groups/public\" target=\"_blank\" rel=\"noopener\">http://maven.baidu-int.com/nexus/content/groups/public</a><br>链接：<a href=\"http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/\" target=\"_blank\" rel=\"noopener\">http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/</a><br>使用方法：compile ‘com.baidu.bdpass:HWOpenSDK:3.3.3@aar’<br>接口人：<a href=\"mailto:zhanghuaming@baidu.com\" target=\"_blank\" rel=\"noopener\">zhanghuaming@baidu.com</a></li>\n</ol>\n<h2 id=\"q008\"><a href=\"#q008\" class=\"headerlink\" title=\"q008\"></a>q008</h2><p><strong>Android plugin内AAR包内的so库加载不出来</strong><br>Android 插件通过gradle方式引用AAR包，但是其中的so库load不出来<br>原因：flutter对AAR包的引用支持不好<br>解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代</p>\n<h2 id=\"q009\"><a href=\"#q009\" class=\"headerlink\" title=\"q009\"></a>q009</h2><p><strong>Json注解制动生成的解析文件解析数据失败</strong><br>原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串<br>解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null</p>\n<h2 id=\"q010\"><a href=\"#q010\" class=\"headerlink\" title=\"q010\"></a>q010</h2><p><strong>Json注解制动生成的解析文件解析数据失败</strong><br>原因：View复用导致没有刷新<br>解决方案：需要给头像控件增加一个单独的Key</p>\n<p>##q011<br>原因：没有网络请求的权限<br>解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限</p>\n<p>##q012<br>原因：未知<br>解决方案：改用NotificationListener</p>\n<h2 id=\"q014\"><a href=\"#q014\" class=\"headerlink\" title=\"q014\"></a>q014</h2><p><strong>flutter动画不执行</strong><br>原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾<br>方案：动画controller写成全局变量，执行动画前先调reset方法。</p>\n<h2 id=\"q015\"><a href=\"#q015\" class=\"headerlink\" title=\"q015\"></a>q015</h2><p><strong>在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失</strong><br>原因不明。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SliverAppBar(</span><br><span class=\"line\">  flexibleSpace: FlexibleSpaceBar(</span><br><span class=\"line\">    background: PageView.builder(</span><br><span class=\"line\">      ... ...</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>PageView若更换成其他非滑动型控件，则无此问题。</p>\n<h2 id=\"q016\"><a href=\"#q016\" class=\"headerlink\" title=\"q016\"></a>q016</h2><p>原因：内存泄漏<br>方案：dispose时将callBack等异步操作取消或置null</p>\n<h2 id=\"q017\"><a href=\"#q017\" class=\"headerlink\" title=\"q017\"></a>q017</h2><p><strong>滑动冲突</strong><br>原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件<br>解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TabBarView(</span><br><span class=\"line\">   children: children,</span><br><span class=\"line\">   physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),</span><br><span class=\"line\">),</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"q018\"><a href=\"#q018\" class=\"headerlink\" title=\"q018\"></a>q018</h2><p>方案：将Text嵌套在Expanded中</p>\n<h2 id=\"q019\"><a href=\"#q019\" class=\"headerlink\" title=\"q019\"></a>q019</h2><p>Info.plist中加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt;</span><br><span class=\"line\">&lt;true/&gt;</span><br><span class=\"line\">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"iOS基础-UIControlState","date":"2016-10-08T11:40:13.000Z","_content":"\n以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。\n\n在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？\n\n看一下UIControlState的定义：\n```\ntypedef NS_OPTIONS(NSUInteger, UIControlState) {\n    UIControlStateNormal       = 0,\n    UIControlStateHighlighted  = 1 << 0,                  // used when UIControl isHighlighted is set\n    UIControlStateDisabled     = 1 << 1,\n    UIControlStateSelected     = 1 << 2,                  // flag usable by app (see below)\n    UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 << 3, // Applicable only when the screen supports focus\n    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use\n    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use\n};\n```\n\n**需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM**\n这几种状态转化成二进制实际上是：\n```\n   0\n   1\n  10\n 100\n1000\n```\n这意味着我们可以对其进行位操作，比如：\n`[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];`\n以上表示，设置按钮被选中且高亮时的图片。","source":"_posts/iOS基础-UIControlState.md","raw":"---\ntitle: iOS基础-UIControlState\ndate: 2016-10-08 19:40:13\ncategories: iOS基础知识\ntags:\n    - UIControlState\n---\n\n以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。\n\n在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？\n\n看一下UIControlState的定义：\n```\ntypedef NS_OPTIONS(NSUInteger, UIControlState) {\n    UIControlStateNormal       = 0,\n    UIControlStateHighlighted  = 1 << 0,                  // used when UIControl isHighlighted is set\n    UIControlStateDisabled     = 1 << 1,\n    UIControlStateSelected     = 1 << 2,                  // flag usable by app (see below)\n    UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 << 3, // Applicable only when the screen supports focus\n    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use\n    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use\n};\n```\n\n**需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM**\n这几种状态转化成二进制实际上是：\n```\n   0\n   1\n  10\n 100\n1000\n```\n这意味着我们可以对其进行位操作，比如：\n`[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];`\n以上表示，设置按钮被选中且高亮时的图片。","slug":"iOS基础-UIControlState","published":1,"updated":"2019-06-12T05:46:11.538Z","_id":"cjwss6z5a00015mlws9617c8p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。</p>\n<p>在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？</p>\n<p>看一下UIControlState的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, UIControlState) &#123;</span><br><span class=\"line\">    UIControlStateNormal       = 0,</span><br><span class=\"line\">    UIControlStateHighlighted  = 1 &lt;&lt; 0,                  // used when UIControl isHighlighted is set</span><br><span class=\"line\">    UIControlStateDisabled     = 1 &lt;&lt; 1,</span><br><span class=\"line\">    UIControlStateSelected     = 1 &lt;&lt; 2,                  // flag usable by app (see below)</span><br><span class=\"line\">    UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 &lt;&lt; 3, // Applicable only when the screen supports focus</span><br><span class=\"line\">    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use</span><br><span class=\"line\">    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM</strong><br>这几种状态转化成二进制实际上是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   0</span><br><span class=\"line\">   1</span><br><span class=\"line\">  10</span><br><span class=\"line\"> 100</span><br><span class=\"line\">1000</span><br></pre></td></tr></table></figure></p>\n<p>这意味着我们可以对其进行位操作，比如：<br><code>[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];</code><br>以上表示，设置按钮被选中且高亮时的图片。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。</p>\n<p>在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？</p>\n<p>看一下UIControlState的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, UIControlState) &#123;</span><br><span class=\"line\">    UIControlStateNormal       = 0,</span><br><span class=\"line\">    UIControlStateHighlighted  = 1 &lt;&lt; 0,                  // used when UIControl isHighlighted is set</span><br><span class=\"line\">    UIControlStateDisabled     = 1 &lt;&lt; 1,</span><br><span class=\"line\">    UIControlStateSelected     = 1 &lt;&lt; 2,                  // flag usable by app (see below)</span><br><span class=\"line\">    UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 &lt;&lt; 3, // Applicable only when the screen supports focus</span><br><span class=\"line\">    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use</span><br><span class=\"line\">    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><strong>需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM</strong><br>这几种状态转化成二进制实际上是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   0</span><br><span class=\"line\">   1</span><br><span class=\"line\">  10</span><br><span class=\"line\"> 100</span><br><span class=\"line\">1000</span><br></pre></td></tr></table></figure></p>\n<p>这意味着我们可以对其进行位操作，比如：<br><code>[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];</code><br>以上表示，设置按钮被选中且高亮时的图片。</p>\n"},{"title":"iOS基础-NSNotificationCenter小结","date":"2018-01-02T06:51:20.000Z","_content":"\n## 线程问题\n日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。\nNSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)];\n    test.backgroundColor = [UIColor blueColor];\n    [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:test];\n    \n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@\"asycObserverNotification\" object:nil];\n    });\n    \n    UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)];\n    test1.backgroundColor = [UIColor blueColor];\n    [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:test1];\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@\"asycPostNotification\" object:nil];\n}\n\n// 主线程发\n- (void)syncPost\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"asycObserverNotification\" object:nil];\n}\n\n// 子线程收\n- (void)lisetner\n{\n    NSLog(@\"Async Observer! - %@\", [NSThread currentThread]);\n}\n\n// 子线程发\n- (void)asyncPost\n{\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"asycPostNotification\" object:nil];\n    });\n}\n\n// 主线程收\n- (void)lisetner1\n{\n    NSLog(@\"Async Post! - %@\", [NSThread currentThread]);\n    self.view.backgroundColor = [UIColor grayColor];\n    [self.view layoutIfNeeded];\n}\n```\n\n执行结果如下：\n```\n2018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - <NSThread: 0x1c407d4c0>{number = 1, name = main}\n\n2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - <NSThread: 0x1c027dc40>{number = 5, name = (null)}\n```","source":"_posts/iOS基础-NSNotificationCenter小结.md","raw":"---\ntitle: iOS基础-NSNotificationCenter小结\ndate: 2018-01-02 14:51:20\ncategories: iOS基础知识\ntags:\n    - NSNotificationCenter\n---\n\n## 线程问题\n日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。\nNSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)];\n    test.backgroundColor = [UIColor blueColor];\n    [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:test];\n    \n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@\"asycObserverNotification\" object:nil];\n    });\n    \n    UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)];\n    test1.backgroundColor = [UIColor blueColor];\n    [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:test1];\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@\"asycPostNotification\" object:nil];\n}\n\n// 主线程发\n- (void)syncPost\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"asycObserverNotification\" object:nil];\n}\n\n// 子线程收\n- (void)lisetner\n{\n    NSLog(@\"Async Observer! - %@\", [NSThread currentThread]);\n}\n\n// 子线程发\n- (void)asyncPost\n{\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"asycPostNotification\" object:nil];\n    });\n}\n\n// 主线程收\n- (void)lisetner1\n{\n    NSLog(@\"Async Post! - %@\", [NSThread currentThread]);\n    self.view.backgroundColor = [UIColor grayColor];\n    [self.view layoutIfNeeded];\n}\n```\n\n执行结果如下：\n```\n2018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - <NSThread: 0x1c407d4c0>{number = 1, name = main}\n\n2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - <NSThread: 0x1c027dc40>{number = 5, name = (null)}\n```","slug":"iOS基础-NSNotificationCenter小结","published":1,"updated":"2019-06-12T05:10:04.368Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwss6z5x00035mlwuxhaqjli","content":"<h2 id=\"线程问题\"><a href=\"#线程问题\" class=\"headerlink\" title=\"线程问题\"></a>线程问题</h2><p>日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。<br>NSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)];</span><br><span class=\"line\">    test.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    [self.view addSubview:test];</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@&quot;asycObserverNotification&quot; object:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)];</span><br><span class=\"line\">    test1.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    [self.view addSubview:test1];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@&quot;asycPostNotification&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 主线程发</span><br><span class=\"line\">- (void)syncPost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycObserverNotification&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子线程收</span><br><span class=\"line\">- (void)lisetner</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Async Observer! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子线程发</span><br><span class=\"line\">- (void)asyncPost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycPostNotification&quot; object:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 主线程收</span><br><span class=\"line\">- (void)lisetner1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Async Post! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    self.view.backgroundColor = [UIColor grayColor];</span><br><span class=\"line\">    [self.view layoutIfNeeded];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - &lt;NSThread: 0x1c407d4c0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - &lt;NSThread: 0x1c027dc40&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线程问题\"><a href=\"#线程问题\" class=\"headerlink\" title=\"线程问题\"></a>线程问题</h2><p>日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。<br>NSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)];</span><br><span class=\"line\">    test.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    [self.view addSubview:test];</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@&quot;asycObserverNotification&quot; object:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)];</span><br><span class=\"line\">    test1.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    [self.view addSubview:test1];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@&quot;asycPostNotification&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 主线程发</span><br><span class=\"line\">- (void)syncPost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycObserverNotification&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子线程收</span><br><span class=\"line\">- (void)lisetner</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Async Observer! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子线程发</span><br><span class=\"line\">- (void)asyncPost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycPostNotification&quot; object:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 主线程收</span><br><span class=\"line\">- (void)lisetner1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Async Post! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    self.view.backgroundColor = [UIColor grayColor];</span><br><span class=\"line\">    [self.view layoutIfNeeded];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - &lt;NSThread: 0x1c407d4c0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - &lt;NSThread: 0x1c027dc40&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"iOS基础-GCD","date":"2016-08-11T12:34:23.000Z","_content":"\nGCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。\n\n# 前提\n1. 代码是顺序执行的。\n2. queue是FIFO（先进先出）的数据结构。\n3. 线程之间是并行的。\n4. `串行队列`：任务`不能同时进行`，这意味着第n+1个任务必须等待0...n个任务全部完成后才会开始。\n5. `并发队列`：任务`可以同时进行`，这意味着只要0...n个任务开始执行，那么第n+1个任务也可以开始。\n6. `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`：将任务（也就是block）放到队列中，同步执行，也就是说在`当前线程`中执行任务，`阻塞当前线程`。\n7. `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`：将任务放到队列中，异步执行，也就是说在`其他线程`中执行任务，`不阻塞当前线程`。（在下文的推演中，发现其并不总是在`其他线程`中执行）\n（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue）\n\n# 验证\n## 1. 代码是顺序执行的。\n```\n    NSLog(@\"step0\");\n    NSLog(@\"step1\");\n```\n\n```\n    2016-08-12 22:29:49.002 MyPractice[25215:3752290] step0\n    2016-08-12 22:29:49.002 MyPractice[25215:3752290] step1\n```\n可以看到确实是顺序执行的（严肃脸）。\n\n## 2. queue是FIFO（先进先出）的数据结构。\n\n## 3. 线程之间是并行的。\n\n## 4. `串行队列`：任务`不能同时进行`，这意味着第n+1个任务必须等待0...n个任务全部完成后才会开始。\n首先来看什么是`DISPATCH_QUEUE_SERIAL`。\n```\n    /*!\n     * @const DISPATCH_QUEUE_SERIAL\n     * @discussion A dispatch queue that invokes blocks serially in FIFO order.\n     */\n    #define DISPATCH_QUEUE_SERIAL NULL\n```\n该队列以先进先出的顺序串行调用blocks。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    for (int i = 0; i < 3; i++) {\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.%d finished! - %@\", i, [NSThread currentThread]);\n        });\n    }\n    \n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - <NSThread: 0x7fac03602dd0>{number = 1, name = main}\n2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - <NSThread: 0x7fac03602dd0>{number = 1, name = main}\n2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n```\n可以看到1大类中的三个任务顺序执行。\n\n## 5. `并发队列`：任务`可以同时进行`，这意味着只要0...n个任务开始执行，那么第n+1个任务也可以开始。\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    for (int i = 0; i < 3; i++) {\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.%d finished! - %@\", i, [NSThread currentThread]);\n        });\n    }\n    \n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - <NSThread: 0x7f9c08c059f0>{number = 1, name = main}\n2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - <NSThread: 0x7f9c08c059f0>{number = 1, name = main}\n2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - <NSThread: 0x7f9c08f04540>{number = 3, name = (null)}\n2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - <NSThread: 0x7f9c08d0acc0>{number = 2, name = (null)}\n2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - <NSThread: 0x7f9c08e0b560>{number = 4, name = (null)}\n```\n可以看到1大类中的三个任务同时执行。\n\n## 6. `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`：将任务（也就是block）放到队列中，同步执行，也就是说在`当前线程`中执行任务，`阻塞当前线程`。\n### dispatch_sync任务到其它串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{    // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n```\nblock1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。\n\n### dispatch_sync任务到当前串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - <NSThread: 0x7f80d8701fc0>{number = 1, name = main}\n```\n整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。\n至此，block0与block1循环等待，死锁。\n\n### dispatch_sync任务到其它并发队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n```\nstep0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。\n\n**总结**\n```\n/*!\n * @function dispatch_sync\n *\n * @abstract\n * Submits a block for synchronous execution on a dispatch queue.\n *\n * @discussion\n * Submits a block to a dispatch queue like dispatch_async(), however\n * dispatch_sync() will not return until the block has finished.\n *\n * Calls to dispatch_sync() targeting the current queue will result\n * in dead-lock. Use of dispatch_sync() is also subject to the same\n * multi-party dead-lock problems that may result from the use of a mutex.\n * Use of dispatch_async() is preferred.\n *\n * Unlike dispatch_async(), no retain is performed on the target queue. Because\n * calls to this function are synchronous, the dispatch_sync() \"borrows\" the\n * reference of the caller.\n *\n * As an optimization, dispatch_sync() invokes the block on the current\n * thread when possible.\n *\n * @param queue\n * The target dispatch queue to which the block is submitted.\n * The result of passing NULL in this parameter is undefined.\n *\n * @param block\n * The block to be invoked on the target dispatch queue.\n * The result of passing NULL in this parameter is undefined.\n */\n#ifdef __BLOCKS__\n__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\n#endif\n```\n- dispatch_sync()在block结束前不会返回。\n- dispatch_sync()任务到当前队列中会引起死锁。\n- 系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。\n- dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。\n- 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。\n- 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。\n\n## 7. `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`：将任务放到队列中，异步执行，也就是说在`其他线程`中执行任务，`不阻塞当前线程`。\n### dispatch_async任务到其它串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - <NSThread: 0x7fe7196022e0>{number = 1, name = main}\n2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - <NSThread: 0x7fe7196a2f50>{number = 2, name = (null)}\n2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - <NSThread: 0x7fe7196022e0>{number = 1, name = main}\n```\n执行顺序为step0 -> step1 -> step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。\n程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。\n\n### dispatch_async任务到当前串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n```\n执行顺序为step0 -> step2 -> step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。\n执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。\n\n### dispatch_async任务到其他并发队列中。\n已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。\n\n**总结**\n```\n/*!\n * @function dispatch_async\n *\n * @abstract\n * Submits a block for asynchronous execution on a dispatch queue.\n *\n * @discussion\n * The dispatch_async() function is the fundamental mechanism for submitting\n * blocks to a dispatch queue.\n *\n * Calls to dispatch_async() always return immediately after the block has\n * been submitted, and never wait for the block to be invoked.\n *\n * The target queue determines whether the block will be invoked serially or\n * concurrently with respect to other blocks submitted to that same queue.\n * Serial queues are processed concurrently with respect to each other.\n *\n * @param queue\n * The target dispatch queue to which the block is submitted.\n * The system will hold a reference on the target queue until the block\n * has finished.\n * The result of passing NULL in this parameter is undefined.\n *\n * @param block\n * The block to submit to the target dispatch queue. This function performs\n * Block_copy() and Block_release() on behalf of callers.\n * The result of passing NULL in this parameter is undefined.\n */\n#ifdef __BLOCKS__\n__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n#endif\n```\n- dispatch_async()的机制是把blocks任务提交到队列中。\n- dispatch_async()会立即返回而不会等待block完成。\n- 目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。\n**这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验**\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1.1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1.1 finished! - %@\", [NSThread currentThread]);\n        \n        dispatch_async(queue, ^{     // block1.2\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.2 finished! - %@\", [NSThread currentThread]);\n        });\n    });\n    \n    dispatch_async(queue, ^{     // block1.3\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1.3 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:3];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - <NSThread: 0x7fbe786079a0>{number = 1, name = main}\n2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - <NSThread: 0x7fbe786079a0>{number = 1, name = main}\n2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n```\nblock1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；\nblock1.2仍然在当前线程（0x7fbe78419320）中执行；\n另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程；\n\n结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系：\n- 主队列对应着主线程；\n- 并发队列对应多条线程（非主线程）；\n- 串行队列对应着一条线程（非主线程）；\n- dispatch_sync&dispatch_async：调度对应线程池中的线程；\n\n接下来继续解读官方API\n- 系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放）\n- 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。\n- dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease）\n- 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。\n\n最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    __weak ViewController* weakSelf = self;\n    dispatch_async(queue, ^{     // block1\n        NSLog(@\"before step1! - %@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1];\n        weakSelf.view.backgroundColor = [UIColor blueColor];\n        NSLog(@\"after step1! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - <NSThread: 0x7fd5e1403450>{number = 1, name = main}\n2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - <NSThread: 0x7fd5e1523bb0>{number = 2, name = (null)}\n2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - <NSThread: 0x7fd5e1523bb0>{number = 2, name = (null)}\n2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - <NSThread: 0x7fd5e1403450>{number = 1, name = main}\n```\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    __weak ViewController* weakSelf = self;\n    dispatch_sync(queue, ^{     // block1\n        NSLog(@\"before step1! - %@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1];\n        weakSelf.view.backgroundColor = [UIColor blueColor];\n        NSLog(@\"after step1! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n```\n\n可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。\n此处迷茫++，还得继续研究啊...\n","source":"_posts/iOS基础-GCD.md","raw":"---\ntitle: iOS基础-GCD\ndate: 2016-08-11 20:34:23\ncategories: iOS基础知识\ntags: \n    - 多线程\n    - GCD\n---\n\nGCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。\n\n# 前提\n1. 代码是顺序执行的。\n2. queue是FIFO（先进先出）的数据结构。\n3. 线程之间是并行的。\n4. `串行队列`：任务`不能同时进行`，这意味着第n+1个任务必须等待0...n个任务全部完成后才会开始。\n5. `并发队列`：任务`可以同时进行`，这意味着只要0...n个任务开始执行，那么第n+1个任务也可以开始。\n6. `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`：将任务（也就是block）放到队列中，同步执行，也就是说在`当前线程`中执行任务，`阻塞当前线程`。\n7. `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`：将任务放到队列中，异步执行，也就是说在`其他线程`中执行任务，`不阻塞当前线程`。（在下文的推演中，发现其并不总是在`其他线程`中执行）\n（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue）\n\n# 验证\n## 1. 代码是顺序执行的。\n```\n    NSLog(@\"step0\");\n    NSLog(@\"step1\");\n```\n\n```\n    2016-08-12 22:29:49.002 MyPractice[25215:3752290] step0\n    2016-08-12 22:29:49.002 MyPractice[25215:3752290] step1\n```\n可以看到确实是顺序执行的（严肃脸）。\n\n## 2. queue是FIFO（先进先出）的数据结构。\n\n## 3. 线程之间是并行的。\n\n## 4. `串行队列`：任务`不能同时进行`，这意味着第n+1个任务必须等待0...n个任务全部完成后才会开始。\n首先来看什么是`DISPATCH_QUEUE_SERIAL`。\n```\n    /*!\n     * @const DISPATCH_QUEUE_SERIAL\n     * @discussion A dispatch queue that invokes blocks serially in FIFO order.\n     */\n    #define DISPATCH_QUEUE_SERIAL NULL\n```\n该队列以先进先出的顺序串行调用blocks。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    for (int i = 0; i < 3; i++) {\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.%d finished! - %@\", i, [NSThread currentThread]);\n        });\n    }\n    \n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - <NSThread: 0x7fac03602dd0>{number = 1, name = main}\n2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - <NSThread: 0x7fac03602dd0>{number = 1, name = main}\n2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n```\n可以看到1大类中的三个任务顺序执行。\n\n## 5. `并发队列`：任务`可以同时进行`，这意味着只要0...n个任务开始执行，那么第n+1个任务也可以开始。\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    for (int i = 0; i < 3; i++) {\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.%d finished! - %@\", i, [NSThread currentThread]);\n        });\n    }\n    \n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - <NSThread: 0x7f9c08c059f0>{number = 1, name = main}\n2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - <NSThread: 0x7f9c08c059f0>{number = 1, name = main}\n2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - <NSThread: 0x7f9c08f04540>{number = 3, name = (null)}\n2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - <NSThread: 0x7f9c08d0acc0>{number = 2, name = (null)}\n2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - <NSThread: 0x7f9c08e0b560>{number = 4, name = (null)}\n```\n可以看到1大类中的三个任务同时执行。\n\n## 6. `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`：将任务（也就是block）放到队列中，同步执行，也就是说在`当前线程`中执行任务，`阻塞当前线程`。\n### dispatch_sync任务到其它串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{    // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n```\nblock1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。\n\n### dispatch_sync任务到当前串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - <NSThread: 0x7f80d8701fc0>{number = 1, name = main}\n```\n整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。\n至此，block0与block1循环等待，死锁。\n\n### dispatch_sync任务到其它并发队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n```\nstep0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。\n\n**总结**\n```\n/*!\n * @function dispatch_sync\n *\n * @abstract\n * Submits a block for synchronous execution on a dispatch queue.\n *\n * @discussion\n * Submits a block to a dispatch queue like dispatch_async(), however\n * dispatch_sync() will not return until the block has finished.\n *\n * Calls to dispatch_sync() targeting the current queue will result\n * in dead-lock. Use of dispatch_sync() is also subject to the same\n * multi-party dead-lock problems that may result from the use of a mutex.\n * Use of dispatch_async() is preferred.\n *\n * Unlike dispatch_async(), no retain is performed on the target queue. Because\n * calls to this function are synchronous, the dispatch_sync() \"borrows\" the\n * reference of the caller.\n *\n * As an optimization, dispatch_sync() invokes the block on the current\n * thread when possible.\n *\n * @param queue\n * The target dispatch queue to which the block is submitted.\n * The result of passing NULL in this parameter is undefined.\n *\n * @param block\n * The block to be invoked on the target dispatch queue.\n * The result of passing NULL in this parameter is undefined.\n */\n#ifdef __BLOCKS__\n__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\n#endif\n```\n- dispatch_sync()在block结束前不会返回。\n- dispatch_sync()任务到当前队列中会引起死锁。\n- 系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。\n- dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。\n- 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。\n- 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。\n\n## 7. `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`：将任务放到队列中，异步执行，也就是说在`其他线程`中执行任务，`不阻塞当前线程`。\n### dispatch_async任务到其它串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - <NSThread: 0x7fe7196022e0>{number = 1, name = main}\n2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - <NSThread: 0x7fe7196a2f50>{number = 2, name = (null)}\n2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - <NSThread: 0x7fe7196022e0>{number = 1, name = main}\n```\n执行顺序为step0 -> step1 -> step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。\n程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。\n\n### dispatch_async任务到当前串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n```\n执行顺序为step0 -> step2 -> step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。\n执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。\n\n### dispatch_async任务到其他并发队列中。\n已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。\n\n**总结**\n```\n/*!\n * @function dispatch_async\n *\n * @abstract\n * Submits a block for asynchronous execution on a dispatch queue.\n *\n * @discussion\n * The dispatch_async() function is the fundamental mechanism for submitting\n * blocks to a dispatch queue.\n *\n * Calls to dispatch_async() always return immediately after the block has\n * been submitted, and never wait for the block to be invoked.\n *\n * The target queue determines whether the block will be invoked serially or\n * concurrently with respect to other blocks submitted to that same queue.\n * Serial queues are processed concurrently with respect to each other.\n *\n * @param queue\n * The target dispatch queue to which the block is submitted.\n * The system will hold a reference on the target queue until the block\n * has finished.\n * The result of passing NULL in this parameter is undefined.\n *\n * @param block\n * The block to submit to the target dispatch queue. This function performs\n * Block_copy() and Block_release() on behalf of callers.\n * The result of passing NULL in this parameter is undefined.\n */\n#ifdef __BLOCKS__\n__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n#endif\n```\n- dispatch_async()的机制是把blocks任务提交到队列中。\n- dispatch_async()会立即返回而不会等待block完成。\n- 目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。\n**这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验**\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1.1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1.1 finished! - %@\", [NSThread currentThread]);\n        \n        dispatch_async(queue, ^{     // block1.2\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.2 finished! - %@\", [NSThread currentThread]);\n        });\n    });\n    \n    dispatch_async(queue, ^{     // block1.3\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1.3 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:3];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - <NSThread: 0x7fbe786079a0>{number = 1, name = main}\n2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - <NSThread: 0x7fbe786079a0>{number = 1, name = main}\n2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n```\nblock1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；\nblock1.2仍然在当前线程（0x7fbe78419320）中执行；\n另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程；\n\n结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系：\n- 主队列对应着主线程；\n- 并发队列对应多条线程（非主线程）；\n- 串行队列对应着一条线程（非主线程）；\n- dispatch_sync&dispatch_async：调度对应线程池中的线程；\n\n接下来继续解读官方API\n- 系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放）\n- 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。\n- dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease）\n- 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。\n\n最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    __weak ViewController* weakSelf = self;\n    dispatch_async(queue, ^{     // block1\n        NSLog(@\"before step1! - %@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1];\n        weakSelf.view.backgroundColor = [UIColor blueColor];\n        NSLog(@\"after step1! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - <NSThread: 0x7fd5e1403450>{number = 1, name = main}\n2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - <NSThread: 0x7fd5e1523bb0>{number = 2, name = (null)}\n2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - <NSThread: 0x7fd5e1523bb0>{number = 2, name = (null)}\n2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - <NSThread: 0x7fd5e1403450>{number = 1, name = main}\n```\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    __weak ViewController* weakSelf = self;\n    dispatch_sync(queue, ^{     // block1\n        NSLog(@\"before step1! - %@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1];\n        weakSelf.view.backgroundColor = [UIColor blueColor];\n        NSLog(@\"after step1! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n```\n\n可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。\n此处迷茫++，还得继续研究啊...\n","slug":"iOS基础-GCD","published":1,"updated":"2019-06-12T05:45:29.175Z","_id":"cjwss6z6000055mlwkn39i8ri","comments":1,"layout":"post","photos":[],"link":"","content":"<p>GCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。</p>\n<h1 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h1><ol>\n<li>代码是顺序执行的。</li>\n<li>queue是FIFO（先进先出）的数据结构。</li>\n<li>线程之间是并行的。</li>\n<li><code>串行队列</code>：任务<code>不能同时进行</code>，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。</li>\n<li><code>并发队列</code>：任务<code>可以同时进行</code>，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。</li>\n<li><code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务（也就是block）放到队列中，同步执行，也就是说在<code>当前线程</code>中执行任务，<code>阻塞当前线程</code>。</li>\n<li><code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务放到队列中，异步执行，也就是说在<code>其他线程</code>中执行任务，<code>不阻塞当前线程</code>。（在下文的推演中，发现其并不总是在<code>其他线程</code>中执行）<br>（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue）</li>\n</ol>\n<h1 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h1><h2 id=\"1-代码是顺序执行的。\"><a href=\"#1-代码是顺序执行的。\" class=\"headerlink\" title=\"1. 代码是顺序执行的。\"></a>1. 代码是顺序执行的。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSLog(@&quot;step0&quot;);</span><br><span class=\"line\">NSLog(@&quot;step1&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-12 22:29:49.002 MyPractice[25215:3752290] step0</span><br><span class=\"line\">2016-08-12 22:29:49.002 MyPractice[25215:3752290] step1</span><br></pre></td></tr></table></figure>\n<p>可以看到确实是顺序执行的（严肃脸）。</p>\n<h2 id=\"2-queue是FIFO（先进先出）的数据结构。\"><a href=\"#2-queue是FIFO（先进先出）的数据结构。\" class=\"headerlink\" title=\"2. queue是FIFO（先进先出）的数据结构。\"></a>2. queue是FIFO（先进先出）的数据结构。</h2><h2 id=\"3-线程之间是并行的。\"><a href=\"#3-线程之间是并行的。\" class=\"headerlink\" title=\"3. 线程之间是并行的。\"></a>3. 线程之间是并行的。</h2><h2 id=\"4-串行队列：任务不能同时进行，这意味着第n-1个任务必须等待0…n个任务全部完成后才会开始。\"><a href=\"#4-串行队列：任务不能同时进行，这意味着第n-1个任务必须等待0…n个任务全部完成后才会开始。\" class=\"headerlink\" title=\"4. 串行队列：任务不能同时进行，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。\"></a>4. <code>串行队列</code>：任务<code>不能同时进行</code>，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。</h2><p>首先来看什么是<code>DISPATCH_QUEUE_SERIAL</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @const DISPATCH_QUEUE_SERIAL</span><br><span class=\"line\"> * @discussion A dispatch queue that invokes blocks serially in FIFO order.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL NULL</span><br></pre></td></tr></table></figure></p>\n<p>该队列以先进先出的顺序串行调用blocks。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到1大类中的三个任务顺序执行。</p>\n<h2 id=\"5-并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n-1个任务也可以开始。\"><a href=\"#5-并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n-1个任务也可以开始。\" class=\"headerlink\" title=\"5. 并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。\"></a>5. <code>并发队列</code>：任务<code>可以同时进行</code>，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - &lt;NSThread: 0x7f9c08f04540&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - &lt;NSThread: 0x7f9c08d0acc0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - &lt;NSThread: 0x7f9c08e0b560&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到1大类中的三个任务同时执行。</p>\n<h2 id=\"6-void-dispatch-sync-dispatch-queue-t-queue-dispatch-block-t-block-：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\"><a href=\"#6-void-dispatch-sync-dispatch-queue-t-queue-dispatch-block-t-block-：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\" class=\"headerlink\" title=\"6. void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\"></a>6. <code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务（也就是block）放到队列中，同步执行，也就是说在<code>当前线程</code>中执行任务，<code>阻塞当前线程</code>。</h2><h3 id=\"dispatch-sync任务到其它串行队列中。\"><a href=\"#dispatch-sync任务到其它串行队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到其它串行队列中。\"></a>dispatch_sync任务到其它串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;    // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>block1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。</p>\n<h3 id=\"dispatch-sync任务到当前串行队列中。\"><a href=\"#dispatch-sync任务到当前串行队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到当前串行队列中。\"></a>dispatch_sync任务到当前串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - &lt;NSThread: 0x7f80d8701fc0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。<br>至此，block0与block1循环等待，死锁。</p>\n<h3 id=\"dispatch-sync任务到其它并发队列中。\"><a href=\"#dispatch-sync任务到其它并发队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到其它并发队列中。\"></a>dispatch_sync任务到其它并发队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>step0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。</p>\n<p><strong>总结</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @function dispatch_sync</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @abstract</span><br><span class=\"line\"> * Submits a block for synchronous execution on a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @discussion</span><br><span class=\"line\"> * Submits a block to a dispatch queue like dispatch_async(), however</span><br><span class=\"line\"> * dispatch_sync() will not return until the block has finished.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Calls to dispatch_sync() targeting the current queue will result</span><br><span class=\"line\"> * in dead-lock. Use of dispatch_sync() is also subject to the same</span><br><span class=\"line\"> * multi-party dead-lock problems that may result from the use of a mutex.</span><br><span class=\"line\"> * Use of dispatch_async() is preferred.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Unlike dispatch_async(), no retain is performed on the target queue. Because</span><br><span class=\"line\"> * calls to this function are synchronous, the dispatch_sync() &quot;borrows&quot; the</span><br><span class=\"line\"> * reference of the caller.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * As an optimization, dispatch_sync() invokes the block on the current</span><br><span class=\"line\"> * thread when possible.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param queue</span><br><span class=\"line\"> * The target dispatch queue to which the block is submitted.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param block</span><br><span class=\"line\"> * The block to be invoked on the target dispatch queue.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#ifdef __BLOCKS__</span><br><span class=\"line\">__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)</span><br><span class=\"line\">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\">void</span><br><span class=\"line\">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dispatch_sync()在block结束前不会返回。</li>\n<li>dispatch_sync()任务到当前队列中会引起死锁。</li>\n<li>系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。</li>\n<li>dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。</li>\n<li>参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。</li>\n<li>参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。</li>\n</ul>\n<h2 id=\"7-void-dispatch-async-dispatch-queue-t-queue-dispatch-block-t-block-：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\"><a href=\"#7-void-dispatch-async-dispatch-queue-t-queue-dispatch-block-t-block-：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\" class=\"headerlink\" title=\"7. void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\"></a>7. <code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务放到队列中，异步执行，也就是说在<code>其他线程</code>中执行任务，<code>不阻塞当前线程</code>。</h2><h3 id=\"dispatch-async任务到其它串行队列中。\"><a href=\"#dispatch-async任务到其它串行队列中。\" class=\"headerlink\" title=\"dispatch_async任务到其它串行队列中。\"></a>dispatch_async任务到其它串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - &lt;NSThread: 0x7fe7196a2f50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>执行顺序为step0 -&gt; step1 -&gt; step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。<br>程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。</p>\n<h3 id=\"dispatch-async任务到当前串行队列中。\"><a href=\"#dispatch-async任务到当前串行队列中。\" class=\"headerlink\" title=\"dispatch_async任务到当前串行队列中。\"></a>dispatch_async任务到当前串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>执行顺序为step0 -&gt; step2 -&gt; step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。<br>执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。</p>\n<h3 id=\"dispatch-async任务到其他并发队列中。\"><a href=\"#dispatch-async任务到其他并发队列中。\" class=\"headerlink\" title=\"dispatch_async任务到其他并发队列中。\"></a>dispatch_async任务到其他并发队列中。</h3><p>已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。</p>\n<p><strong>总结</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @function dispatch_async</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @abstract</span><br><span class=\"line\"> * Submits a block for asynchronous execution on a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @discussion</span><br><span class=\"line\"> * The dispatch_async() function is the fundamental mechanism for submitting</span><br><span class=\"line\"> * blocks to a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Calls to dispatch_async() always return immediately after the block has</span><br><span class=\"line\"> * been submitted, and never wait for the block to be invoked.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * The target queue determines whether the block will be invoked serially or</span><br><span class=\"line\"> * concurrently with respect to other blocks submitted to that same queue.</span><br><span class=\"line\"> * Serial queues are processed concurrently with respect to each other.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param queue</span><br><span class=\"line\"> * The target dispatch queue to which the block is submitted.</span><br><span class=\"line\"> * The system will hold a reference on the target queue until the block</span><br><span class=\"line\"> * has finished.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param block</span><br><span class=\"line\"> * The block to submit to the target dispatch queue. This function performs</span><br><span class=\"line\"> * Block_copy() and Block_release() on behalf of callers.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#ifdef __BLOCKS__</span><br><span class=\"line\">__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)</span><br><span class=\"line\">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\">void</span><br><span class=\"line\">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dispatch_async()的机制是把blocks任务提交到队列中。</li>\n<li>dispatch_async()会立即返回而不会等待block完成。</li>\n<li>目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。<br><strong>这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1.1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1.1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;     // block1.2</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.2 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1.3</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1.3 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:3];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>block1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；<br>block1.2仍然在当前线程（0x7fbe78419320）中执行；<br>另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程；</p>\n<p>结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系：</p>\n<ul>\n<li>主队列对应着主线程；</li>\n<li>并发队列对应多条线程（非主线程）；</li>\n<li>串行队列对应着一条线程（非主线程）；</li>\n<li>dispatch_sync&amp;dispatch_async：调度对应线程池中的线程；</li>\n</ul>\n<p>接下来继续解读官方API</p>\n<ul>\n<li>系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放）</li>\n<li>参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。</li>\n<li>dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease）</li>\n<li>参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。</li>\n</ul>\n<p>最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">__weak ViewController* weakSelf = self;</span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    weakSelf.view.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">__weak ViewController* weakSelf = self;</span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    weakSelf.view.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。<br>此处迷茫++，还得继续研究啊…</p>\n","site":{"data":{}},"excerpt":"","more":"<p>GCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。</p>\n<h1 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h1><ol>\n<li>代码是顺序执行的。</li>\n<li>queue是FIFO（先进先出）的数据结构。</li>\n<li>线程之间是并行的。</li>\n<li><code>串行队列</code>：任务<code>不能同时进行</code>，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。</li>\n<li><code>并发队列</code>：任务<code>可以同时进行</code>，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。</li>\n<li><code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务（也就是block）放到队列中，同步执行，也就是说在<code>当前线程</code>中执行任务，<code>阻塞当前线程</code>。</li>\n<li><code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务放到队列中，异步执行，也就是说在<code>其他线程</code>中执行任务，<code>不阻塞当前线程</code>。（在下文的推演中，发现其并不总是在<code>其他线程</code>中执行）<br>（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue）</li>\n</ol>\n<h1 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h1><h2 id=\"1-代码是顺序执行的。\"><a href=\"#1-代码是顺序执行的。\" class=\"headerlink\" title=\"1. 代码是顺序执行的。\"></a>1. 代码是顺序执行的。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSLog(@&quot;step0&quot;);</span><br><span class=\"line\">NSLog(@&quot;step1&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-12 22:29:49.002 MyPractice[25215:3752290] step0</span><br><span class=\"line\">2016-08-12 22:29:49.002 MyPractice[25215:3752290] step1</span><br></pre></td></tr></table></figure>\n<p>可以看到确实是顺序执行的（严肃脸）。</p>\n<h2 id=\"2-queue是FIFO（先进先出）的数据结构。\"><a href=\"#2-queue是FIFO（先进先出）的数据结构。\" class=\"headerlink\" title=\"2. queue是FIFO（先进先出）的数据结构。\"></a>2. queue是FIFO（先进先出）的数据结构。</h2><h2 id=\"3-线程之间是并行的。\"><a href=\"#3-线程之间是并行的。\" class=\"headerlink\" title=\"3. 线程之间是并行的。\"></a>3. 线程之间是并行的。</h2><h2 id=\"4-串行队列：任务不能同时进行，这意味着第n-1个任务必须等待0…n个任务全部完成后才会开始。\"><a href=\"#4-串行队列：任务不能同时进行，这意味着第n-1个任务必须等待0…n个任务全部完成后才会开始。\" class=\"headerlink\" title=\"4. 串行队列：任务不能同时进行，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。\"></a>4. <code>串行队列</code>：任务<code>不能同时进行</code>，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。</h2><p>首先来看什么是<code>DISPATCH_QUEUE_SERIAL</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @const DISPATCH_QUEUE_SERIAL</span><br><span class=\"line\"> * @discussion A dispatch queue that invokes blocks serially in FIFO order.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL NULL</span><br></pre></td></tr></table></figure></p>\n<p>该队列以先进先出的顺序串行调用blocks。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到1大类中的三个任务顺序执行。</p>\n<h2 id=\"5-并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n-1个任务也可以开始。\"><a href=\"#5-并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n-1个任务也可以开始。\" class=\"headerlink\" title=\"5. 并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。\"></a>5. <code>并发队列</code>：任务<code>可以同时进行</code>，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - &lt;NSThread: 0x7f9c08f04540&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - &lt;NSThread: 0x7f9c08d0acc0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - &lt;NSThread: 0x7f9c08e0b560&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到1大类中的三个任务同时执行。</p>\n<h2 id=\"6-void-dispatch-sync-dispatch-queue-t-queue-dispatch-block-t-block-：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\"><a href=\"#6-void-dispatch-sync-dispatch-queue-t-queue-dispatch-block-t-block-：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\" class=\"headerlink\" title=\"6. void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\"></a>6. <code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务（也就是block）放到队列中，同步执行，也就是说在<code>当前线程</code>中执行任务，<code>阻塞当前线程</code>。</h2><h3 id=\"dispatch-sync任务到其它串行队列中。\"><a href=\"#dispatch-sync任务到其它串行队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到其它串行队列中。\"></a>dispatch_sync任务到其它串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;    // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>block1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。</p>\n<h3 id=\"dispatch-sync任务到当前串行队列中。\"><a href=\"#dispatch-sync任务到当前串行队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到当前串行队列中。\"></a>dispatch_sync任务到当前串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - &lt;NSThread: 0x7f80d8701fc0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。<br>至此，block0与block1循环等待，死锁。</p>\n<h3 id=\"dispatch-sync任务到其它并发队列中。\"><a href=\"#dispatch-sync任务到其它并发队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到其它并发队列中。\"></a>dispatch_sync任务到其它并发队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>step0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。</p>\n<p><strong>总结</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @function dispatch_sync</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @abstract</span><br><span class=\"line\"> * Submits a block for synchronous execution on a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @discussion</span><br><span class=\"line\"> * Submits a block to a dispatch queue like dispatch_async(), however</span><br><span class=\"line\"> * dispatch_sync() will not return until the block has finished.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Calls to dispatch_sync() targeting the current queue will result</span><br><span class=\"line\"> * in dead-lock. Use of dispatch_sync() is also subject to the same</span><br><span class=\"line\"> * multi-party dead-lock problems that may result from the use of a mutex.</span><br><span class=\"line\"> * Use of dispatch_async() is preferred.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Unlike dispatch_async(), no retain is performed on the target queue. Because</span><br><span class=\"line\"> * calls to this function are synchronous, the dispatch_sync() &quot;borrows&quot; the</span><br><span class=\"line\"> * reference of the caller.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * As an optimization, dispatch_sync() invokes the block on the current</span><br><span class=\"line\"> * thread when possible.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param queue</span><br><span class=\"line\"> * The target dispatch queue to which the block is submitted.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param block</span><br><span class=\"line\"> * The block to be invoked on the target dispatch queue.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#ifdef __BLOCKS__</span><br><span class=\"line\">__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)</span><br><span class=\"line\">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\">void</span><br><span class=\"line\">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dispatch_sync()在block结束前不会返回。</li>\n<li>dispatch_sync()任务到当前队列中会引起死锁。</li>\n<li>系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。</li>\n<li>dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。</li>\n<li>参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。</li>\n<li>参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。</li>\n</ul>\n<h2 id=\"7-void-dispatch-async-dispatch-queue-t-queue-dispatch-block-t-block-：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\"><a href=\"#7-void-dispatch-async-dispatch-queue-t-queue-dispatch-block-t-block-：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\" class=\"headerlink\" title=\"7. void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\"></a>7. <code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务放到队列中，异步执行，也就是说在<code>其他线程</code>中执行任务，<code>不阻塞当前线程</code>。</h2><h3 id=\"dispatch-async任务到其它串行队列中。\"><a href=\"#dispatch-async任务到其它串行队列中。\" class=\"headerlink\" title=\"dispatch_async任务到其它串行队列中。\"></a>dispatch_async任务到其它串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - &lt;NSThread: 0x7fe7196a2f50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>执行顺序为step0 -&gt; step1 -&gt; step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。<br>程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。</p>\n<h3 id=\"dispatch-async任务到当前串行队列中。\"><a href=\"#dispatch-async任务到当前串行队列中。\" class=\"headerlink\" title=\"dispatch_async任务到当前串行队列中。\"></a>dispatch_async任务到当前串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>执行顺序为step0 -&gt; step2 -&gt; step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。<br>执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。</p>\n<h3 id=\"dispatch-async任务到其他并发队列中。\"><a href=\"#dispatch-async任务到其他并发队列中。\" class=\"headerlink\" title=\"dispatch_async任务到其他并发队列中。\"></a>dispatch_async任务到其他并发队列中。</h3><p>已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。</p>\n<p><strong>总结</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @function dispatch_async</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @abstract</span><br><span class=\"line\"> * Submits a block for asynchronous execution on a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @discussion</span><br><span class=\"line\"> * The dispatch_async() function is the fundamental mechanism for submitting</span><br><span class=\"line\"> * blocks to a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Calls to dispatch_async() always return immediately after the block has</span><br><span class=\"line\"> * been submitted, and never wait for the block to be invoked.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * The target queue determines whether the block will be invoked serially or</span><br><span class=\"line\"> * concurrently with respect to other blocks submitted to that same queue.</span><br><span class=\"line\"> * Serial queues are processed concurrently with respect to each other.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param queue</span><br><span class=\"line\"> * The target dispatch queue to which the block is submitted.</span><br><span class=\"line\"> * The system will hold a reference on the target queue until the block</span><br><span class=\"line\"> * has finished.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param block</span><br><span class=\"line\"> * The block to submit to the target dispatch queue. This function performs</span><br><span class=\"line\"> * Block_copy() and Block_release() on behalf of callers.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#ifdef __BLOCKS__</span><br><span class=\"line\">__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)</span><br><span class=\"line\">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\">void</span><br><span class=\"line\">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dispatch_async()的机制是把blocks任务提交到队列中。</li>\n<li>dispatch_async()会立即返回而不会等待block完成。</li>\n<li>目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。<br><strong>这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1.1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1.1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;     // block1.2</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.2 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1.3</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1.3 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:3];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>block1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；<br>block1.2仍然在当前线程（0x7fbe78419320）中执行；<br>另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程；</p>\n<p>结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系：</p>\n<ul>\n<li>主队列对应着主线程；</li>\n<li>并发队列对应多条线程（非主线程）；</li>\n<li>串行队列对应着一条线程（非主线程）；</li>\n<li>dispatch_sync&amp;dispatch_async：调度对应线程池中的线程；</li>\n</ul>\n<p>接下来继续解读官方API</p>\n<ul>\n<li>系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放）</li>\n<li>参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。</li>\n<li>dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease）</li>\n<li>参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。</li>\n</ul>\n<p>最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">__weak ViewController* weakSelf = self;</span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    weakSelf.view.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">__weak ViewController* weakSelf = self;</span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    weakSelf.view.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。<br>此处迷茫++，还得继续研究啊…</p>\n"},{"title":"iOS基础-UIViewController生命周期","date":"2017-01-04T03:44:02.000Z","_content":"\n# UIViewController生命周期\n1. init\n2. loadView\n3. viewDidLoad\n4. viewWillAppear\n5. viewWillLayoutSubviews\n6. viewDidLayoutSubviews\n7. viewDidAppear\n8. viewWillDisappear\n9. viewDidDisappear\n10. dealloc\n\n# UIView layoutSubviews方法触发条件\n[layoutSubviews触发条件](http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called)\n- init does not cause layoutSubviews to be called (duh)\n- addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target\n- view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different\n- scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview\n- rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)\n- Resizing a view will call layoutSubviews on its superview\n\n# 在UIViewController中使用UIView时，layoutSubviews的触发时机\n## 测试代码\n`ViewController.m`\n```\n#import \"ViewController.h\"\n#import \"LKView.h\"\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];\n    [self.view addSubview:view];\n    \n    NSLog(@\"1...\");\n}\n\n- (void)viewWillLayoutSubviews\n{\n    [super viewWillLayoutSubviews];\n    NSLog(@\"3...\");\n}\n\n- (void)viewDidLayoutSubviews\n{\n    [super viewDidLayoutSubviews];\n    NSLog(@\"4...\");\n}\n\n- (void)viewWillAppear:(BOOL)animated\n{\n    [super viewWillAppear:animated];\n    NSLog(@\"2...\");\n}\n\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    NSLog(@\"5...\");\n}\n\n@end\n```\n\n`LKView.m`\n```\n#import \"LKView.h\"\n\n@implementation LKView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self)\n    {\n        UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)];\n        [self addSubview:btn];\n    }\n    return self;\n}\n\n- (void)layoutSubviews\n{\n    NSLog(@\"lay out...\");\n}\n\n@end\n```\n\n## 测试结果\n```\n2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...\n2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...\n2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...\n2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...\n2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...\n2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5...\n```\n\n在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。","source":"_posts/iOS基础-UIViewController生命周期.md","raw":"---\ntitle: iOS基础-UIViewController生命周期\ndate: 2017-01-04 11:44:02\ncategories: iOS基础知识\ntags: \n    - UIViewController\n---\n\n# UIViewController生命周期\n1. init\n2. loadView\n3. viewDidLoad\n4. viewWillAppear\n5. viewWillLayoutSubviews\n6. viewDidLayoutSubviews\n7. viewDidAppear\n8. viewWillDisappear\n9. viewDidDisappear\n10. dealloc\n\n# UIView layoutSubviews方法触发条件\n[layoutSubviews触发条件](http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called)\n- init does not cause layoutSubviews to be called (duh)\n- addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target\n- view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different\n- scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview\n- rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)\n- Resizing a view will call layoutSubviews on its superview\n\n# 在UIViewController中使用UIView时，layoutSubviews的触发时机\n## 测试代码\n`ViewController.m`\n```\n#import \"ViewController.h\"\n#import \"LKView.h\"\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];\n    [self.view addSubview:view];\n    \n    NSLog(@\"1...\");\n}\n\n- (void)viewWillLayoutSubviews\n{\n    [super viewWillLayoutSubviews];\n    NSLog(@\"3...\");\n}\n\n- (void)viewDidLayoutSubviews\n{\n    [super viewDidLayoutSubviews];\n    NSLog(@\"4...\");\n}\n\n- (void)viewWillAppear:(BOOL)animated\n{\n    [super viewWillAppear:animated];\n    NSLog(@\"2...\");\n}\n\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    NSLog(@\"5...\");\n}\n\n@end\n```\n\n`LKView.m`\n```\n#import \"LKView.h\"\n\n@implementation LKView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self)\n    {\n        UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)];\n        [self addSubview:btn];\n    }\n    return self;\n}\n\n- (void)layoutSubviews\n{\n    NSLog(@\"lay out...\");\n}\n\n@end\n```\n\n## 测试结果\n```\n2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...\n2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...\n2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...\n2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...\n2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...\n2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5...\n```\n\n在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。","slug":"iOS基础-UIViewController生命周期","published":1,"updated":"2019-06-12T05:46:14.928Z","_id":"cjwss6z6200085mlwf19llik2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"UIViewController生命周期\"><a href=\"#UIViewController生命周期\" class=\"headerlink\" title=\"UIViewController生命周期\"></a>UIViewController生命周期</h1><ol>\n<li>init</li>\n<li>loadView</li>\n<li>viewDidLoad</li>\n<li>viewWillAppear</li>\n<li>viewWillLayoutSubviews</li>\n<li>viewDidLayoutSubviews</li>\n<li>viewDidAppear</li>\n<li>viewWillDisappear</li>\n<li>viewDidDisappear</li>\n<li>dealloc</li>\n</ol>\n<h1 id=\"UIView-layoutSubviews方法触发条件\"><a href=\"#UIView-layoutSubviews方法触发条件\" class=\"headerlink\" title=\"UIView layoutSubviews方法触发条件\"></a>UIView layoutSubviews方法触发条件</h1><p><a href=\"http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called\" target=\"_blank\" rel=\"noopener\">layoutSubviews触发条件</a></p>\n<ul>\n<li>init does not cause layoutSubviews to be called (duh)</li>\n<li>addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target</li>\n<li>view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different</li>\n<li>scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview</li>\n<li>rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)</li>\n<li>Resizing a view will call layoutSubviews on its superview</li>\n</ul>\n<h1 id=\"在UIViewController中使用UIView时，layoutSubviews的触发时机\"><a href=\"#在UIViewController中使用UIView时，layoutSubviews的触发时机\" class=\"headerlink\" title=\"在UIViewController中使用UIView时，layoutSubviews的触发时机\"></a>在UIViewController中使用UIView时，layoutSubviews的触发时机</h1><h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p><code>ViewController.m</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\">#import &quot;LKView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];</span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;1...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillLayoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewWillLayoutSubviews];</span><br><span class=\"line\">    NSLog(@&quot;3...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLayoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLayoutSubviews];</span><br><span class=\"line\">    NSLog(@&quot;4...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    NSLog(@&quot;2...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidAppear:animated];</span><br><span class=\"line\">    NSLog(@&quot;5...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p><code>LKView.m</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;LKView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation LKView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super initWithFrame:frame];</span><br><span class=\"line\">    if (self)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)];</span><br><span class=\"line\">        [self addSubview:btn];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)layoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;lay out...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...</span><br><span class=\"line\">2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...</span><br><span class=\"line\">2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...</span><br><span class=\"line\">2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...</span><br><span class=\"line\">2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...</span><br><span class=\"line\">2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5...</span><br></pre></td></tr></table></figure>\n<p>在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"UIViewController生命周期\"><a href=\"#UIViewController生命周期\" class=\"headerlink\" title=\"UIViewController生命周期\"></a>UIViewController生命周期</h1><ol>\n<li>init</li>\n<li>loadView</li>\n<li>viewDidLoad</li>\n<li>viewWillAppear</li>\n<li>viewWillLayoutSubviews</li>\n<li>viewDidLayoutSubviews</li>\n<li>viewDidAppear</li>\n<li>viewWillDisappear</li>\n<li>viewDidDisappear</li>\n<li>dealloc</li>\n</ol>\n<h1 id=\"UIView-layoutSubviews方法触发条件\"><a href=\"#UIView-layoutSubviews方法触发条件\" class=\"headerlink\" title=\"UIView layoutSubviews方法触发条件\"></a>UIView layoutSubviews方法触发条件</h1><p><a href=\"http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called\" target=\"_blank\" rel=\"noopener\">layoutSubviews触发条件</a></p>\n<ul>\n<li>init does not cause layoutSubviews to be called (duh)</li>\n<li>addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target</li>\n<li>view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different</li>\n<li>scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview</li>\n<li>rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)</li>\n<li>Resizing a view will call layoutSubviews on its superview</li>\n</ul>\n<h1 id=\"在UIViewController中使用UIView时，layoutSubviews的触发时机\"><a href=\"#在UIViewController中使用UIView时，layoutSubviews的触发时机\" class=\"headerlink\" title=\"在UIViewController中使用UIView时，layoutSubviews的触发时机\"></a>在UIViewController中使用UIView时，layoutSubviews的触发时机</h1><h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p><code>ViewController.m</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\">#import &quot;LKView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];</span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;1...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillLayoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewWillLayoutSubviews];</span><br><span class=\"line\">    NSLog(@&quot;3...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLayoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLayoutSubviews];</span><br><span class=\"line\">    NSLog(@&quot;4...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    NSLog(@&quot;2...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidAppear:animated];</span><br><span class=\"line\">    NSLog(@&quot;5...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p><code>LKView.m</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;LKView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation LKView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super initWithFrame:frame];</span><br><span class=\"line\">    if (self)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)];</span><br><span class=\"line\">        [self addSubview:btn];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)layoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;lay out...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...</span><br><span class=\"line\">2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...</span><br><span class=\"line\">2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...</span><br><span class=\"line\">2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...</span><br><span class=\"line\">2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...</span><br><span class=\"line\">2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5...</span><br></pre></td></tr></table></figure>\n<p>在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。</p>\n"},{"title":"iOS基础-知识面归纳","date":"2019-05-27T08:58:29.000Z","_content":"对这几年来开发中遇到的常见基础知识点做一个总结。\n\n# Block\n参考[iOS-Block的本质](https://www.jianshu.com/p/4e79e9a0dd82)\n[关于Block用copy修饰的原因的一点自己的理解](https://www.jianshu.com/p/bf3798fe3f49)\n## Block本质\nBlock是一种OC对象，内部有isa指针，它封装了函数调用和函数调用环境的OC对象。它会捕获变量的临时值（遇到过一个BUG，Block初始化时捕获了变量值，后续每一次调用时本应该基于最新的值来做业务），若想要在block内部改变外部值，使用__block。\n\n## Block类型\n- __NSGlobalBlock __ （ _NSConcreteGlobalBlock ） 数据区\n- __NSStackBlock __ （ _NSConcreteStackBlock ） 堆区\n- __NSMallocBlock __ （ _NSConcreteMallocBlock ） 栈区\n\n## 如何判断block是哪种类型\n- 没有访问auto变量的block是__NSGlobalBlock __ ，放在数据段\n- 访问了auto变量的block是__NSStackBlock __\n- [__NSStackBlock __ copy]操作就变成了__NSMallocBlock __\n因此\n- __NSGlobalBlock __调用copy操作后，什么也不做\n- __NSStackBlock __ 调用copy操作后，复制效果是：从栈复制到堆；副本存储位置是堆\n- __NSStackBlock __ 调用copy操作后，复制效果是：引用计数增加；副本存储位置是堆\n\n## ARC下Block何时自动复制到堆上\n- block作为函数返回值时\n- 将block赋值给__strong指针时\n- block作为Cocoa API中方法名含有usingBlock的方法参数时\n- block作为GCD API的方法参数时\n\n## 为什么用copy修饰\n栈区Block在MRC下不会像ARC中那样自动copy，因此栈区的Block容易在方法执行完后自动释放导致野指针crash。\n\n## Block的内存泄漏\nBlock最典型的循环引用就是self持有block，block持有self，为了避免循环引用，通常使用__weak或__block的弱引用，在此基础上，还衍生出了weak strong dance，来避免block内部引用对象被释放导致的野指针crash或bug。\n\n# Runtime\n参考[iOS运行时(Runtime)详解+Demo](https://www.jianshu.com/p/adf0d566c887)\n## Runtime本质\nOC是一门由C和汇编语言写的面向对象的动态语言。关键在于理解Class的数据结构定义。\n```\ntypedef struct object_class *Class;\nstruct object_class{\n    Class isa OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n     Class super_class                        OBJC2_UNAVAILABLE;  // 父类\n     const char *name                         OBJC2_UNAVAILABLE;  // 类名\n     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0\n     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识\n     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小\n     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表\n     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表\n     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存\n     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表\n#endif\n}OBJC2_UNAVAILABLE;\n\ntypedef struct objc_object *id;\nstruct objc_object{\n     Class isa OBJC_ISA_AVAILABILITY;\n};\n\ntypedef struct objc_category *Category\nstruct objc_category{\n     char *category_name                         OBJC2_UNAVAILABLE; // 分类名\n     char *class_name                            OBJC2_UNAVAILABLE;  // 分类所属的类名\n     struct objc_method_list *instance_methods   OBJC2_UNAVAILABLE;  // 实例方法列表\n     struct objc_method_list *class_methods      OBJC2_UNAVAILABLE; // 类方法列表\n     struct objc_protocol_list *protocols        OBJC2_UNAVAILABLE; // 分类所实现的协议列表\n}\n```\n\n## isa\nisa是一个指向Class的指针，实例对象的isa指向它的类，他的类的isa指向其元类，元类的isa指向根元类，根元类的isa指向其自身。\n{% asset_img isa.png isa指针 %}\n需要注意NSObject的元类，父类指针指向NSObject，形成一个环。\n\n## SEL和IMP的区别\nSEL的数据结构：`typedef struct objc_selector *SEL；`，它是指向一个方法的指针；\nIMP的定义：`id (*IMP)(id, SEL,...)`，它是一个函数指针，指向方法实现的地址。第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)\n第二个参数：是方法选择器(selector)\n\n## Method\n```\ntypedef struct objc_method *Method\nstruct objc_method{\n    SEL method_name      OBJC2_UNAVAILABLE; // 方法名\n    char *method_types   OBJC2_UNAVAILABLE;\n    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现\n}\n```\nMethod可以理解为方法名和方法实现的map映射，便于我们通过方法指针找到方法实现。OC的消息转发、方法动态绑定、方法交换都是基于这个机制。\n\n## 消息发送 - objc_msgSend()\n参考[Objective-C 消息发送与转发机制原理](http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/)\n1. 检测selector、target。\n2. 从这个类的缓存方法列表里找，是否有执行过这个方法。\n3. 找不到就从方法列表里找。\n4. 找不到就从父类的方法列表里找，直到NSObject。\n5. 找不到进入动态方法解析，类对象+ (BOOL)resolveClassMethod:(SEL)sel和元类对象+ (BOOL)resolveInstanceMethod:(SEL)sel\n6. 找不到进入消息转发，- (id)forwardingTargetForSelector:(SEL)aSelector生成NSInvocation，forwardInvocation:转发。\n\n## load方法和initialize方法的异同\n[Runtime-load和initialize](http://blog.leeouf.com/2019/06/07/Runtime-load和initialize/)\n\n# RunLoop\n参考[iOS底层原理总结-RunLoop](https://www.jianshu.com/p/de752066d0ad)\n## RunLoop本质\n就是一个while循环......源码如下：\n```\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;          /* locked for accessing mode list */\n    __CFPort _wakeUpPort;           // used for CFRunLoopWakeUp \n    Boolean _unused;\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread;\n    uint32_t _winthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    struct _block_item *_blocks_head;\n    struct _block_item *_blocks_tail;\n    CFAbsoluteTime _runTime;\n    CFAbsoluteTime _sleepTime;\n    CFTypeRef _counterpart;\n};\n\ntypedef struct __CFRunLoopMode *CFRunLoopModeRef;\nstruct __CFRunLoopMode {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;  /* must have the run loop locked before locking this */\n    CFStringRef _name;\n    Boolean _stopped;\n    char _padding[3];\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n    CFMutableDictionaryRef _portToV1SourceMap;\n    __CFPortSet _portSet;\n    CFIndex _observerMask;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    dispatch_source_t _timerSource;\n    dispatch_queue_t _queue;\n    Boolean _timerFired; // set to true by the source when a timer has fired\n    Boolean _dispatchTimerArmed;\n#endif\n#if USE_MK_TIMER_TOO\n    mach_port_t _timerPort;\n    Boolean _mkTimerArmed;\n#endif\n#if DEPLOYMENT_TARGET_WINDOWS\n    DWORD _msgQMask;\n    void (*_msgPump)(void);\n#endif\n    uint64_t _timerSoftDeadline; /* TSR */\n    uint64_t _timerHardDeadline; /* TSR */\n};\n```\n\n## RunLoop作用\n- 保证主线程不被销毁（写过那么多hello world应该知道main函数顺序执行完就退出了，很好理解）。\n- 处理用户事件，传感器、通知。\n- 调度CPU资源，让我们在空闲时能干很多事。\n\n## RunLoop流程\n{% asset_img RunLoop.png RunLoop流程 %}\n\n## RunLoop Mode\n- kCFRunLoopDefaultMode：默认模式，主线程是在这个运行模式下运行\n- UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）\n- UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用\n- GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到\n- kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案\n\n## RunLoop几种状态\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n     kCFRunLoopEntry = (1UL << 0),   //   即将进入RunLoop\n     kCFRunLoopBeforeTimers = (1UL << 1), // 即将处理Timer\n     kCFRunLoopBeforeSources = (1UL << 2), // 即将处理Source\n     kCFRunLoopBeforeWaiting = (1UL << 5), //即将进入休眠\n     kCFRunLoopAfterWaiting = (1UL << 6),// 刚从休眠中唤醒\n     kCFRunLoopExit = (1UL << 7),// 即将退出RunLoop\n     kCFRunLoopAllActivities = 0x0FFFFFFFU\n     };\n```\n\n# 内存管理相关\n## ARC\n### ARC的本质\nARC本质上和MRC没有区别，都是依靠引用计数进行管理，只是编译器帮我们做了内存管理的操作。ARC有4种修饰符__strong,__weak,__autoreleasing,__unsafe_unretained。\n\n### 内存泄漏\n内存泄漏最常出现在循环引用，表现为A强引用B，B强引用A的循环，会导致双方的引用计数不可能为0，无法释放，内存无法释放的结果就是app占用内存逐渐扩大，最终被看门狗杀死进程crash。\n\n### 野指针\nCrash中出现频率较高的BAD_ACCESS就是野指针Crash之一，即指针指向的内存已经在别处被回收。通常出现在MRC或者iOS9以前的ARC上，常见的如block（见过最多的就是把block从通知中抛出给别的地方处理，省事的代码容易挖坑）等。调试方式主要依靠XCode的Zoombie Object和Address Sanitizer。\n\n### Autoreleasepool\n参考 [Autoreleasepool](https://www.jianshu.com/p/a2999d7728b4)\n[AutoreleasePool底层实现原理](https://www.jianshu.com/p/50bdd8438857)\n- AutoreleasePool创建是在一个RunLoop事件开始之前(push)\n- AutoreleasePool释放是在一个RunLoop事件即将结束之前(pop)。\n- AutoreleasePool里的Autorelease对象的加入是在RunLoop事件中，AutoreleasePool里的Autorelease对象的释放是在AutoreleasePool释放时。\n\n### MRC怎么写\n像init，copy这些实例方法，是由对象持有者管理内存的，所以在MRC中要主动release，而stringWithFormat之类的类方法则是由类自身去管理。\n\n# UIKit\n## UIView与CALayer\n- UIView基于UIKit，继承于UIResponder，CALayer基于QuartzCore，继承于NSObject。\n- UIView是CALayer的delegate，UIView负责处理事件，CALayer负责绘制。\n- CALayer不需要处理交互事件，所以更轻量。\n\n## frame与bounds\n- frame以父级页面坐标系为基础，bounds是以自身左上角为原点。\n\n## animation\n先看一段代码\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.testView = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 200, 100)];\n    [self.view addSubview:self.testView];\n    [self printFrame];\n    \n    [UIView animateWithDuration:5.0f animations:^{\n        self.testView.transform = CGAffineTransformMakeScale(2, 2);\n    } completion:^(BOOL finished) {\n        NSLog(@\"animate complete\");\n        [self printFrame];\n    }];\n    \n//    NSLog(@\"before change\");\n//    self.testView.frame = CGRectMake(40, 50, 50, 25);\n//    [self printFrame];\n//    NSLog(@\"after change\");\n    \n    self.timer = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(printFrame) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];\n}\n\n- (void)printFrame {\n    NSLog(@\"frame:%@ - bounds:%@\", NSStringFromCGRect(self.testView.frame), NSStringFromCGRect(self.testView.bounds));\n}\n```\n此时的输出是\n```\n2019-05-30 13:20:38.968830+0800 LKTestOC[26445:12812774] frame:{{40, 50}, {200, 100}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:39.970986+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:40.970806+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:41.971040+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:42.970473+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:43.970007+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:43.980835+0800 LKTestOC[26445:12812774] animate complete\n2019-05-30 13:20:43.981103+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n```\n打开注释后的输出是：\n```\n2019-05-30 13:21:57.706688+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {200, 100}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:21:57.707726+0800 LKTestOC[26631:12816453] before change\n2019-05-30 13:21:57.707959+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:21:57.708076+0800 LKTestOC[26631:12816453] after change\n2019-05-30 13:21:58.708456+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:21:59.708621+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:22:00.708491+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:22:01.708489+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:22:02.708597+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:22:02.719551+0800 LKTestOC[26631:12816453] animate complete\n2019-05-30 13:22:02.719705+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n```\n可以看出\n- animate后frame是直接变化的，而在屏幕上的绘制是逐渐变化。\n- bounds可以看成是view在其自身坐标系上的真实大小，frame应该是bounds与transform等叠加之后在父级坐标系中的值。\n- 因为frame是直接变化的，因此在动画开始后改frame是基于这个值直接变化。\n- 涂色后可以看出，在动画开始后改变frame，真实的动画是从(25,12.5)放大到(50,25)的过程。\n\n## 事件响应链\n参考[iOS hitTest](https://blog.csdn.net/qq_18505715/article/details/78411052)\nhitTest方法调用步骤如下：\n1. 首先在当前视图的hitTest方法中调用pointInside方法判断触摸点是否在当前视图内\n2. 若pointInside方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest返回nil，该视图不处理该事件\n3. 若pointInside方法返回YES，说明触摸点在当前视图内，则从最上层的子视图开始（即从subviews数组的末尾向前遍历），遍历当前视图的所有子视图，调用子视图的hitTest方法重复步骤1-3\n4. 直到有子视图的hitTest方法返回非空对象或者全部子视图遍历完毕\n5. 若第一次有子视图的hitTest方法返回非空对象，则当前视图的hitTest方法就返回此对象，处理结束\n6. 若所有子视图的hitTest方法都返回nil，则当前视图的hitTest方法返回当前视图本身，最终由该对象处理触摸事件\n而事件传递的顺序则与hitTest调用顺序相反，如下：\nview -> superView ...- > UIViewController.view -> UIViewController -> UIWindow -> UIApplication -> 事件丢弃\n\n## UITableView调优\n### 系统API\n- Cell复用池\n- 预估高度\n\n### TableViewKit封装\n封装tableview、datasource、delegate等，提供：\n- 二维数组数据源。\n- Cell内部高度计算类方法。\n- 上下拉刷新、左右滑动。\n\n### 内容优化\n- 减少主线程操作，异步加载，如图片。\n- 异步绘制，如YYTextLabel。\n- 减少对象创建，创建好，改变hidden。\n- 减少属性赋值，frame的改变会引发重绘，在android端有一个实践，把Cell拆分成N个小Cell，在直觉上这是违背优化的，但是带来了非常可观的性能优化，我认为当业务到达一定复杂度阈值的时候，将Cell拆分可以减少频繁赋值导致的性能开销。\n- 减少离屏渲染，如masks\\shadow\\corner等，尽量用hidden避免用alpha。\n- 谨慎使用autolayout。\n\n### Layouter\nLayouter与MVVM思想类似，将server端的数据转化为与View绑定的ViewModel（整理上游数据，保证View能用）。一次计算好布局数据后就可以避免在heightForRow和cellForRow-bindData过程中重复计算。再进一步也可以作为下次更新的缓存，用于预估高度、减少白屏时间等。缓存高度最好是在runloop空闲时，参考SDWebImage。\n\n### 性能检测工具\n- profile instruments\n- 代码打点\n\n# 多线程\n## 概念\n多线程就是说可以进行多个任务并发，通常线程数等于物理核心数，在后来有了四核八线程等基于逻辑核心的超线程技术。\n\n## GCD\n参考[iOS 多线程：『GCD』详尽总结](https://www.jianshu.com/p/2d57c72016c6)\nGCD有两个核心概念，队列和任务，重点在理解串行、并发队列；主线程、子线程；同步执行、异步执行。\n除了常见的同步、异步dispatch外，还有dispatch_barrier_async（栅栏）、dispatch_after（延时）、dispatch_once（只执行一次）、dispatch_apply（迭代）、dispatch_group（组）、dispatch_group_notify、dispatch_group_wait、dispatch_group_enter、dispatch_group_leave等。\n\n## dispatch_barrier和dispatch_group的区别\n参考[dispatch_barrier_async和dispatch_barrier_sync的区别和详细解析](https://www.jianshu.com/p/a0ce5e51286d)\ndispatch_barrier_async和sync的区别：\n相同点：\n- 等待在它前面插入队列的任务先执行完\n- 等待他们自己的任务执行完再执行后面的任务\n不同点：\n- dispatch_barrier_sync将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们。\n- dispatch_barrier_async将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务。\n\n## NSOperation\nCCD基于C，NSOperation基于OC，其底层也是通过GCD实现，NSOperation比GCD更抽象，API更丰富，效率较低，在大多数普通业务中更倾向于用GCD。\n\n# 缓存\n## iOS数据持久化方案\n1. 沙盒 - 每个应用程序对应的系统目录\n1.1. plist\n1.2. SQLite FMDatabase\n1.3. NSKeyedArchiver 归档成文件 NSFileManager\n2. CoreData\n\n## iOS缓存\n1. NSCache\n2. NSURLCache\n3. 内存缓存\n\n# 网络\n## TCP和UDP\nTCP有三次握手，可靠传输，UDP是不可靠传输。TCP的滑动窗口是接收方为了流量控制限制的窗口大小，控制发送速度防止自己被淹没。\n\n## Https，SSL\nHttp是无状态的，而Https是加入了SSL层，可进行加密传输、身份认证的网络协议。\n\n## cookie和session\ncookie和session的最大区别就是cookie保存在客户端，session保存在服务端。\n\n# 热更新\n## JSPatch\n参考[JSPatch-实现原理详解](https://github.com/bang590/JSPatch/wiki/JSPatch-实现原理详解)\n通过JSContext来实现JS调用OC方法，通过方法交换替换掉IMP指针。\n\n## RN\n基于JSCore的解析引擎，通过bridge调用native方法，UI基于OEM widgets。\n\n## Flutter\n自己实现了渲染框架，底层skia引擎，Widgets Rendering。通过Platform Method Channels与原生代码通信。\n\n# Protobuf\n解析二进制字节流，有效地压缩数据，数据量体积小，使用Tag - Length - Value编码方式，存储紧凑，空间利用率高。\n## Varint\n编码方式T-V，值越小的数字，使用越少的字节数表示。\n## Zigzag\n将 有符号数 转换成 无符号数，然后再采用Varint编码。\n## 数组\nrepeated字段，编码方式Tag - Length - Value -Value -Value。\n## optional & required\noptional默认值，可删除。\n\n# 散乱知识点\n1. [KVO、Delegate、Notification 区别及相关使用场景](https://www.jianshu.com/p/9215251693f0)，KVO isa-swizzling，根据原类创建中间类，重写方法，然后返回原类的Class\n2. 什么是类簇 —— 类簇是Foundation的一种设计模式，比如NSNumber下的int、double、long。可以很方便的用一个类来管理不同的数据类型。\n","source":"_posts/iOS基础-知识面归纳.md","raw":"---\ntitle: iOS基础-知识面归纳\ndate: 2019-05-27 16:58:29\ncategories: iOS基础知识\ntags:\n    - iOS基础知识\n---\n对这几年来开发中遇到的常见基础知识点做一个总结。\n\n# Block\n参考[iOS-Block的本质](https://www.jianshu.com/p/4e79e9a0dd82)\n[关于Block用copy修饰的原因的一点自己的理解](https://www.jianshu.com/p/bf3798fe3f49)\n## Block本质\nBlock是一种OC对象，内部有isa指针，它封装了函数调用和函数调用环境的OC对象。它会捕获变量的临时值（遇到过一个BUG，Block初始化时捕获了变量值，后续每一次调用时本应该基于最新的值来做业务），若想要在block内部改变外部值，使用__block。\n\n## Block类型\n- __NSGlobalBlock __ （ _NSConcreteGlobalBlock ） 数据区\n- __NSStackBlock __ （ _NSConcreteStackBlock ） 堆区\n- __NSMallocBlock __ （ _NSConcreteMallocBlock ） 栈区\n\n## 如何判断block是哪种类型\n- 没有访问auto变量的block是__NSGlobalBlock __ ，放在数据段\n- 访问了auto变量的block是__NSStackBlock __\n- [__NSStackBlock __ copy]操作就变成了__NSMallocBlock __\n因此\n- __NSGlobalBlock __调用copy操作后，什么也不做\n- __NSStackBlock __ 调用copy操作后，复制效果是：从栈复制到堆；副本存储位置是堆\n- __NSStackBlock __ 调用copy操作后，复制效果是：引用计数增加；副本存储位置是堆\n\n## ARC下Block何时自动复制到堆上\n- block作为函数返回值时\n- 将block赋值给__strong指针时\n- block作为Cocoa API中方法名含有usingBlock的方法参数时\n- block作为GCD API的方法参数时\n\n## 为什么用copy修饰\n栈区Block在MRC下不会像ARC中那样自动copy，因此栈区的Block容易在方法执行完后自动释放导致野指针crash。\n\n## Block的内存泄漏\nBlock最典型的循环引用就是self持有block，block持有self，为了避免循环引用，通常使用__weak或__block的弱引用，在此基础上，还衍生出了weak strong dance，来避免block内部引用对象被释放导致的野指针crash或bug。\n\n# Runtime\n参考[iOS运行时(Runtime)详解+Demo](https://www.jianshu.com/p/adf0d566c887)\n## Runtime本质\nOC是一门由C和汇编语言写的面向对象的动态语言。关键在于理解Class的数据结构定义。\n```\ntypedef struct object_class *Class;\nstruct object_class{\n    Class isa OBJC_ISA_AVAILABILITY;\n#if !__OBJC2__\n     Class super_class                        OBJC2_UNAVAILABLE;  // 父类\n     const char *name                         OBJC2_UNAVAILABLE;  // 类名\n     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0\n     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识\n     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小\n     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表\n     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表\n     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存\n     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表\n#endif\n}OBJC2_UNAVAILABLE;\n\ntypedef struct objc_object *id;\nstruct objc_object{\n     Class isa OBJC_ISA_AVAILABILITY;\n};\n\ntypedef struct objc_category *Category\nstruct objc_category{\n     char *category_name                         OBJC2_UNAVAILABLE; // 分类名\n     char *class_name                            OBJC2_UNAVAILABLE;  // 分类所属的类名\n     struct objc_method_list *instance_methods   OBJC2_UNAVAILABLE;  // 实例方法列表\n     struct objc_method_list *class_methods      OBJC2_UNAVAILABLE; // 类方法列表\n     struct objc_protocol_list *protocols        OBJC2_UNAVAILABLE; // 分类所实现的协议列表\n}\n```\n\n## isa\nisa是一个指向Class的指针，实例对象的isa指向它的类，他的类的isa指向其元类，元类的isa指向根元类，根元类的isa指向其自身。\n{% asset_img isa.png isa指针 %}\n需要注意NSObject的元类，父类指针指向NSObject，形成一个环。\n\n## SEL和IMP的区别\nSEL的数据结构：`typedef struct objc_selector *SEL；`，它是指向一个方法的指针；\nIMP的定义：`id (*IMP)(id, SEL,...)`，它是一个函数指针，指向方法实现的地址。第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)\n第二个参数：是方法选择器(selector)\n\n## Method\n```\ntypedef struct objc_method *Method\nstruct objc_method{\n    SEL method_name      OBJC2_UNAVAILABLE; // 方法名\n    char *method_types   OBJC2_UNAVAILABLE;\n    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现\n}\n```\nMethod可以理解为方法名和方法实现的map映射，便于我们通过方法指针找到方法实现。OC的消息转发、方法动态绑定、方法交换都是基于这个机制。\n\n## 消息发送 - objc_msgSend()\n参考[Objective-C 消息发送与转发机制原理](http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/)\n1. 检测selector、target。\n2. 从这个类的缓存方法列表里找，是否有执行过这个方法。\n3. 找不到就从方法列表里找。\n4. 找不到就从父类的方法列表里找，直到NSObject。\n5. 找不到进入动态方法解析，类对象+ (BOOL)resolveClassMethod:(SEL)sel和元类对象+ (BOOL)resolveInstanceMethod:(SEL)sel\n6. 找不到进入消息转发，- (id)forwardingTargetForSelector:(SEL)aSelector生成NSInvocation，forwardInvocation:转发。\n\n## load方法和initialize方法的异同\n[Runtime-load和initialize](http://blog.leeouf.com/2019/06/07/Runtime-load和initialize/)\n\n# RunLoop\n参考[iOS底层原理总结-RunLoop](https://www.jianshu.com/p/de752066d0ad)\n## RunLoop本质\n就是一个while循环......源码如下：\n```\nstruct __CFRunLoop {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;          /* locked for accessing mode list */\n    __CFPort _wakeUpPort;           // used for CFRunLoopWakeUp \n    Boolean _unused;\n    volatile _per_run_data *_perRunData;              // reset for runs of the run loop\n    pthread_t _pthread;\n    uint32_t _winthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunLoopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    struct _block_item *_blocks_head;\n    struct _block_item *_blocks_tail;\n    CFAbsoluteTime _runTime;\n    CFAbsoluteTime _sleepTime;\n    CFTypeRef _counterpart;\n};\n\ntypedef struct __CFRunLoopMode *CFRunLoopModeRef;\nstruct __CFRunLoopMode {\n    CFRuntimeBase _base;\n    pthread_mutex_t _lock;  /* must have the run loop locked before locking this */\n    CFStringRef _name;\n    Boolean _stopped;\n    char _padding[3];\n    CFMutableSetRef _sources0;\n    CFMutableSetRef _sources1;\n    CFMutableArrayRef _observers;\n    CFMutableArrayRef _timers;\n    CFMutableDictionaryRef _portToV1SourceMap;\n    __CFPortSet _portSet;\n    CFIndex _observerMask;\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n    dispatch_source_t _timerSource;\n    dispatch_queue_t _queue;\n    Boolean _timerFired; // set to true by the source when a timer has fired\n    Boolean _dispatchTimerArmed;\n#endif\n#if USE_MK_TIMER_TOO\n    mach_port_t _timerPort;\n    Boolean _mkTimerArmed;\n#endif\n#if DEPLOYMENT_TARGET_WINDOWS\n    DWORD _msgQMask;\n    void (*_msgPump)(void);\n#endif\n    uint64_t _timerSoftDeadline; /* TSR */\n    uint64_t _timerHardDeadline; /* TSR */\n};\n```\n\n## RunLoop作用\n- 保证主线程不被销毁（写过那么多hello world应该知道main函数顺序执行完就退出了，很好理解）。\n- 处理用户事件，传感器、通知。\n- 调度CPU资源，让我们在空闲时能干很多事。\n\n## RunLoop流程\n{% asset_img RunLoop.png RunLoop流程 %}\n\n## RunLoop Mode\n- kCFRunLoopDefaultMode：默认模式，主线程是在这个运行模式下运行\n- UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）\n- UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用\n- GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到\n- kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案\n\n## RunLoop几种状态\n```\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n     kCFRunLoopEntry = (1UL << 0),   //   即将进入RunLoop\n     kCFRunLoopBeforeTimers = (1UL << 1), // 即将处理Timer\n     kCFRunLoopBeforeSources = (1UL << 2), // 即将处理Source\n     kCFRunLoopBeforeWaiting = (1UL << 5), //即将进入休眠\n     kCFRunLoopAfterWaiting = (1UL << 6),// 刚从休眠中唤醒\n     kCFRunLoopExit = (1UL << 7),// 即将退出RunLoop\n     kCFRunLoopAllActivities = 0x0FFFFFFFU\n     };\n```\n\n# 内存管理相关\n## ARC\n### ARC的本质\nARC本质上和MRC没有区别，都是依靠引用计数进行管理，只是编译器帮我们做了内存管理的操作。ARC有4种修饰符__strong,__weak,__autoreleasing,__unsafe_unretained。\n\n### 内存泄漏\n内存泄漏最常出现在循环引用，表现为A强引用B，B强引用A的循环，会导致双方的引用计数不可能为0，无法释放，内存无法释放的结果就是app占用内存逐渐扩大，最终被看门狗杀死进程crash。\n\n### 野指针\nCrash中出现频率较高的BAD_ACCESS就是野指针Crash之一，即指针指向的内存已经在别处被回收。通常出现在MRC或者iOS9以前的ARC上，常见的如block（见过最多的就是把block从通知中抛出给别的地方处理，省事的代码容易挖坑）等。调试方式主要依靠XCode的Zoombie Object和Address Sanitizer。\n\n### Autoreleasepool\n参考 [Autoreleasepool](https://www.jianshu.com/p/a2999d7728b4)\n[AutoreleasePool底层实现原理](https://www.jianshu.com/p/50bdd8438857)\n- AutoreleasePool创建是在一个RunLoop事件开始之前(push)\n- AutoreleasePool释放是在一个RunLoop事件即将结束之前(pop)。\n- AutoreleasePool里的Autorelease对象的加入是在RunLoop事件中，AutoreleasePool里的Autorelease对象的释放是在AutoreleasePool释放时。\n\n### MRC怎么写\n像init，copy这些实例方法，是由对象持有者管理内存的，所以在MRC中要主动release，而stringWithFormat之类的类方法则是由类自身去管理。\n\n# UIKit\n## UIView与CALayer\n- UIView基于UIKit，继承于UIResponder，CALayer基于QuartzCore，继承于NSObject。\n- UIView是CALayer的delegate，UIView负责处理事件，CALayer负责绘制。\n- CALayer不需要处理交互事件，所以更轻量。\n\n## frame与bounds\n- frame以父级页面坐标系为基础，bounds是以自身左上角为原点。\n\n## animation\n先看一段代码\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    self.testView = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 200, 100)];\n    [self.view addSubview:self.testView];\n    [self printFrame];\n    \n    [UIView animateWithDuration:5.0f animations:^{\n        self.testView.transform = CGAffineTransformMakeScale(2, 2);\n    } completion:^(BOOL finished) {\n        NSLog(@\"animate complete\");\n        [self printFrame];\n    }];\n    \n//    NSLog(@\"before change\");\n//    self.testView.frame = CGRectMake(40, 50, 50, 25);\n//    [self printFrame];\n//    NSLog(@\"after change\");\n    \n    self.timer = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(printFrame) userInfo:nil repeats:YES];\n    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];\n}\n\n- (void)printFrame {\n    NSLog(@\"frame:%@ - bounds:%@\", NSStringFromCGRect(self.testView.frame), NSStringFromCGRect(self.testView.bounds));\n}\n```\n此时的输出是\n```\n2019-05-30 13:20:38.968830+0800 LKTestOC[26445:12812774] frame:{{40, 50}, {200, 100}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:39.970986+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:40.970806+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:41.971040+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:42.970473+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:43.970007+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:20:43.980835+0800 LKTestOC[26445:12812774] animate complete\n2019-05-30 13:20:43.981103+0800 LKTestOC[26445:12812774] frame:{{-60, 0}, {400, 200}} - bounds:{{0, 0}, {200, 100}}\n```\n打开注释后的输出是：\n```\n2019-05-30 13:21:57.706688+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {200, 100}} - bounds:{{0, 0}, {200, 100}}\n2019-05-30 13:21:57.707726+0800 LKTestOC[26631:12816453] before change\n2019-05-30 13:21:57.707959+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:21:57.708076+0800 LKTestOC[26631:12816453] after change\n2019-05-30 13:21:58.708456+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:21:59.708621+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:22:00.708491+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:22:01.708489+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:22:02.708597+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n2019-05-30 13:22:02.719551+0800 LKTestOC[26631:12816453] animate complete\n2019-05-30 13:22:02.719705+0800 LKTestOC[26631:12816453] frame:{{40, 50}, {50, 25}} - bounds:{{0, 0}, {25, 12.5}}\n```\n可以看出\n- animate后frame是直接变化的，而在屏幕上的绘制是逐渐变化。\n- bounds可以看成是view在其自身坐标系上的真实大小，frame应该是bounds与transform等叠加之后在父级坐标系中的值。\n- 因为frame是直接变化的，因此在动画开始后改frame是基于这个值直接变化。\n- 涂色后可以看出，在动画开始后改变frame，真实的动画是从(25,12.5)放大到(50,25)的过程。\n\n## 事件响应链\n参考[iOS hitTest](https://blog.csdn.net/qq_18505715/article/details/78411052)\nhitTest方法调用步骤如下：\n1. 首先在当前视图的hitTest方法中调用pointInside方法判断触摸点是否在当前视图内\n2. 若pointInside方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest返回nil，该视图不处理该事件\n3. 若pointInside方法返回YES，说明触摸点在当前视图内，则从最上层的子视图开始（即从subviews数组的末尾向前遍历），遍历当前视图的所有子视图，调用子视图的hitTest方法重复步骤1-3\n4. 直到有子视图的hitTest方法返回非空对象或者全部子视图遍历完毕\n5. 若第一次有子视图的hitTest方法返回非空对象，则当前视图的hitTest方法就返回此对象，处理结束\n6. 若所有子视图的hitTest方法都返回nil，则当前视图的hitTest方法返回当前视图本身，最终由该对象处理触摸事件\n而事件传递的顺序则与hitTest调用顺序相反，如下：\nview -> superView ...- > UIViewController.view -> UIViewController -> UIWindow -> UIApplication -> 事件丢弃\n\n## UITableView调优\n### 系统API\n- Cell复用池\n- 预估高度\n\n### TableViewKit封装\n封装tableview、datasource、delegate等，提供：\n- 二维数组数据源。\n- Cell内部高度计算类方法。\n- 上下拉刷新、左右滑动。\n\n### 内容优化\n- 减少主线程操作，异步加载，如图片。\n- 异步绘制，如YYTextLabel。\n- 减少对象创建，创建好，改变hidden。\n- 减少属性赋值，frame的改变会引发重绘，在android端有一个实践，把Cell拆分成N个小Cell，在直觉上这是违背优化的，但是带来了非常可观的性能优化，我认为当业务到达一定复杂度阈值的时候，将Cell拆分可以减少频繁赋值导致的性能开销。\n- 减少离屏渲染，如masks\\shadow\\corner等，尽量用hidden避免用alpha。\n- 谨慎使用autolayout。\n\n### Layouter\nLayouter与MVVM思想类似，将server端的数据转化为与View绑定的ViewModel（整理上游数据，保证View能用）。一次计算好布局数据后就可以避免在heightForRow和cellForRow-bindData过程中重复计算。再进一步也可以作为下次更新的缓存，用于预估高度、减少白屏时间等。缓存高度最好是在runloop空闲时，参考SDWebImage。\n\n### 性能检测工具\n- profile instruments\n- 代码打点\n\n# 多线程\n## 概念\n多线程就是说可以进行多个任务并发，通常线程数等于物理核心数，在后来有了四核八线程等基于逻辑核心的超线程技术。\n\n## GCD\n参考[iOS 多线程：『GCD』详尽总结](https://www.jianshu.com/p/2d57c72016c6)\nGCD有两个核心概念，队列和任务，重点在理解串行、并发队列；主线程、子线程；同步执行、异步执行。\n除了常见的同步、异步dispatch外，还有dispatch_barrier_async（栅栏）、dispatch_after（延时）、dispatch_once（只执行一次）、dispatch_apply（迭代）、dispatch_group（组）、dispatch_group_notify、dispatch_group_wait、dispatch_group_enter、dispatch_group_leave等。\n\n## dispatch_barrier和dispatch_group的区别\n参考[dispatch_barrier_async和dispatch_barrier_sync的区别和详细解析](https://www.jianshu.com/p/a0ce5e51286d)\ndispatch_barrier_async和sync的区别：\n相同点：\n- 等待在它前面插入队列的任务先执行完\n- 等待他们自己的任务执行完再执行后面的任务\n不同点：\n- dispatch_barrier_sync将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们。\n- dispatch_barrier_async将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务。\n\n## NSOperation\nCCD基于C，NSOperation基于OC，其底层也是通过GCD实现，NSOperation比GCD更抽象，API更丰富，效率较低，在大多数普通业务中更倾向于用GCD。\n\n# 缓存\n## iOS数据持久化方案\n1. 沙盒 - 每个应用程序对应的系统目录\n1.1. plist\n1.2. SQLite FMDatabase\n1.3. NSKeyedArchiver 归档成文件 NSFileManager\n2. CoreData\n\n## iOS缓存\n1. NSCache\n2. NSURLCache\n3. 内存缓存\n\n# 网络\n## TCP和UDP\nTCP有三次握手，可靠传输，UDP是不可靠传输。TCP的滑动窗口是接收方为了流量控制限制的窗口大小，控制发送速度防止自己被淹没。\n\n## Https，SSL\nHttp是无状态的，而Https是加入了SSL层，可进行加密传输、身份认证的网络协议。\n\n## cookie和session\ncookie和session的最大区别就是cookie保存在客户端，session保存在服务端。\n\n# 热更新\n## JSPatch\n参考[JSPatch-实现原理详解](https://github.com/bang590/JSPatch/wiki/JSPatch-实现原理详解)\n通过JSContext来实现JS调用OC方法，通过方法交换替换掉IMP指针。\n\n## RN\n基于JSCore的解析引擎，通过bridge调用native方法，UI基于OEM widgets。\n\n## Flutter\n自己实现了渲染框架，底层skia引擎，Widgets Rendering。通过Platform Method Channels与原生代码通信。\n\n# Protobuf\n解析二进制字节流，有效地压缩数据，数据量体积小，使用Tag - Length - Value编码方式，存储紧凑，空间利用率高。\n## Varint\n编码方式T-V，值越小的数字，使用越少的字节数表示。\n## Zigzag\n将 有符号数 转换成 无符号数，然后再采用Varint编码。\n## 数组\nrepeated字段，编码方式Tag - Length - Value -Value -Value。\n## optional & required\noptional默认值，可删除。\n\n# 散乱知识点\n1. [KVO、Delegate、Notification 区别及相关使用场景](https://www.jianshu.com/p/9215251693f0)，KVO isa-swizzling，根据原类创建中间类，重写方法，然后返回原类的Class\n2. 什么是类簇 —— 类簇是Foundation的一种设计模式，比如NSNumber下的int、double、long。可以很方便的用一个类来管理不同的数据类型。\n","slug":"iOS基础-知识面归纳","published":1,"updated":"2019-06-12T05:07:00.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwss6z63000b5mlw3hjaiovq","content":"<p>对这几年来开发中遇到的常见基础知识点做一个总结。</p>\n<h1 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h1><p>参考<a href=\"https://www.jianshu.com/p/4e79e9a0dd82\" target=\"_blank\" rel=\"noopener\">iOS-Block的本质</a><br><a href=\"https://www.jianshu.com/p/bf3798fe3f49\" target=\"_blank\" rel=\"noopener\">关于Block用copy修饰的原因的一点自己的理解</a></p>\n<h2 id=\"Block本质\"><a href=\"#Block本质\" class=\"headerlink\" title=\"Block本质\"></a>Block本质</h2><p>Block是一种OC对象，内部有isa指针，它封装了函数调用和函数调用环境的OC对象。它会捕获变量的临时值（遇到过一个BUG，Block初始化时捕获了变量值，后续每一次调用时本应该基于最新的值来做业务），若想要在block内部改变外部值，使用__block。</p>\n<h2 id=\"Block类型\"><a href=\"#Block类型\" class=\"headerlink\" title=\"Block类型\"></a>Block类型</h2><ul>\n<li><strong>NSGlobalBlock </strong> （ _NSConcreteGlobalBlock ） 数据区</li>\n<li><strong>NSStackBlock </strong> （ _NSConcreteStackBlock ） 堆区</li>\n<li><strong>NSMallocBlock </strong> （ _NSConcreteMallocBlock ） 栈区</li>\n</ul>\n<h2 id=\"如何判断block是哪种类型\"><a href=\"#如何判断block是哪种类型\" class=\"headerlink\" title=\"如何判断block是哪种类型\"></a>如何判断block是哪种类型</h2><ul>\n<li>没有访问auto变量的block是<strong>NSGlobalBlock </strong> ，放在数据段</li>\n<li>访问了auto变量的block是<strong>NSStackBlock </strong></li>\n<li>[<strong>NSStackBlock </strong> copy]操作就变成了<strong>NSMallocBlock </strong><br>因此</li>\n<li><strong>NSGlobalBlock </strong>调用copy操作后，什么也不做</li>\n<li><strong>NSStackBlock </strong> 调用copy操作后，复制效果是：从栈复制到堆；副本存储位置是堆</li>\n<li><strong>NSStackBlock </strong> 调用copy操作后，复制效果是：引用计数增加；副本存储位置是堆</li>\n</ul>\n<h2 id=\"ARC下Block何时自动复制到堆上\"><a href=\"#ARC下Block何时自动复制到堆上\" class=\"headerlink\" title=\"ARC下Block何时自动复制到堆上\"></a>ARC下Block何时自动复制到堆上</h2><ul>\n<li>block作为函数返回值时</li>\n<li>将block赋值给__strong指针时</li>\n<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>\n<li>block作为GCD API的方法参数时</li>\n</ul>\n<h2 id=\"为什么用copy修饰\"><a href=\"#为什么用copy修饰\" class=\"headerlink\" title=\"为什么用copy修饰\"></a>为什么用copy修饰</h2><p>栈区Block在MRC下不会像ARC中那样自动copy，因此栈区的Block容易在方法执行完后自动释放导致野指针crash。</p>\n<h2 id=\"Block的内存泄漏\"><a href=\"#Block的内存泄漏\" class=\"headerlink\" title=\"Block的内存泄漏\"></a>Block的内存泄漏</h2><p>Block最典型的循环引用就是self持有block，block持有self，为了避免循环引用，通常使用<strong>weak或</strong>block的弱引用，在此基础上，还衍生出了weak strong dance，来避免block内部引用对象被释放导致的野指针crash或bug。</p>\n<h1 id=\"Runtime\"><a href=\"#Runtime\" class=\"headerlink\" title=\"Runtime\"></a>Runtime</h1><p>参考<a href=\"https://www.jianshu.com/p/adf0d566c887\" target=\"_blank\" rel=\"noopener\">iOS运行时(Runtime)详解+Demo</a></p>\n<h2 id=\"Runtime本质\"><a href=\"#Runtime本质\" class=\"headerlink\" title=\"Runtime本质\"></a>Runtime本质</h2><p>OC是一门由C和汇编语言写的面向对象的动态语言。关键在于理解Class的数据结构定义。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct object_class *Class;</span><br><span class=\"line\">struct object_class&#123;</span><br><span class=\"line\">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">#if !__OBJC2__</span><br><span class=\"line\">     Class super_class                        OBJC2_UNAVAILABLE;  // 父类</span><br><span class=\"line\">     const char *name                         OBJC2_UNAVAILABLE;  // 类名</span><br><span class=\"line\">     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class=\"line\">     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class=\"line\">     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class=\"line\">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class=\"line\">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class=\"line\">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class=\"line\">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_object *id;</span><br><span class=\"line\">struct objc_object&#123;</span><br><span class=\"line\">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_category *Category</span><br><span class=\"line\">struct objc_category&#123;</span><br><span class=\"line\">     char *category_name                         OBJC2_UNAVAILABLE; // 分类名</span><br><span class=\"line\">     char *class_name                            OBJC2_UNAVAILABLE;  // 分类所属的类名</span><br><span class=\"line\">     struct objc_method_list *instance_methods   OBJC2_UNAVAILABLE;  // 实例方法列表</span><br><span class=\"line\">     struct objc_method_list *class_methods      OBJC2_UNAVAILABLE; // 类方法列表</span><br><span class=\"line\">     struct objc_protocol_list *protocols        OBJC2_UNAVAILABLE; // 分类所实现的协议列表</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"isa\"><a href=\"#isa\" class=\"headerlink\" title=\"isa\"></a>isa</h2><p>isa是一个指向Class的指针，实例对象的isa指向它的类，他的类的isa指向其元类，元类的isa指向根元类，根元类的isa指向其自身。<br><br>需要注意NSObject的元类，父类指针指向NSObject，形成一个环。</p>\n<h2 id=\"SEL和IMP的区别\"><a href=\"#SEL和IMP的区别\" class=\"headerlink\" title=\"SEL和IMP的区别\"></a>SEL和IMP的区别</h2><p>SEL的数据结构：<code>typedef struct objc_selector *SEL；</code>，它是指向一个方法的指针；<br>IMP的定义：<code>id (*IMP)(id, SEL,...)</code>，它是一个函数指针，指向方法实现的地址。第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)<br>第二个参数：是方法选择器(selector)</p>\n<h2 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct objc_method *Method</span><br><span class=\"line\">struct objc_method&#123;</span><br><span class=\"line\">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class=\"line\">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Method可以理解为方法名和方法实现的map映射，便于我们通过方法指针找到方法实现。OC的消息转发、方法动态绑定、方法交换都是基于这个机制。</p>\n<h2 id=\"消息发送-objc-msgSend\"><a href=\"#消息发送-objc-msgSend\" class=\"headerlink\" title=\"消息发送 - objc_msgSend()\"></a>消息发送 - objc_msgSend()</h2><p>参考<a href=\"http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/\" target=\"_blank\" rel=\"noopener\">Objective-C 消息发送与转发机制原理</a></p>\n<ol>\n<li>检测selector、target。</li>\n<li>从这个类的缓存方法列表里找，是否有执行过这个方法。</li>\n<li>找不到就从方法列表里找。</li>\n<li>找不到就从父类的方法列表里找，直到NSObject。</li>\n<li>找不到进入动态方法解析，类对象+ (BOOL)resolveClassMethod:(SEL)sel和元类对象+ (BOOL)resolveInstanceMethod:(SEL)sel</li>\n<li>找不到进入消息转发，- (id)forwardingTargetForSelector:(SEL)aSelector生成NSInvocation，forwardInvocation:转发。</li>\n</ol>\n<h2 id=\"load方法和initialize方法的异同\"><a href=\"#load方法和initialize方法的异同\" class=\"headerlink\" title=\"load方法和initialize方法的异同\"></a>load方法和initialize方法的异同</h2><p><a href=\"http://blog.leeouf.com/2019/06/07/Runtime-load和initialize/\" target=\"_blank\" rel=\"noopener\">Runtime-load和initialize</a></p>\n<h1 id=\"RunLoop\"><a href=\"#RunLoop\" class=\"headerlink\" title=\"RunLoop\"></a>RunLoop</h1><p>参考<a href=\"https://www.jianshu.com/p/de752066d0ad\" target=\"_blank\" rel=\"noopener\">iOS底层原理总结-RunLoop</a></p>\n<h2 id=\"RunLoop本质\"><a href=\"#RunLoop本质\" class=\"headerlink\" title=\"RunLoop本质\"></a>RunLoop本质</h2><p>就是一个while循环……源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __CFRunLoop &#123;</span><br><span class=\"line\">    CFRuntimeBase _base;</span><br><span class=\"line\">    pthread_mutex_t _lock;          /* locked for accessing mode list */</span><br><span class=\"line\">    __CFPort _wakeUpPort;           // used for CFRunLoopWakeUp </span><br><span class=\"line\">    Boolean _unused;</span><br><span class=\"line\">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class=\"line\">    pthread_t _pthread;</span><br><span class=\"line\">    uint32_t _winthread;</span><br><span class=\"line\">    CFMutableSetRef _commonModes;</span><br><span class=\"line\">    CFMutableSetRef _commonModeItems;</span><br><span class=\"line\">    CFRunLoopModeRef _currentMode;</span><br><span class=\"line\">    CFMutableSetRef _modes;</span><br><span class=\"line\">    struct _block_item *_blocks_head;</span><br><span class=\"line\">    struct _block_item *_blocks_tail;</span><br><span class=\"line\">    CFAbsoluteTime _runTime;</span><br><span class=\"line\">    CFAbsoluteTime _sleepTime;</span><br><span class=\"line\">    CFTypeRef _counterpart;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class=\"line\">struct __CFRunLoopMode &#123;</span><br><span class=\"line\">    CFRuntimeBase _base;</span><br><span class=\"line\">    pthread_mutex_t _lock;  /* must have the run loop locked before locking this */</span><br><span class=\"line\">    CFStringRef _name;</span><br><span class=\"line\">    Boolean _stopped;</span><br><span class=\"line\">    char _padding[3];</span><br><span class=\"line\">    CFMutableSetRef _sources0;</span><br><span class=\"line\">    CFMutableSetRef _sources1;</span><br><span class=\"line\">    CFMutableArrayRef _observers;</span><br><span class=\"line\">    CFMutableArrayRef _timers;</span><br><span class=\"line\">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class=\"line\">    __CFPortSet _portSet;</span><br><span class=\"line\">    CFIndex _observerMask;</span><br><span class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class=\"line\">    dispatch_source_t _timerSource;</span><br><span class=\"line\">    dispatch_queue_t _queue;</span><br><span class=\"line\">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class=\"line\">    Boolean _dispatchTimerArmed;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#if USE_MK_TIMER_TOO</span><br><span class=\"line\">    mach_port_t _timerPort;</span><br><span class=\"line\">    Boolean _mkTimerArmed;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class=\"line\">    DWORD _msgQMask;</span><br><span class=\"line\">    void (*_msgPump)(void);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class=\"line\">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"RunLoop作用\"><a href=\"#RunLoop作用\" class=\"headerlink\" title=\"RunLoop作用\"></a>RunLoop作用</h2><ul>\n<li>保证主线程不被销毁（写过那么多hello world应该知道main函数顺序执行完就退出了，很好理解）。</li>\n<li>处理用户事件，传感器、通知。</li>\n<li>调度CPU资源，让我们在空闲时能干很多事。</li>\n</ul>\n<h2 id=\"RunLoop流程\"><a href=\"#RunLoop流程\" class=\"headerlink\" title=\"RunLoop流程\"></a>RunLoop流程</h2>\n<h2 id=\"RunLoop-Mode\"><a href=\"#RunLoop-Mode\" class=\"headerlink\" title=\"RunLoop Mode\"></a>RunLoop Mode</h2><ul>\n<li>kCFRunLoopDefaultMode：默认模式，主线程是在这个运行模式下运行</li>\n<li>UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>\n<li>UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li>\n<li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li>\n<li>kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案</li>\n</ul>\n<h2 id=\"RunLoop几种状态\"><a href=\"#RunLoop几种状态\" class=\"headerlink\" title=\"RunLoop几种状态\"></a>RunLoop几种状态</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">     kCFRunLoopEntry = (1UL &lt;&lt; 0),   //   即将进入RunLoop</span><br><span class=\"line\">     kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer</span><br><span class=\"line\">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source</span><br><span class=\"line\">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠</span><br><span class=\"line\">     kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒</span><br><span class=\"line\">     kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop</span><br><span class=\"line\">     kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class=\"line\">     &#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"内存管理相关\"><a href=\"#内存管理相关\" class=\"headerlink\" title=\"内存管理相关\"></a>内存管理相关</h1><h2 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h2><h3 id=\"ARC的本质\"><a href=\"#ARC的本质\" class=\"headerlink\" title=\"ARC的本质\"></a>ARC的本质</h3><p>ARC本质上和MRC没有区别，都是依靠引用计数进行管理，只是编译器帮我们做了内存管理的操作。ARC有4种修饰符<strong>strong,</strong>weak,<strong>autoreleasing,</strong>unsafe_unretained。</p>\n<h3 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h3><p>内存泄漏最常出现在循环引用，表现为A强引用B，B强引用A的循环，会导致双方的引用计数不可能为0，无法释放，内存无法释放的结果就是app占用内存逐渐扩大，最终被看门狗杀死进程crash。</p>\n<h3 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h3><p>Crash中出现频率较高的BAD_ACCESS就是野指针Crash之一，即指针指向的内存已经在别处被回收。通常出现在MRC或者iOS9以前的ARC上，常见的如block（见过最多的就是把block从通知中抛出给别的地方处理，省事的代码容易挖坑）等。调试方式主要依靠XCode的Zoombie Object和Address Sanitizer。</p>\n<h3 id=\"Autoreleasepool\"><a href=\"#Autoreleasepool\" class=\"headerlink\" title=\"Autoreleasepool\"></a>Autoreleasepool</h3><p>参考 <a href=\"https://www.jianshu.com/p/a2999d7728b4\" target=\"_blank\" rel=\"noopener\">Autoreleasepool</a><br><a href=\"https://www.jianshu.com/p/50bdd8438857\" target=\"_blank\" rel=\"noopener\">AutoreleasePool底层实现原理</a></p>\n<ul>\n<li>AutoreleasePool创建是在一个RunLoop事件开始之前(push)</li>\n<li>AutoreleasePool释放是在一个RunLoop事件即将结束之前(pop)。</li>\n<li>AutoreleasePool里的Autorelease对象的加入是在RunLoop事件中，AutoreleasePool里的Autorelease对象的释放是在AutoreleasePool释放时。</li>\n</ul>\n<h3 id=\"MRC怎么写\"><a href=\"#MRC怎么写\" class=\"headerlink\" title=\"MRC怎么写\"></a>MRC怎么写</h3><p>像init，copy这些实例方法，是由对象持有者管理内存的，所以在MRC中要主动release，而stringWithFormat之类的类方法则是由类自身去管理。</p>\n<h1 id=\"UIKit\"><a href=\"#UIKit\" class=\"headerlink\" title=\"UIKit\"></a>UIKit</h1><h2 id=\"UIView与CALayer\"><a href=\"#UIView与CALayer\" class=\"headerlink\" title=\"UIView与CALayer\"></a>UIView与CALayer</h2><ul>\n<li>UIView基于UIKit，继承于UIResponder，CALayer基于QuartzCore，继承于NSObject。</li>\n<li>UIView是CALayer的delegate，UIView负责处理事件，CALayer负责绘制。</li>\n<li>CALayer不需要处理交互事件，所以更轻量。</li>\n</ul>\n<h2 id=\"frame与bounds\"><a href=\"#frame与bounds\" class=\"headerlink\" title=\"frame与bounds\"></a>frame与bounds</h2><ul>\n<li>frame以父级页面坐标系为基础，bounds是以自身左上角为原点。</li>\n</ul>\n<h2 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h2><p>先看一段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.testView = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 200, 100)];</span><br><span class=\"line\">    [self.view addSubview:self.testView];</span><br><span class=\"line\">    [self printFrame];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [UIView animateWithDuration:5.0f animations:^&#123;</span><br><span class=\"line\">        self.testView.transform = CGAffineTransformMakeScale(2, 2);</span><br><span class=\"line\">    &#125; completion:^(BOOL finished) &#123;</span><br><span class=\"line\">        NSLog(@&quot;animate complete&quot;);</span><br><span class=\"line\">        [self printFrame];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">//    NSLog(@&quot;before change&quot;);</span><br><span class=\"line\">//    self.testView.frame = CGRectMake(40, 50, 50, 25);</span><br><span class=\"line\">//    [self printFrame];</span><br><span class=\"line\">//    NSLog(@&quot;after change&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.timer = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(printFrame) userInfo:nil repeats:YES];</span><br><span class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)printFrame &#123;</span><br><span class=\"line\">    NSLog(@&quot;frame:%@ - bounds:%@&quot;, NSStringFromCGRect(self.testView.frame), NSStringFromCGRect(self.testView.bounds));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时的输出是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-05-30 13:20:38.968830+0800 LKTestOC[26445:12812774] frame:&#123;&#123;40, 50&#125;, &#123;200, 100&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:39.970986+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:40.970806+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:41.971040+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:42.970473+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:43.970007+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:43.980835+0800 LKTestOC[26445:12812774] animate complete</span><br><span class=\"line\">2019-05-30 13:20:43.981103+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>打开注释后的输出是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-05-30 13:21:57.706688+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;200, 100&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:21:57.707726+0800 LKTestOC[26631:12816453] before change</span><br><span class=\"line\">2019-05-30 13:21:57.707959+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:21:57.708076+0800 LKTestOC[26631:12816453] after change</span><br><span class=\"line\">2019-05-30 13:21:58.708456+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:21:59.708621+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:22:00.708491+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:22:01.708489+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:22:02.708597+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:22:02.719551+0800 LKTestOC[26631:12816453] animate complete</span><br><span class=\"line\">2019-05-30 13:22:02.719705+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出</p>\n<ul>\n<li>animate后frame是直接变化的，而在屏幕上的绘制是逐渐变化。</li>\n<li>bounds可以看成是view在其自身坐标系上的真实大小，frame应该是bounds与transform等叠加之后在父级坐标系中的值。</li>\n<li>因为frame是直接变化的，因此在动画开始后改frame是基于这个值直接变化。</li>\n<li>涂色后可以看出，在动画开始后改变frame，真实的动画是从(25,12.5)放大到(50,25)的过程。</li>\n</ul>\n<h2 id=\"事件响应链\"><a href=\"#事件响应链\" class=\"headerlink\" title=\"事件响应链\"></a>事件响应链</h2><p>参考<a href=\"https://blog.csdn.net/qq_18505715/article/details/78411052\" target=\"_blank\" rel=\"noopener\">iOS hitTest</a><br>hitTest方法调用步骤如下：</p>\n<ol>\n<li>首先在当前视图的hitTest方法中调用pointInside方法判断触摸点是否在当前视图内</li>\n<li>若pointInside方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest返回nil，该视图不处理该事件</li>\n<li>若pointInside方法返回YES，说明触摸点在当前视图内，则从最上层的子视图开始（即从subviews数组的末尾向前遍历），遍历当前视图的所有子视图，调用子视图的hitTest方法重复步骤1-3</li>\n<li>直到有子视图的hitTest方法返回非空对象或者全部子视图遍历完毕</li>\n<li>若第一次有子视图的hitTest方法返回非空对象，则当前视图的hitTest方法就返回此对象，处理结束</li>\n<li>若所有子视图的hitTest方法都返回nil，则当前视图的hitTest方法返回当前视图本身，最终由该对象处理触摸事件<br>而事件传递的顺序则与hitTest调用顺序相反，如下：<br>view -&gt; superView …- &gt; UIViewController.view -&gt; UIViewController -&gt; UIWindow -&gt; UIApplication -&gt; 事件丢弃</li>\n</ol>\n<h2 id=\"UITableView调优\"><a href=\"#UITableView调优\" class=\"headerlink\" title=\"UITableView调优\"></a>UITableView调优</h2><h3 id=\"系统API\"><a href=\"#系统API\" class=\"headerlink\" title=\"系统API\"></a>系统API</h3><ul>\n<li>Cell复用池</li>\n<li>预估高度</li>\n</ul>\n<h3 id=\"TableViewKit封装\"><a href=\"#TableViewKit封装\" class=\"headerlink\" title=\"TableViewKit封装\"></a>TableViewKit封装</h3><p>封装tableview、datasource、delegate等，提供：</p>\n<ul>\n<li>二维数组数据源。</li>\n<li>Cell内部高度计算类方法。</li>\n<li>上下拉刷新、左右滑动。</li>\n</ul>\n<h3 id=\"内容优化\"><a href=\"#内容优化\" class=\"headerlink\" title=\"内容优化\"></a>内容优化</h3><ul>\n<li>减少主线程操作，异步加载，如图片。</li>\n<li>异步绘制，如YYTextLabel。</li>\n<li>减少对象创建，创建好，改变hidden。</li>\n<li>减少属性赋值，frame的改变会引发重绘，在android端有一个实践，把Cell拆分成N个小Cell，在直觉上这是违背优化的，但是带来了非常可观的性能优化，我认为当业务到达一定复杂度阈值的时候，将Cell拆分可以减少频繁赋值导致的性能开销。</li>\n<li>减少离屏渲染，如masks\\shadow\\corner等，尽量用hidden避免用alpha。</li>\n<li>谨慎使用autolayout。</li>\n</ul>\n<h3 id=\"Layouter\"><a href=\"#Layouter\" class=\"headerlink\" title=\"Layouter\"></a>Layouter</h3><p>Layouter与MVVM思想类似，将server端的数据转化为与View绑定的ViewModel（整理上游数据，保证View能用）。一次计算好布局数据后就可以避免在heightForRow和cellForRow-bindData过程中重复计算。再进一步也可以作为下次更新的缓存，用于预估高度、减少白屏时间等。缓存高度最好是在runloop空闲时，参考SDWebImage。</p>\n<h3 id=\"性能检测工具\"><a href=\"#性能检测工具\" class=\"headerlink\" title=\"性能检测工具\"></a>性能检测工具</h3><ul>\n<li>profile instruments</li>\n<li>代码打点</li>\n</ul>\n<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>多线程就是说可以进行多个任务并发，通常线程数等于物理核心数，在后来有了四核八线程等基于逻辑核心的超线程技术。</p>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p>参考<a href=\"https://www.jianshu.com/p/2d57c72016c6\" target=\"_blank\" rel=\"noopener\">iOS 多线程：『GCD』详尽总结</a><br>GCD有两个核心概念，队列和任务，重点在理解串行、并发队列；主线程、子线程；同步执行、异步执行。<br>除了常见的同步、异步dispatch外，还有dispatch_barrier_async（栅栏）、dispatch_after（延时）、dispatch_once（只执行一次）、dispatch_apply（迭代）、dispatch_group（组）、dispatch_group_notify、dispatch_group_wait、dispatch_group_enter、dispatch_group_leave等。</p>\n<h2 id=\"dispatch-barrier和dispatch-group的区别\"><a href=\"#dispatch-barrier和dispatch-group的区别\" class=\"headerlink\" title=\"dispatch_barrier和dispatch_group的区别\"></a>dispatch_barrier和dispatch_group的区别</h2><p>参考<a href=\"https://www.jianshu.com/p/a0ce5e51286d\" target=\"_blank\" rel=\"noopener\">dispatch_barrier_async和dispatch_barrier_sync的区别和详细解析</a><br>dispatch_barrier_async和sync的区别：<br>相同点：</p>\n<ul>\n<li>等待在它前面插入队列的任务先执行完</li>\n<li>等待他们自己的任务执行完再执行后面的任务<br>不同点：</li>\n<li>dispatch_barrier_sync将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们。</li>\n<li>dispatch_barrier_async将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务。</li>\n</ul>\n<h2 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p>CCD基于C，NSOperation基于OC，其底层也是通过GCD实现，NSOperation比GCD更抽象，API更丰富，效率较低，在大多数普通业务中更倾向于用GCD。</p>\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><h2 id=\"iOS数据持久化方案\"><a href=\"#iOS数据持久化方案\" class=\"headerlink\" title=\"iOS数据持久化方案\"></a>iOS数据持久化方案</h2><ol>\n<li>沙盒 - 每个应用程序对应的系统目录<br>1.1. plist<br>1.2. SQLite FMDatabase<br>1.3. NSKeyedArchiver 归档成文件 NSFileManager</li>\n<li>CoreData</li>\n</ol>\n<h2 id=\"iOS缓存\"><a href=\"#iOS缓存\" class=\"headerlink\" title=\"iOS缓存\"></a>iOS缓存</h2><ol>\n<li>NSCache</li>\n<li>NSURLCache</li>\n<li>内存缓存</li>\n</ol>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h2 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h2><p>TCP有三次握手，可靠传输，UDP是不可靠传输。TCP的滑动窗口是接收方为了流量控制限制的窗口大小，控制发送速度防止自己被淹没。</p>\n<h2 id=\"Https，SSL\"><a href=\"#Https，SSL\" class=\"headerlink\" title=\"Https，SSL\"></a>Https，SSL</h2><p>Http是无状态的，而Https是加入了SSL层，可进行加密传输、身份认证的网络协议。</p>\n<h2 id=\"cookie和session\"><a href=\"#cookie和session\" class=\"headerlink\" title=\"cookie和session\"></a>cookie和session</h2><p>cookie和session的最大区别就是cookie保存在客户端，session保存在服务端。</p>\n<h1 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h1><h2 id=\"JSPatch\"><a href=\"#JSPatch\" class=\"headerlink\" title=\"JSPatch\"></a>JSPatch</h2><p>参考<a href=\"https://github.com/bang590/JSPatch/wiki/JSPatch-实现原理详解\" target=\"_blank\" rel=\"noopener\">JSPatch-实现原理详解</a><br>通过JSContext来实现JS调用OC方法，通过方法交换替换掉IMP指针。</p>\n<h2 id=\"RN\"><a href=\"#RN\" class=\"headerlink\" title=\"RN\"></a>RN</h2><p>基于JSCore的解析引擎，通过bridge调用native方法，UI基于OEM widgets。</p>\n<h2 id=\"Flutter\"><a href=\"#Flutter\" class=\"headerlink\" title=\"Flutter\"></a>Flutter</h2><p>自己实现了渲染框架，底层skia引擎，Widgets Rendering。通过Platform Method Channels与原生代码通信。</p>\n<h1 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h1><p>解析二进制字节流，有效地压缩数据，数据量体积小，使用Tag - Length - Value编码方式，存储紧凑，空间利用率高。</p>\n<h2 id=\"Varint\"><a href=\"#Varint\" class=\"headerlink\" title=\"Varint\"></a>Varint</h2><p>编码方式T-V，值越小的数字，使用越少的字节数表示。</p>\n<h2 id=\"Zigzag\"><a href=\"#Zigzag\" class=\"headerlink\" title=\"Zigzag\"></a>Zigzag</h2><p>将 有符号数 转换成 无符号数，然后再采用Varint编码。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>repeated字段，编码方式Tag - Length - Value -Value -Value。</p>\n<h2 id=\"optional-amp-required\"><a href=\"#optional-amp-required\" class=\"headerlink\" title=\"optional &amp; required\"></a>optional &amp; required</h2><p>optional默认值，可删除。</p>\n<h1 id=\"散乱知识点\"><a href=\"#散乱知识点\" class=\"headerlink\" title=\"散乱知识点\"></a>散乱知识点</h1><ol>\n<li><a href=\"https://www.jianshu.com/p/9215251693f0\" target=\"_blank\" rel=\"noopener\">KVO、Delegate、Notification 区别及相关使用场景</a>，KVO isa-swizzling，根据原类创建中间类，重写方法，然后返回原类的Class</li>\n<li>什么是类簇 —— 类簇是Foundation的一种设计模式，比如NSNumber下的int、double、long。可以很方便的用一个类来管理不同的数据类型。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>对这几年来开发中遇到的常见基础知识点做一个总结。</p>\n<h1 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h1><p>参考<a href=\"https://www.jianshu.com/p/4e79e9a0dd82\" target=\"_blank\" rel=\"noopener\">iOS-Block的本质</a><br><a href=\"https://www.jianshu.com/p/bf3798fe3f49\" target=\"_blank\" rel=\"noopener\">关于Block用copy修饰的原因的一点自己的理解</a></p>\n<h2 id=\"Block本质\"><a href=\"#Block本质\" class=\"headerlink\" title=\"Block本质\"></a>Block本质</h2><p>Block是一种OC对象，内部有isa指针，它封装了函数调用和函数调用环境的OC对象。它会捕获变量的临时值（遇到过一个BUG，Block初始化时捕获了变量值，后续每一次调用时本应该基于最新的值来做业务），若想要在block内部改变外部值，使用__block。</p>\n<h2 id=\"Block类型\"><a href=\"#Block类型\" class=\"headerlink\" title=\"Block类型\"></a>Block类型</h2><ul>\n<li><strong>NSGlobalBlock </strong> （ _NSConcreteGlobalBlock ） 数据区</li>\n<li><strong>NSStackBlock </strong> （ _NSConcreteStackBlock ） 堆区</li>\n<li><strong>NSMallocBlock </strong> （ _NSConcreteMallocBlock ） 栈区</li>\n</ul>\n<h2 id=\"如何判断block是哪种类型\"><a href=\"#如何判断block是哪种类型\" class=\"headerlink\" title=\"如何判断block是哪种类型\"></a>如何判断block是哪种类型</h2><ul>\n<li>没有访问auto变量的block是<strong>NSGlobalBlock </strong> ，放在数据段</li>\n<li>访问了auto变量的block是<strong>NSStackBlock </strong></li>\n<li>[<strong>NSStackBlock </strong> copy]操作就变成了<strong>NSMallocBlock </strong><br>因此</li>\n<li><strong>NSGlobalBlock </strong>调用copy操作后，什么也不做</li>\n<li><strong>NSStackBlock </strong> 调用copy操作后，复制效果是：从栈复制到堆；副本存储位置是堆</li>\n<li><strong>NSStackBlock </strong> 调用copy操作后，复制效果是：引用计数增加；副本存储位置是堆</li>\n</ul>\n<h2 id=\"ARC下Block何时自动复制到堆上\"><a href=\"#ARC下Block何时自动复制到堆上\" class=\"headerlink\" title=\"ARC下Block何时自动复制到堆上\"></a>ARC下Block何时自动复制到堆上</h2><ul>\n<li>block作为函数返回值时</li>\n<li>将block赋值给__strong指针时</li>\n<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>\n<li>block作为GCD API的方法参数时</li>\n</ul>\n<h2 id=\"为什么用copy修饰\"><a href=\"#为什么用copy修饰\" class=\"headerlink\" title=\"为什么用copy修饰\"></a>为什么用copy修饰</h2><p>栈区Block在MRC下不会像ARC中那样自动copy，因此栈区的Block容易在方法执行完后自动释放导致野指针crash。</p>\n<h2 id=\"Block的内存泄漏\"><a href=\"#Block的内存泄漏\" class=\"headerlink\" title=\"Block的内存泄漏\"></a>Block的内存泄漏</h2><p>Block最典型的循环引用就是self持有block，block持有self，为了避免循环引用，通常使用<strong>weak或</strong>block的弱引用，在此基础上，还衍生出了weak strong dance，来避免block内部引用对象被释放导致的野指针crash或bug。</p>\n<h1 id=\"Runtime\"><a href=\"#Runtime\" class=\"headerlink\" title=\"Runtime\"></a>Runtime</h1><p>参考<a href=\"https://www.jianshu.com/p/adf0d566c887\" target=\"_blank\" rel=\"noopener\">iOS运行时(Runtime)详解+Demo</a></p>\n<h2 id=\"Runtime本质\"><a href=\"#Runtime本质\" class=\"headerlink\" title=\"Runtime本质\"></a>Runtime本质</h2><p>OC是一门由C和汇编语言写的面向对象的动态语言。关键在于理解Class的数据结构定义。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct object_class *Class;</span><br><span class=\"line\">struct object_class&#123;</span><br><span class=\"line\">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">#if !__OBJC2__</span><br><span class=\"line\">     Class super_class                        OBJC2_UNAVAILABLE;  // 父类</span><br><span class=\"line\">     const char *name                         OBJC2_UNAVAILABLE;  // 类名</span><br><span class=\"line\">     long version                             OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class=\"line\">     long info                                OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class=\"line\">     long instance_size                       OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class=\"line\">     struct objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class=\"line\">     struct objc_method_list *methodLists     OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class=\"line\">     struct objc_cache *cache                 OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class=\"line\">     struct objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;OBJC2_UNAVAILABLE;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_object *id;</span><br><span class=\"line\">struct objc_object&#123;</span><br><span class=\"line\">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_category *Category</span><br><span class=\"line\">struct objc_category&#123;</span><br><span class=\"line\">     char *category_name                         OBJC2_UNAVAILABLE; // 分类名</span><br><span class=\"line\">     char *class_name                            OBJC2_UNAVAILABLE;  // 分类所属的类名</span><br><span class=\"line\">     struct objc_method_list *instance_methods   OBJC2_UNAVAILABLE;  // 实例方法列表</span><br><span class=\"line\">     struct objc_method_list *class_methods      OBJC2_UNAVAILABLE; // 类方法列表</span><br><span class=\"line\">     struct objc_protocol_list *protocols        OBJC2_UNAVAILABLE; // 分类所实现的协议列表</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"isa\"><a href=\"#isa\" class=\"headerlink\" title=\"isa\"></a>isa</h2><p>isa是一个指向Class的指针，实例对象的isa指向它的类，他的类的isa指向其元类，元类的isa指向根元类，根元类的isa指向其自身。<br><br>需要注意NSObject的元类，父类指针指向NSObject，形成一个环。</p>\n<h2 id=\"SEL和IMP的区别\"><a href=\"#SEL和IMP的区别\" class=\"headerlink\" title=\"SEL和IMP的区别\"></a>SEL和IMP的区别</h2><p>SEL的数据结构：<code>typedef struct objc_selector *SEL；</code>，它是指向一个方法的指针；<br>IMP的定义：<code>id (*IMP)(id, SEL,...)</code>，它是一个函数指针，指向方法实现的地址。第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)<br>第二个参数：是方法选择器(selector)</p>\n<h2 id=\"Method\"><a href=\"#Method\" class=\"headerlink\" title=\"Method\"></a>Method</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct objc_method *Method</span><br><span class=\"line\">struct objc_method&#123;</span><br><span class=\"line\">    SEL method_name      OBJC2_UNAVAILABLE; // 方法名</span><br><span class=\"line\">    char *method_types   OBJC2_UNAVAILABLE;</span><br><span class=\"line\">    IMP method_imp       OBJC2_UNAVAILABLE; // 方法实现</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Method可以理解为方法名和方法实现的map映射，便于我们通过方法指针找到方法实现。OC的消息转发、方法动态绑定、方法交换都是基于这个机制。</p>\n<h2 id=\"消息发送-objc-msgSend\"><a href=\"#消息发送-objc-msgSend\" class=\"headerlink\" title=\"消息发送 - objc_msgSend()\"></a>消息发送 - objc_msgSend()</h2><p>参考<a href=\"http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/\" target=\"_blank\" rel=\"noopener\">Objective-C 消息发送与转发机制原理</a></p>\n<ol>\n<li>检测selector、target。</li>\n<li>从这个类的缓存方法列表里找，是否有执行过这个方法。</li>\n<li>找不到就从方法列表里找。</li>\n<li>找不到就从父类的方法列表里找，直到NSObject。</li>\n<li>找不到进入动态方法解析，类对象+ (BOOL)resolveClassMethod:(SEL)sel和元类对象+ (BOOL)resolveInstanceMethod:(SEL)sel</li>\n<li>找不到进入消息转发，- (id)forwardingTargetForSelector:(SEL)aSelector生成NSInvocation，forwardInvocation:转发。</li>\n</ol>\n<h2 id=\"load方法和initialize方法的异同\"><a href=\"#load方法和initialize方法的异同\" class=\"headerlink\" title=\"load方法和initialize方法的异同\"></a>load方法和initialize方法的异同</h2><p><a href=\"http://blog.leeouf.com/2019/06/07/Runtime-load和initialize/\" target=\"_blank\" rel=\"noopener\">Runtime-load和initialize</a></p>\n<h1 id=\"RunLoop\"><a href=\"#RunLoop\" class=\"headerlink\" title=\"RunLoop\"></a>RunLoop</h1><p>参考<a href=\"https://www.jianshu.com/p/de752066d0ad\" target=\"_blank\" rel=\"noopener\">iOS底层原理总结-RunLoop</a></p>\n<h2 id=\"RunLoop本质\"><a href=\"#RunLoop本质\" class=\"headerlink\" title=\"RunLoop本质\"></a>RunLoop本质</h2><p>就是一个while循环……源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __CFRunLoop &#123;</span><br><span class=\"line\">    CFRuntimeBase _base;</span><br><span class=\"line\">    pthread_mutex_t _lock;          /* locked for accessing mode list */</span><br><span class=\"line\">    __CFPort _wakeUpPort;           // used for CFRunLoopWakeUp </span><br><span class=\"line\">    Boolean _unused;</span><br><span class=\"line\">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class=\"line\">    pthread_t _pthread;</span><br><span class=\"line\">    uint32_t _winthread;</span><br><span class=\"line\">    CFMutableSetRef _commonModes;</span><br><span class=\"line\">    CFMutableSetRef _commonModeItems;</span><br><span class=\"line\">    CFRunLoopModeRef _currentMode;</span><br><span class=\"line\">    CFMutableSetRef _modes;</span><br><span class=\"line\">    struct _block_item *_blocks_head;</span><br><span class=\"line\">    struct _block_item *_blocks_tail;</span><br><span class=\"line\">    CFAbsoluteTime _runTime;</span><br><span class=\"line\">    CFAbsoluteTime _sleepTime;</span><br><span class=\"line\">    CFTypeRef _counterpart;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class=\"line\">struct __CFRunLoopMode &#123;</span><br><span class=\"line\">    CFRuntimeBase _base;</span><br><span class=\"line\">    pthread_mutex_t _lock;  /* must have the run loop locked before locking this */</span><br><span class=\"line\">    CFStringRef _name;</span><br><span class=\"line\">    Boolean _stopped;</span><br><span class=\"line\">    char _padding[3];</span><br><span class=\"line\">    CFMutableSetRef _sources0;</span><br><span class=\"line\">    CFMutableSetRef _sources1;</span><br><span class=\"line\">    CFMutableArrayRef _observers;</span><br><span class=\"line\">    CFMutableArrayRef _timers;</span><br><span class=\"line\">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class=\"line\">    __CFPortSet _portSet;</span><br><span class=\"line\">    CFIndex _observerMask;</span><br><span class=\"line\">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class=\"line\">    dispatch_source_t _timerSource;</span><br><span class=\"line\">    dispatch_queue_t _queue;</span><br><span class=\"line\">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class=\"line\">    Boolean _dispatchTimerArmed;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#if USE_MK_TIMER_TOO</span><br><span class=\"line\">    mach_port_t _timerPort;</span><br><span class=\"line\">    Boolean _mkTimerArmed;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class=\"line\">    DWORD _msgQMask;</span><br><span class=\"line\">    void (*_msgPump)(void);</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class=\"line\">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"RunLoop作用\"><a href=\"#RunLoop作用\" class=\"headerlink\" title=\"RunLoop作用\"></a>RunLoop作用</h2><ul>\n<li>保证主线程不被销毁（写过那么多hello world应该知道main函数顺序执行完就退出了，很好理解）。</li>\n<li>处理用户事件，传感器、通知。</li>\n<li>调度CPU资源，让我们在空闲时能干很多事。</li>\n</ul>\n<h2 id=\"RunLoop流程\"><a href=\"#RunLoop流程\" class=\"headerlink\" title=\"RunLoop流程\"></a>RunLoop流程</h2>\n<h2 id=\"RunLoop-Mode\"><a href=\"#RunLoop-Mode\" class=\"headerlink\" title=\"RunLoop Mode\"></a>RunLoop Mode</h2><ul>\n<li>kCFRunLoopDefaultMode：默认模式，主线程是在这个运行模式下运行</li>\n<li>UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>\n<li>UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li>\n<li>GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到</li>\n<li>kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案</li>\n</ul>\n<h2 id=\"RunLoop几种状态\"><a href=\"#RunLoop几种状态\" class=\"headerlink\" title=\"RunLoop几种状态\"></a>RunLoop几种状态</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class=\"line\">     kCFRunLoopEntry = (1UL &lt;&lt; 0),   //   即将进入RunLoop</span><br><span class=\"line\">     kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer</span><br><span class=\"line\">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source</span><br><span class=\"line\">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠</span><br><span class=\"line\">     kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒</span><br><span class=\"line\">     kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop</span><br><span class=\"line\">     kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class=\"line\">     &#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"内存管理相关\"><a href=\"#内存管理相关\" class=\"headerlink\" title=\"内存管理相关\"></a>内存管理相关</h1><h2 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h2><h3 id=\"ARC的本质\"><a href=\"#ARC的本质\" class=\"headerlink\" title=\"ARC的本质\"></a>ARC的本质</h3><p>ARC本质上和MRC没有区别，都是依靠引用计数进行管理，只是编译器帮我们做了内存管理的操作。ARC有4种修饰符<strong>strong,</strong>weak,<strong>autoreleasing,</strong>unsafe_unretained。</p>\n<h3 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h3><p>内存泄漏最常出现在循环引用，表现为A强引用B，B强引用A的循环，会导致双方的引用计数不可能为0，无法释放，内存无法释放的结果就是app占用内存逐渐扩大，最终被看门狗杀死进程crash。</p>\n<h3 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h3><p>Crash中出现频率较高的BAD_ACCESS就是野指针Crash之一，即指针指向的内存已经在别处被回收。通常出现在MRC或者iOS9以前的ARC上，常见的如block（见过最多的就是把block从通知中抛出给别的地方处理，省事的代码容易挖坑）等。调试方式主要依靠XCode的Zoombie Object和Address Sanitizer。</p>\n<h3 id=\"Autoreleasepool\"><a href=\"#Autoreleasepool\" class=\"headerlink\" title=\"Autoreleasepool\"></a>Autoreleasepool</h3><p>参考 <a href=\"https://www.jianshu.com/p/a2999d7728b4\" target=\"_blank\" rel=\"noopener\">Autoreleasepool</a><br><a href=\"https://www.jianshu.com/p/50bdd8438857\" target=\"_blank\" rel=\"noopener\">AutoreleasePool底层实现原理</a></p>\n<ul>\n<li>AutoreleasePool创建是在一个RunLoop事件开始之前(push)</li>\n<li>AutoreleasePool释放是在一个RunLoop事件即将结束之前(pop)。</li>\n<li>AutoreleasePool里的Autorelease对象的加入是在RunLoop事件中，AutoreleasePool里的Autorelease对象的释放是在AutoreleasePool释放时。</li>\n</ul>\n<h3 id=\"MRC怎么写\"><a href=\"#MRC怎么写\" class=\"headerlink\" title=\"MRC怎么写\"></a>MRC怎么写</h3><p>像init，copy这些实例方法，是由对象持有者管理内存的，所以在MRC中要主动release，而stringWithFormat之类的类方法则是由类自身去管理。</p>\n<h1 id=\"UIKit\"><a href=\"#UIKit\" class=\"headerlink\" title=\"UIKit\"></a>UIKit</h1><h2 id=\"UIView与CALayer\"><a href=\"#UIView与CALayer\" class=\"headerlink\" title=\"UIView与CALayer\"></a>UIView与CALayer</h2><ul>\n<li>UIView基于UIKit，继承于UIResponder，CALayer基于QuartzCore，继承于NSObject。</li>\n<li>UIView是CALayer的delegate，UIView负责处理事件，CALayer负责绘制。</li>\n<li>CALayer不需要处理交互事件，所以更轻量。</li>\n</ul>\n<h2 id=\"frame与bounds\"><a href=\"#frame与bounds\" class=\"headerlink\" title=\"frame与bounds\"></a>frame与bounds</h2><ul>\n<li>frame以父级页面坐标系为基础，bounds是以自身左上角为原点。</li>\n</ul>\n<h2 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h2><p>先看一段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.testView = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 200, 100)];</span><br><span class=\"line\">    [self.view addSubview:self.testView];</span><br><span class=\"line\">    [self printFrame];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [UIView animateWithDuration:5.0f animations:^&#123;</span><br><span class=\"line\">        self.testView.transform = CGAffineTransformMakeScale(2, 2);</span><br><span class=\"line\">    &#125; completion:^(BOOL finished) &#123;</span><br><span class=\"line\">        NSLog(@&quot;animate complete&quot;);</span><br><span class=\"line\">        [self printFrame];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">//    NSLog(@&quot;before change&quot;);</span><br><span class=\"line\">//    self.testView.frame = CGRectMake(40, 50, 50, 25);</span><br><span class=\"line\">//    [self printFrame];</span><br><span class=\"line\">//    NSLog(@&quot;after change&quot;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    self.timer = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(printFrame) userInfo:nil repeats:YES];</span><br><span class=\"line\">    [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)printFrame &#123;</span><br><span class=\"line\">    NSLog(@&quot;frame:%@ - bounds:%@&quot;, NSStringFromCGRect(self.testView.frame), NSStringFromCGRect(self.testView.bounds));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时的输出是<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-05-30 13:20:38.968830+0800 LKTestOC[26445:12812774] frame:&#123;&#123;40, 50&#125;, &#123;200, 100&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:39.970986+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:40.970806+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:41.971040+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:42.970473+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:43.970007+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:20:43.980835+0800 LKTestOC[26445:12812774] animate complete</span><br><span class=\"line\">2019-05-30 13:20:43.981103+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>打开注释后的输出是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-05-30 13:21:57.706688+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;200, 100&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:21:57.707726+0800 LKTestOC[26631:12816453] before change</span><br><span class=\"line\">2019-05-30 13:21:57.707959+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:21:57.708076+0800 LKTestOC[26631:12816453] after change</span><br><span class=\"line\">2019-05-30 13:21:58.708456+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:21:59.708621+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:22:00.708491+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:22:01.708489+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:22:02.708597+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br><span class=\"line\">2019-05-30 13:22:02.719551+0800 LKTestOC[26631:12816453] animate complete</span><br><span class=\"line\">2019-05-30 13:22:02.719705+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出</p>\n<ul>\n<li>animate后frame是直接变化的，而在屏幕上的绘制是逐渐变化。</li>\n<li>bounds可以看成是view在其自身坐标系上的真实大小，frame应该是bounds与transform等叠加之后在父级坐标系中的值。</li>\n<li>因为frame是直接变化的，因此在动画开始后改frame是基于这个值直接变化。</li>\n<li>涂色后可以看出，在动画开始后改变frame，真实的动画是从(25,12.5)放大到(50,25)的过程。</li>\n</ul>\n<h2 id=\"事件响应链\"><a href=\"#事件响应链\" class=\"headerlink\" title=\"事件响应链\"></a>事件响应链</h2><p>参考<a href=\"https://blog.csdn.net/qq_18505715/article/details/78411052\" target=\"_blank\" rel=\"noopener\">iOS hitTest</a><br>hitTest方法调用步骤如下：</p>\n<ol>\n<li>首先在当前视图的hitTest方法中调用pointInside方法判断触摸点是否在当前视图内</li>\n<li>若pointInside方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest返回nil，该视图不处理该事件</li>\n<li>若pointInside方法返回YES，说明触摸点在当前视图内，则从最上层的子视图开始（即从subviews数组的末尾向前遍历），遍历当前视图的所有子视图，调用子视图的hitTest方法重复步骤1-3</li>\n<li>直到有子视图的hitTest方法返回非空对象或者全部子视图遍历完毕</li>\n<li>若第一次有子视图的hitTest方法返回非空对象，则当前视图的hitTest方法就返回此对象，处理结束</li>\n<li>若所有子视图的hitTest方法都返回nil，则当前视图的hitTest方法返回当前视图本身，最终由该对象处理触摸事件<br>而事件传递的顺序则与hitTest调用顺序相反，如下：<br>view -&gt; superView …- &gt; UIViewController.view -&gt; UIViewController -&gt; UIWindow -&gt; UIApplication -&gt; 事件丢弃</li>\n</ol>\n<h2 id=\"UITableView调优\"><a href=\"#UITableView调优\" class=\"headerlink\" title=\"UITableView调优\"></a>UITableView调优</h2><h3 id=\"系统API\"><a href=\"#系统API\" class=\"headerlink\" title=\"系统API\"></a>系统API</h3><ul>\n<li>Cell复用池</li>\n<li>预估高度</li>\n</ul>\n<h3 id=\"TableViewKit封装\"><a href=\"#TableViewKit封装\" class=\"headerlink\" title=\"TableViewKit封装\"></a>TableViewKit封装</h3><p>封装tableview、datasource、delegate等，提供：</p>\n<ul>\n<li>二维数组数据源。</li>\n<li>Cell内部高度计算类方法。</li>\n<li>上下拉刷新、左右滑动。</li>\n</ul>\n<h3 id=\"内容优化\"><a href=\"#内容优化\" class=\"headerlink\" title=\"内容优化\"></a>内容优化</h3><ul>\n<li>减少主线程操作，异步加载，如图片。</li>\n<li>异步绘制，如YYTextLabel。</li>\n<li>减少对象创建，创建好，改变hidden。</li>\n<li>减少属性赋值，frame的改变会引发重绘，在android端有一个实践，把Cell拆分成N个小Cell，在直觉上这是违背优化的，但是带来了非常可观的性能优化，我认为当业务到达一定复杂度阈值的时候，将Cell拆分可以减少频繁赋值导致的性能开销。</li>\n<li>减少离屏渲染，如masks\\shadow\\corner等，尽量用hidden避免用alpha。</li>\n<li>谨慎使用autolayout。</li>\n</ul>\n<h3 id=\"Layouter\"><a href=\"#Layouter\" class=\"headerlink\" title=\"Layouter\"></a>Layouter</h3><p>Layouter与MVVM思想类似，将server端的数据转化为与View绑定的ViewModel（整理上游数据，保证View能用）。一次计算好布局数据后就可以避免在heightForRow和cellForRow-bindData过程中重复计算。再进一步也可以作为下次更新的缓存，用于预估高度、减少白屏时间等。缓存高度最好是在runloop空闲时，参考SDWebImage。</p>\n<h3 id=\"性能检测工具\"><a href=\"#性能检测工具\" class=\"headerlink\" title=\"性能检测工具\"></a>性能检测工具</h3><ul>\n<li>profile instruments</li>\n<li>代码打点</li>\n</ul>\n<h1 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>多线程就是说可以进行多个任务并发，通常线程数等于物理核心数，在后来有了四核八线程等基于逻辑核心的超线程技术。</p>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><p>参考<a href=\"https://www.jianshu.com/p/2d57c72016c6\" target=\"_blank\" rel=\"noopener\">iOS 多线程：『GCD』详尽总结</a><br>GCD有两个核心概念，队列和任务，重点在理解串行、并发队列；主线程、子线程；同步执行、异步执行。<br>除了常见的同步、异步dispatch外，还有dispatch_barrier_async（栅栏）、dispatch_after（延时）、dispatch_once（只执行一次）、dispatch_apply（迭代）、dispatch_group（组）、dispatch_group_notify、dispatch_group_wait、dispatch_group_enter、dispatch_group_leave等。</p>\n<h2 id=\"dispatch-barrier和dispatch-group的区别\"><a href=\"#dispatch-barrier和dispatch-group的区别\" class=\"headerlink\" title=\"dispatch_barrier和dispatch_group的区别\"></a>dispatch_barrier和dispatch_group的区别</h2><p>参考<a href=\"https://www.jianshu.com/p/a0ce5e51286d\" target=\"_blank\" rel=\"noopener\">dispatch_barrier_async和dispatch_barrier_sync的区别和详细解析</a><br>dispatch_barrier_async和sync的区别：<br>相同点：</p>\n<ul>\n<li>等待在它前面插入队列的任务先执行完</li>\n<li>等待他们自己的任务执行完再执行后面的任务<br>不同点：</li>\n<li>dispatch_barrier_sync将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们。</li>\n<li>dispatch_barrier_async将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务。</li>\n</ul>\n<h2 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h2><p>CCD基于C，NSOperation基于OC，其底层也是通过GCD实现，NSOperation比GCD更抽象，API更丰富，效率较低，在大多数普通业务中更倾向于用GCD。</p>\n<h1 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h1><h2 id=\"iOS数据持久化方案\"><a href=\"#iOS数据持久化方案\" class=\"headerlink\" title=\"iOS数据持久化方案\"></a>iOS数据持久化方案</h2><ol>\n<li>沙盒 - 每个应用程序对应的系统目录<br>1.1. plist<br>1.2. SQLite FMDatabase<br>1.3. NSKeyedArchiver 归档成文件 NSFileManager</li>\n<li>CoreData</li>\n</ol>\n<h2 id=\"iOS缓存\"><a href=\"#iOS缓存\" class=\"headerlink\" title=\"iOS缓存\"></a>iOS缓存</h2><ol>\n<li>NSCache</li>\n<li>NSURLCache</li>\n<li>内存缓存</li>\n</ol>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h2 id=\"TCP和UDP\"><a href=\"#TCP和UDP\" class=\"headerlink\" title=\"TCP和UDP\"></a>TCP和UDP</h2><p>TCP有三次握手，可靠传输，UDP是不可靠传输。TCP的滑动窗口是接收方为了流量控制限制的窗口大小，控制发送速度防止自己被淹没。</p>\n<h2 id=\"Https，SSL\"><a href=\"#Https，SSL\" class=\"headerlink\" title=\"Https，SSL\"></a>Https，SSL</h2><p>Http是无状态的，而Https是加入了SSL层，可进行加密传输、身份认证的网络协议。</p>\n<h2 id=\"cookie和session\"><a href=\"#cookie和session\" class=\"headerlink\" title=\"cookie和session\"></a>cookie和session</h2><p>cookie和session的最大区别就是cookie保存在客户端，session保存在服务端。</p>\n<h1 id=\"热更新\"><a href=\"#热更新\" class=\"headerlink\" title=\"热更新\"></a>热更新</h1><h2 id=\"JSPatch\"><a href=\"#JSPatch\" class=\"headerlink\" title=\"JSPatch\"></a>JSPatch</h2><p>参考<a href=\"https://github.com/bang590/JSPatch/wiki/JSPatch-实现原理详解\" target=\"_blank\" rel=\"noopener\">JSPatch-实现原理详解</a><br>通过JSContext来实现JS调用OC方法，通过方法交换替换掉IMP指针。</p>\n<h2 id=\"RN\"><a href=\"#RN\" class=\"headerlink\" title=\"RN\"></a>RN</h2><p>基于JSCore的解析引擎，通过bridge调用native方法，UI基于OEM widgets。</p>\n<h2 id=\"Flutter\"><a href=\"#Flutter\" class=\"headerlink\" title=\"Flutter\"></a>Flutter</h2><p>自己实现了渲染框架，底层skia引擎，Widgets Rendering。通过Platform Method Channels与原生代码通信。</p>\n<h1 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h1><p>解析二进制字节流，有效地压缩数据，数据量体积小，使用Tag - Length - Value编码方式，存储紧凑，空间利用率高。</p>\n<h2 id=\"Varint\"><a href=\"#Varint\" class=\"headerlink\" title=\"Varint\"></a>Varint</h2><p>编码方式T-V，值越小的数字，使用越少的字节数表示。</p>\n<h2 id=\"Zigzag\"><a href=\"#Zigzag\" class=\"headerlink\" title=\"Zigzag\"></a>Zigzag</h2><p>将 有符号数 转换成 无符号数，然后再采用Varint编码。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>repeated字段，编码方式Tag - Length - Value -Value -Value。</p>\n<h2 id=\"optional-amp-required\"><a href=\"#optional-amp-required\" class=\"headerlink\" title=\"optional &amp; required\"></a>optional &amp; required</h2><p>optional默认值，可删除。</p>\n<h1 id=\"散乱知识点\"><a href=\"#散乱知识点\" class=\"headerlink\" title=\"散乱知识点\"></a>散乱知识点</h1><ol>\n<li><a href=\"https://www.jianshu.com/p/9215251693f0\" target=\"_blank\" rel=\"noopener\">KVO、Delegate、Notification 区别及相关使用场景</a>，KVO isa-swizzling，根据原类创建中间类，重写方法，然后返回原类的Class</li>\n<li>什么是类簇 —— 类簇是Foundation的一种设计模式，比如NSNumber下的int、double、long。可以很方便的用一个类来管理不同的数据类型。</li>\n</ol>\n"},{"title":"iOS基础-OC基础知识小结","date":"2016-09-17T12:29:17.000Z","_content":"\n# 内存\n\n## 堆栈\n**栈区（stack）**\n由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。\n\n**堆区(heap)**\nheap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。\n\n**全局区（static）**\n全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。\n\n**文字常量区**\n常量字符串就是放在这里的。 程序结束后由系统释放。\n\n**程序代码区**\n存放函数体的二进制代码。\n{% asset_img 内存空间.png 内存空间 %}\n\n## 引用计数\n\n### 4个原则\n- 自己生成的对象，自己持有。\n- 非自己生成的对象，自己也能持有。\n- 不再需要自己持有的对象时释放。\n- 非自己持有的对象无法释放。\n\n### 对象操作\n| 对象操作         | Objective-C方法            |\n| --------------- |:-------------------------:|\n| 生成并持有对象    | alloc/new/copy/mutableCopy|\n| 持有对象         | retain                    |\n| 释放对象         | release                   |\n| 废弃对象         | dealloc                   |\n\n### ARC\nARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。\n\n## 自动释放池\n对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。\n\n- 对象执行autorelease方法时会将对象添加到自动释放池中。\n- 当自动释放池销毁时自动释放池中所有对象作release操作。\n- 对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。\n\n## 属性参数\n- assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。\n- retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。\n- copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。\n- unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。\n- weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。\n- strong: （ARC中默认属性类型）相当于retain。\n\n## 实例\n### 测试1\n```\n#import <Foundation/Foundation.h>\n\n@interface TestARC : NSObject\n@property (nonatomic, strong) NSString *string;\n@property (nonatomic, assign) NSString *stringAssign;\n@property (nonatomic, retain) NSString *stringRetain;\n@property (nonatomic, copy) NSString *stringCopy;\n@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;\n@property (nonatomic, weak) NSString *stringWeak;\n@property (nonatomic, strong) NSString *stringStrong;\n@end\n```\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringAssign = testObj.string;\n        testObj.string = nil;\n    }\n    \n    NSLog(@\"string = %@\", testObj.string);\n    NSLog(@\"stringAssign = %@\", testObj.stringAssign);\n    \n    return 0;\n}\n```\nstringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。\n\n### 测试2\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringWeak = testObj.string;\n//        testObj.stringStrong = testObj.string;\n        testObj.string = nil;\n    }\n    \n    NSLog(@\"string = %@\", testObj.string);\n    NSLog(@\"stringWeak = %@\", testObj.stringWeak);\n    \n    return 0;\n}\n```\n```\n2016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)\n2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null)\n```\n```\n2016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)\n2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1\n```\n强指针指向对象时，内存没有被释放。\n\n### 测试3\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringRetain = testObj.string;\n        testObj.stringCopy = testObj.string;\n        testObj.stringStrong = testObj.string;\n        testObj.string = nil;\n    }\n    \n    return 0;\n}\n```\n```\n(lldb) p testObj.string\n(NSString *) $0 = nil\n(lldb) p testObj.stringRetain\n(__NSCFString *) $1 = 0x00000001005036c0 @\"string1\"\n(lldb) p testObj.stringCopy\n(NSTaggedPointerString *) $2 = 0x31676e6972747375 @\"string1\"\n(lldb) p testObj.stringStrong\n(__NSCFString *) $3 = 0x00000001005036c0 @\"string1\"\n```\n\n# Block\n带有自动变量（局部变量）的匿名函数。形如int (^count)(int) =  ^int (int count){return count+1;}; \n声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。\n赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。\n\n## 类型\n- _NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。\n- _NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。\n- _NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。\n\n## 注意点\n- block会截获外部自动变量的瞬间值。\n- block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。\n- 使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如`__weak typeof(self) weakSelf = self;`新建一个指针的方式解决，在block内部使用__weak类型的对象。\n- block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。\n\n## 实例\n```\n#import <Foundation/Foundation.h>\n\n@interface TestBlock : NSObject\ntypedef NSString *(^testBlockStruct)(NSString *);\n@property (nonatomic, strong) testBlockStruct completionBlock;\n\n- (void)handleBlock:(NSString *)string;\n@end\n```\n```\n#import \"TestBlock.h\"\n\n@implementation TestBlock\n- (void)handleBlock:(NSString *)string {\n    if (self.completionBlock) {\n        NSLog(@\"%@\", self.completionBlock(string));\n    }\n}\n@end\n```\n```\n#import \"TestBlock.h\"\n\nint main(int argc, const char * argv[]) {\n    TestBlock *testBlock = [[TestBlock alloc] init];\n    \n    NSString *tempString = @\"Baidu\";\n    testBlock.completionBlock = ^NSString *(NSString *string){\n        // 使用外部的局部变量tempString\n        NSLog(@\"Block is here with %@ at %@.\", string, tempString);\n        return @\"Block is completed.\";\n    };\n    // 改变局部变量tempString，打印出的block截获了其瞬间值\"Baidu\"\n    tempString = @\"Beijing\";\n    \n    [testBlock handleBlock:@\"LeeOuf\"];\n    return 0;\n}\n```\n```\n2016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeeOuf at Baidu.\n2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed.\n```\n\n# GCD\nGCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。\n\n## Dispatch Queue\n- DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。\n- DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。\n\n获取Dispatch Queue方法: \n- dispatch_get_main_queue()\n- dispatch_get_global_queue()\n- dispatch_queue_create()\n\n## 方法列表\n{% asset_img queue.png queue.h %}\n{% asset_img GCD02.png group.h %}\n{% asset_img GCD03.png once.h %}\n\n# 补充\n1. MRC不能使用weak，使用什么替代？\n2. NSString为什么要使用copy?\n3. block底层forwarding实现\n4. 那些部分不能使用async操作\n5. ARC和MRC下的循环引用\n6. 如何检测VC的循环引用\n7. Category的好处，Category中是否可以加property？\n8. 类别和扩展的区别？为啥要使用扩展\n9. Category中一定添加property，如何实现？\n10. Category中添加和原有类的方法，是否覆盖？  \n-------------------------------- \n1. assign\n2. 因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。\n3. `__Block_byref_val_0`结构体实例有一个成员变量`__forwarding`持有只想该实例自身的指针。\nstatic void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {\n    struct Block_byref **destp = (struct Block_byref **)dest;\n    struct Block_byref *src = (struct Block_byref *)arg;\n    // src points to stack\n    struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);\n    copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)\n    src->forwarding = copy;  // patch stack to point to heap copy\n    copy->size = src->size;\n    // assign byref data block pointer into new Block\n    _Block_assign(src->forwarding, (void **)destp);\n}\n根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。\n4. UI部分。\n5. ARC中可以新建一个__weak修饰符修饰的指针（如__weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用__block修饰（如__block typeof(self) weakSelf = self;）。\n6. \n(1) Product->Profile，查看Leaks，如：\n{% asset_img 调试01.png Leaks %}\n{% asset_img 调试02.png Leaks结果 %}\n\n(2) lldb直接print，查看对象是否为nil。\n7&9. 优点：不使用继承而为现有类添加新方法。\nCategory用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。\n8&10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。\n（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。\n","source":"_posts/iOS基础-OC基础知识小结.md","raw":"---\ntitle: iOS基础-OC基础知识小结\ndate: 2016-09-17 20:29:17\ncategories: iOS基础知识\ntags:\n    - Objective-C\n---\n\n# 内存\n\n## 堆栈\n**栈区（stack）**\n由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。\n\n**堆区(heap)**\nheap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。\n\n**全局区（static）**\n全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。\n\n**文字常量区**\n常量字符串就是放在这里的。 程序结束后由系统释放。\n\n**程序代码区**\n存放函数体的二进制代码。\n{% asset_img 内存空间.png 内存空间 %}\n\n## 引用计数\n\n### 4个原则\n- 自己生成的对象，自己持有。\n- 非自己生成的对象，自己也能持有。\n- 不再需要自己持有的对象时释放。\n- 非自己持有的对象无法释放。\n\n### 对象操作\n| 对象操作         | Objective-C方法            |\n| --------------- |:-------------------------:|\n| 生成并持有对象    | alloc/new/copy/mutableCopy|\n| 持有对象         | retain                    |\n| 释放对象         | release                   |\n| 废弃对象         | dealloc                   |\n\n### ARC\nARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。\n\n## 自动释放池\n对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。\n\n- 对象执行autorelease方法时会将对象添加到自动释放池中。\n- 当自动释放池销毁时自动释放池中所有对象作release操作。\n- 对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。\n\n## 属性参数\n- assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。\n- retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。\n- copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。\n- unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。\n- weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。\n- strong: （ARC中默认属性类型）相当于retain。\n\n## 实例\n### 测试1\n```\n#import <Foundation/Foundation.h>\n\n@interface TestARC : NSObject\n@property (nonatomic, strong) NSString *string;\n@property (nonatomic, assign) NSString *stringAssign;\n@property (nonatomic, retain) NSString *stringRetain;\n@property (nonatomic, copy) NSString *stringCopy;\n@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;\n@property (nonatomic, weak) NSString *stringWeak;\n@property (nonatomic, strong) NSString *stringStrong;\n@end\n```\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringAssign = testObj.string;\n        testObj.string = nil;\n    }\n    \n    NSLog(@\"string = %@\", testObj.string);\n    NSLog(@\"stringAssign = %@\", testObj.stringAssign);\n    \n    return 0;\n}\n```\nstringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。\n\n### 测试2\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringWeak = testObj.string;\n//        testObj.stringStrong = testObj.string;\n        testObj.string = nil;\n    }\n    \n    NSLog(@\"string = %@\", testObj.string);\n    NSLog(@\"stringWeak = %@\", testObj.stringWeak);\n    \n    return 0;\n}\n```\n```\n2016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)\n2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null)\n```\n```\n2016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)\n2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1\n```\n强指针指向对象时，内存没有被释放。\n\n### 测试3\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringRetain = testObj.string;\n        testObj.stringCopy = testObj.string;\n        testObj.stringStrong = testObj.string;\n        testObj.string = nil;\n    }\n    \n    return 0;\n}\n```\n```\n(lldb) p testObj.string\n(NSString *) $0 = nil\n(lldb) p testObj.stringRetain\n(__NSCFString *) $1 = 0x00000001005036c0 @\"string1\"\n(lldb) p testObj.stringCopy\n(NSTaggedPointerString *) $2 = 0x31676e6972747375 @\"string1\"\n(lldb) p testObj.stringStrong\n(__NSCFString *) $3 = 0x00000001005036c0 @\"string1\"\n```\n\n# Block\n带有自动变量（局部变量）的匿名函数。形如int (^count)(int) =  ^int (int count){return count+1;}; \n声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。\n赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。\n\n## 类型\n- _NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。\n- _NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。\n- _NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。\n\n## 注意点\n- block会截获外部自动变量的瞬间值。\n- block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。\n- 使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如`__weak typeof(self) weakSelf = self;`新建一个指针的方式解决，在block内部使用__weak类型的对象。\n- block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。\n\n## 实例\n```\n#import <Foundation/Foundation.h>\n\n@interface TestBlock : NSObject\ntypedef NSString *(^testBlockStruct)(NSString *);\n@property (nonatomic, strong) testBlockStruct completionBlock;\n\n- (void)handleBlock:(NSString *)string;\n@end\n```\n```\n#import \"TestBlock.h\"\n\n@implementation TestBlock\n- (void)handleBlock:(NSString *)string {\n    if (self.completionBlock) {\n        NSLog(@\"%@\", self.completionBlock(string));\n    }\n}\n@end\n```\n```\n#import \"TestBlock.h\"\n\nint main(int argc, const char * argv[]) {\n    TestBlock *testBlock = [[TestBlock alloc] init];\n    \n    NSString *tempString = @\"Baidu\";\n    testBlock.completionBlock = ^NSString *(NSString *string){\n        // 使用外部的局部变量tempString\n        NSLog(@\"Block is here with %@ at %@.\", string, tempString);\n        return @\"Block is completed.\";\n    };\n    // 改变局部变量tempString，打印出的block截获了其瞬间值\"Baidu\"\n    tempString = @\"Beijing\";\n    \n    [testBlock handleBlock:@\"LeeOuf\"];\n    return 0;\n}\n```\n```\n2016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeeOuf at Baidu.\n2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed.\n```\n\n# GCD\nGCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。\n\n## Dispatch Queue\n- DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。\n- DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。\n\n获取Dispatch Queue方法: \n- dispatch_get_main_queue()\n- dispatch_get_global_queue()\n- dispatch_queue_create()\n\n## 方法列表\n{% asset_img queue.png queue.h %}\n{% asset_img GCD02.png group.h %}\n{% asset_img GCD03.png once.h %}\n\n# 补充\n1. MRC不能使用weak，使用什么替代？\n2. NSString为什么要使用copy?\n3. block底层forwarding实现\n4. 那些部分不能使用async操作\n5. ARC和MRC下的循环引用\n6. 如何检测VC的循环引用\n7. Category的好处，Category中是否可以加property？\n8. 类别和扩展的区别？为啥要使用扩展\n9. Category中一定添加property，如何实现？\n10. Category中添加和原有类的方法，是否覆盖？  \n-------------------------------- \n1. assign\n2. 因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。\n3. `__Block_byref_val_0`结构体实例有一个成员变量`__forwarding`持有只想该实例自身的指针。\nstatic void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {\n    struct Block_byref **destp = (struct Block_byref **)dest;\n    struct Block_byref *src = (struct Block_byref *)arg;\n    // src points to stack\n    struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);\n    copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)\n    src->forwarding = copy;  // patch stack to point to heap copy\n    copy->size = src->size;\n    // assign byref data block pointer into new Block\n    _Block_assign(src->forwarding, (void **)destp);\n}\n根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。\n4. UI部分。\n5. ARC中可以新建一个__weak修饰符修饰的指针（如__weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用__block修饰（如__block typeof(self) weakSelf = self;）。\n6. \n(1) Product->Profile，查看Leaks，如：\n{% asset_img 调试01.png Leaks %}\n{% asset_img 调试02.png Leaks结果 %}\n\n(2) lldb直接print，查看对象是否为nil。\n7&9. 优点：不使用继承而为现有类添加新方法。\nCategory用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。\n8&10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。\n（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。\n","slug":"iOS基础-OC基础知识小结","published":1,"updated":"2019-06-12T05:46:08.296Z","_id":"cjwss6z64000e5mlwsay9fpiw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><h2 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h2><p><strong>栈区（stack）</strong><br>由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。</p>\n<p><strong>堆区(heap)</strong><br>heap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。</p>\n<p><strong>全局区（static）</strong><br>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。</p>\n<p><strong>文字常量区</strong><br>常量字符串就是放在这里的。 程序结束后由系统释放。</p>\n<p><strong>程序代码区</strong><br>存放函数体的二进制代码。<br></p>\n<h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><h3 id=\"4个原则\"><a href=\"#4个原则\" class=\"headerlink\" title=\"4个原则\"></a>4个原则</h3><ul>\n<li>自己生成的对象，自己持有。</li>\n<li>非自己生成的对象，自己也能持有。</li>\n<li>不再需要自己持有的对象时释放。</li>\n<li>非自己持有的对象无法释放。</li>\n</ul>\n<h3 id=\"对象操作\"><a href=\"#对象操作\" class=\"headerlink\" title=\"对象操作\"></a>对象操作</h3><table>\n<thead>\n<tr>\n<th>对象操作</th>\n<th style=\"text-align:center\">Objective-C方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生成并持有对象</td>\n<td style=\"text-align:center\">alloc/new/copy/mutableCopy</td>\n</tr>\n<tr>\n<td>持有对象</td>\n<td style=\"text-align:center\">retain</td>\n</tr>\n<tr>\n<td>释放对象</td>\n<td style=\"text-align:center\">release</td>\n</tr>\n<tr>\n<td>废弃对象</td>\n<td style=\"text-align:center\">dealloc</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h3><p>ARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。</p>\n<h2 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h2><p>对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>\n<ul>\n<li>对象执行autorelease方法时会将对象添加到自动释放池中。</li>\n<li>当自动释放池销毁时自动释放池中所有对象作release操作。</li>\n<li>对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。</li>\n</ul>\n<h2 id=\"属性参数\"><a href=\"#属性参数\" class=\"headerlink\" title=\"属性参数\"></a>属性参数</h2><ul>\n<li>assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。</li>\n<li>retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。</li>\n<li>copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。</li>\n<li>unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。</li>\n<li>weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。</li>\n<li>strong: （ARC中默认属性类型）相当于retain。</li>\n</ul>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"测试1\"><a href=\"#测试1\" class=\"headerlink\" title=\"测试1\"></a>测试1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface TestARC : NSObject</span><br><span class=\"line\">@property (nonatomic, strong) NSString *string;</span><br><span class=\"line\">@property (nonatomic, assign) NSString *stringAssign;</span><br><span class=\"line\">@property (nonatomic, retain) NSString *stringRetain;</span><br><span class=\"line\">@property (nonatomic, copy) NSString *stringCopy;</span><br><span class=\"line\">@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;</span><br><span class=\"line\">@property (nonatomic, weak) NSString *stringWeak;</span><br><span class=\"line\">@property (nonatomic, strong) NSString *stringStrong;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringAssign = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string = %@&quot;, testObj.string);</span><br><span class=\"line\">    NSLog(@&quot;stringAssign = %@&quot;, testObj.stringAssign);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>stringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。</p>\n<h3 id=\"测试2\"><a href=\"#测试2\" class=\"headerlink\" title=\"测试2\"></a>测试2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringWeak = testObj.string;</span><br><span class=\"line\">//        testObj.stringStrong = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string = %@&quot;, testObj.string);</span><br><span class=\"line\">    NSLog(@&quot;stringWeak = %@&quot;, testObj.stringWeak);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)</span><br><span class=\"line\">2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)</span><br><span class=\"line\">2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1</span><br></pre></td></tr></table></figure>\n<p>强指针指向对象时，内存没有被释放。</p>\n<h3 id=\"测试3\"><a href=\"#测试3\" class=\"headerlink\" title=\"测试3\"></a>测试3</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringRetain = testObj.string;</span><br><span class=\"line\">        testObj.stringCopy = testObj.string;</span><br><span class=\"line\">        testObj.stringStrong = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p testObj.string</span><br><span class=\"line\">(NSString *) $0 = nil</span><br><span class=\"line\">(lldb) p testObj.stringRetain</span><br><span class=\"line\">(__NSCFString *) $1 = 0x00000001005036c0 @&quot;string1&quot;</span><br><span class=\"line\">(lldb) p testObj.stringCopy</span><br><span class=\"line\">(NSTaggedPointerString *) $2 = 0x31676e6972747375 @&quot;string1&quot;</span><br><span class=\"line\">(lldb) p testObj.stringStrong</span><br><span class=\"line\">(__NSCFString *) $3 = 0x00000001005036c0 @&quot;string1&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h1><p>带有自动变量（局部变量）的匿名函数。形如int (^count)(int) =  ^int (int count){return count+1;};<br>声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。<br>赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><ul>\n<li>_NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。</li>\n<li>_NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。</li>\n<li>_NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。</li>\n</ul>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ul>\n<li>block会截获外部自动变量的瞬间值。</li>\n<li>block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。</li>\n<li>使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如<code>__weak typeof(self) weakSelf = self;</code>新建一个指针的方式解决，在block内部使用__weak类型的对象。</li>\n<li>block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。</li>\n</ul>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface TestBlock : NSObject</span><br><span class=\"line\">typedef NSString *(^testBlockStruct)(NSString *);</span><br><span class=\"line\">@property (nonatomic, strong) testBlockStruct completionBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleBlock:(NSString *)string;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestBlock.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation TestBlock</span><br><span class=\"line\">- (void)handleBlock:(NSString *)string &#123;</span><br><span class=\"line\">    if (self.completionBlock) &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, self.completionBlock(string));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestBlock.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestBlock *testBlock = [[TestBlock alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *tempString = @&quot;Baidu&quot;;</span><br><span class=\"line\">    testBlock.completionBlock = ^NSString *(NSString *string)&#123;</span><br><span class=\"line\">        // 使用外部的局部变量tempString</span><br><span class=\"line\">        NSLog(@&quot;Block is here with %@ at %@.&quot;, string, tempString);</span><br><span class=\"line\">        return @&quot;Block is completed.&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 改变局部变量tempString，打印出的block截获了其瞬间值&quot;Baidu&quot;</span><br><span class=\"line\">    tempString = @&quot;Beijing&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [testBlock handleBlock:@&quot;LeeOuf&quot;];</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeeOuf at Baidu.</span><br><span class=\"line\">2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed.</span><br></pre></td></tr></table></figure>\n<h1 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h1><p>GCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。</p>\n<h2 id=\"Dispatch-Queue\"><a href=\"#Dispatch-Queue\" class=\"headerlink\" title=\"Dispatch Queue\"></a>Dispatch Queue</h2><ul>\n<li>DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。</li>\n<li>DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。</li>\n</ul>\n<p>获取Dispatch Queue方法: </p>\n<ul>\n<li>dispatch_get_main_queue()</li>\n<li>dispatch_get_global_queue()</li>\n<li>dispatch_queue_create()</li>\n</ul>\n<h2 id=\"方法列表\"><a href=\"#方法列表\" class=\"headerlink\" title=\"方法列表\"></a>方法列表</h2>\n\n\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ol>\n<li>MRC不能使用weak，使用什么替代？</li>\n<li>NSString为什么要使用copy?</li>\n<li>block底层forwarding实现</li>\n<li>那些部分不能使用async操作</li>\n<li>ARC和MRC下的循环引用</li>\n<li>如何检测VC的循环引用</li>\n<li>Category的好处，Category中是否可以加property？</li>\n<li>类别和扩展的区别？为啥要使用扩展</li>\n<li>Category中一定添加property，如何实现？</li>\n<li>Category中添加和原有类的方法，是否覆盖？  </li>\n</ol>\n<hr>\n<ol>\n<li>assign</li>\n<li>因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。</li>\n<li><code>__Block_byref_val_0</code>结构体实例有一个成员变量<code>__forwarding</code>持有只想该实例自身的指针。<br>static void _Block_byref_assign_copy(void <em>dest, const void </em>arg, const int flags) {<br> struct Block_byref <strong>destp = (struct Block_byref </strong>)dest;<br> struct Block_byref <em>src = (struct Block_byref </em>)arg;<br> // src points to stack<br> struct Block_byref <em>copy = (struct Block_byref </em>)_Block_allocator(src-&gt;size, false, isWeak);<br> copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)<br> src-&gt;forwarding = copy;  // patch stack to point to heap copy<br> copy-&gt;size = src-&gt;size;<br> // assign byref data block pointer into new Block<br> _Block_assign(src-&gt;forwarding, (void **)destp);<br>}<br>根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。</li>\n<li>UI部分。</li>\n<li>ARC中可以新建一个<strong>weak修饰符修饰的指针（如</strong>weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用<strong>block修饰（如</strong>block typeof(self) weakSelf = self;）。</li>\n<li>(1) Product-&gt;Profile，查看Leaks，如：\n\n</li>\n</ol>\n<p>(2) lldb直接print，查看对象是否为nil。<br>7&amp;9. 优点：不使用继承而为现有类添加新方法。<br>Category用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。<br>8&amp;10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。<br>（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><h2 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h2><p><strong>栈区（stack）</strong><br>由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。</p>\n<p><strong>堆区(heap)</strong><br>heap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。</p>\n<p><strong>全局区（static）</strong><br>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。</p>\n<p><strong>文字常量区</strong><br>常量字符串就是放在这里的。 程序结束后由系统释放。</p>\n<p><strong>程序代码区</strong><br>存放函数体的二进制代码。<br></p>\n<h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><h3 id=\"4个原则\"><a href=\"#4个原则\" class=\"headerlink\" title=\"4个原则\"></a>4个原则</h3><ul>\n<li>自己生成的对象，自己持有。</li>\n<li>非自己生成的对象，自己也能持有。</li>\n<li>不再需要自己持有的对象时释放。</li>\n<li>非自己持有的对象无法释放。</li>\n</ul>\n<h3 id=\"对象操作\"><a href=\"#对象操作\" class=\"headerlink\" title=\"对象操作\"></a>对象操作</h3><table>\n<thead>\n<tr>\n<th>对象操作</th>\n<th style=\"text-align:center\">Objective-C方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生成并持有对象</td>\n<td style=\"text-align:center\">alloc/new/copy/mutableCopy</td>\n</tr>\n<tr>\n<td>持有对象</td>\n<td style=\"text-align:center\">retain</td>\n</tr>\n<tr>\n<td>释放对象</td>\n<td style=\"text-align:center\">release</td>\n</tr>\n<tr>\n<td>废弃对象</td>\n<td style=\"text-align:center\">dealloc</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h3><p>ARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。</p>\n<h2 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h2><p>对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>\n<ul>\n<li>对象执行autorelease方法时会将对象添加到自动释放池中。</li>\n<li>当自动释放池销毁时自动释放池中所有对象作release操作。</li>\n<li>对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。</li>\n</ul>\n<h2 id=\"属性参数\"><a href=\"#属性参数\" class=\"headerlink\" title=\"属性参数\"></a>属性参数</h2><ul>\n<li>assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。</li>\n<li>retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。</li>\n<li>copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。</li>\n<li>unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。</li>\n<li>weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。</li>\n<li>strong: （ARC中默认属性类型）相当于retain。</li>\n</ul>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"测试1\"><a href=\"#测试1\" class=\"headerlink\" title=\"测试1\"></a>测试1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface TestARC : NSObject</span><br><span class=\"line\">@property (nonatomic, strong) NSString *string;</span><br><span class=\"line\">@property (nonatomic, assign) NSString *stringAssign;</span><br><span class=\"line\">@property (nonatomic, retain) NSString *stringRetain;</span><br><span class=\"line\">@property (nonatomic, copy) NSString *stringCopy;</span><br><span class=\"line\">@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;</span><br><span class=\"line\">@property (nonatomic, weak) NSString *stringWeak;</span><br><span class=\"line\">@property (nonatomic, strong) NSString *stringStrong;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringAssign = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string = %@&quot;, testObj.string);</span><br><span class=\"line\">    NSLog(@&quot;stringAssign = %@&quot;, testObj.stringAssign);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>stringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。</p>\n<h3 id=\"测试2\"><a href=\"#测试2\" class=\"headerlink\" title=\"测试2\"></a>测试2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringWeak = testObj.string;</span><br><span class=\"line\">//        testObj.stringStrong = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string = %@&quot;, testObj.string);</span><br><span class=\"line\">    NSLog(@&quot;stringWeak = %@&quot;, testObj.stringWeak);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)</span><br><span class=\"line\">2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)</span><br><span class=\"line\">2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1</span><br></pre></td></tr></table></figure>\n<p>强指针指向对象时，内存没有被释放。</p>\n<h3 id=\"测试3\"><a href=\"#测试3\" class=\"headerlink\" title=\"测试3\"></a>测试3</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringRetain = testObj.string;</span><br><span class=\"line\">        testObj.stringCopy = testObj.string;</span><br><span class=\"line\">        testObj.stringStrong = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p testObj.string</span><br><span class=\"line\">(NSString *) $0 = nil</span><br><span class=\"line\">(lldb) p testObj.stringRetain</span><br><span class=\"line\">(__NSCFString *) $1 = 0x00000001005036c0 @&quot;string1&quot;</span><br><span class=\"line\">(lldb) p testObj.stringCopy</span><br><span class=\"line\">(NSTaggedPointerString *) $2 = 0x31676e6972747375 @&quot;string1&quot;</span><br><span class=\"line\">(lldb) p testObj.stringStrong</span><br><span class=\"line\">(__NSCFString *) $3 = 0x00000001005036c0 @&quot;string1&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h1><p>带有自动变量（局部变量）的匿名函数。形如int (^count)(int) =  ^int (int count){return count+1;};<br>声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。<br>赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><ul>\n<li>_NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。</li>\n<li>_NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。</li>\n<li>_NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。</li>\n</ul>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ul>\n<li>block会截获外部自动变量的瞬间值。</li>\n<li>block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。</li>\n<li>使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如<code>__weak typeof(self) weakSelf = self;</code>新建一个指针的方式解决，在block内部使用__weak类型的对象。</li>\n<li>block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。</li>\n</ul>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface TestBlock : NSObject</span><br><span class=\"line\">typedef NSString *(^testBlockStruct)(NSString *);</span><br><span class=\"line\">@property (nonatomic, strong) testBlockStruct completionBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleBlock:(NSString *)string;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestBlock.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation TestBlock</span><br><span class=\"line\">- (void)handleBlock:(NSString *)string &#123;</span><br><span class=\"line\">    if (self.completionBlock) &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, self.completionBlock(string));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestBlock.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestBlock *testBlock = [[TestBlock alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *tempString = @&quot;Baidu&quot;;</span><br><span class=\"line\">    testBlock.completionBlock = ^NSString *(NSString *string)&#123;</span><br><span class=\"line\">        // 使用外部的局部变量tempString</span><br><span class=\"line\">        NSLog(@&quot;Block is here with %@ at %@.&quot;, string, tempString);</span><br><span class=\"line\">        return @&quot;Block is completed.&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 改变局部变量tempString，打印出的block截获了其瞬间值&quot;Baidu&quot;</span><br><span class=\"line\">    tempString = @&quot;Beijing&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [testBlock handleBlock:@&quot;LeeOuf&quot;];</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeeOuf at Baidu.</span><br><span class=\"line\">2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed.</span><br></pre></td></tr></table></figure>\n<h1 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h1><p>GCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。</p>\n<h2 id=\"Dispatch-Queue\"><a href=\"#Dispatch-Queue\" class=\"headerlink\" title=\"Dispatch Queue\"></a>Dispatch Queue</h2><ul>\n<li>DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。</li>\n<li>DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。</li>\n</ul>\n<p>获取Dispatch Queue方法: </p>\n<ul>\n<li>dispatch_get_main_queue()</li>\n<li>dispatch_get_global_queue()</li>\n<li>dispatch_queue_create()</li>\n</ul>\n<h2 id=\"方法列表\"><a href=\"#方法列表\" class=\"headerlink\" title=\"方法列表\"></a>方法列表</h2>\n\n\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ol>\n<li>MRC不能使用weak，使用什么替代？</li>\n<li>NSString为什么要使用copy?</li>\n<li>block底层forwarding实现</li>\n<li>那些部分不能使用async操作</li>\n<li>ARC和MRC下的循环引用</li>\n<li>如何检测VC的循环引用</li>\n<li>Category的好处，Category中是否可以加property？</li>\n<li>类别和扩展的区别？为啥要使用扩展</li>\n<li>Category中一定添加property，如何实现？</li>\n<li>Category中添加和原有类的方法，是否覆盖？  </li>\n</ol>\n<hr>\n<ol>\n<li>assign</li>\n<li>因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。</li>\n<li><code>__Block_byref_val_0</code>结构体实例有一个成员变量<code>__forwarding</code>持有只想该实例自身的指针。<br>static void _Block_byref_assign_copy(void <em>dest, const void </em>arg, const int flags) {<br> struct Block_byref <strong>destp = (struct Block_byref </strong>)dest;<br> struct Block_byref <em>src = (struct Block_byref </em>)arg;<br> // src points to stack<br> struct Block_byref <em>copy = (struct Block_byref </em>)_Block_allocator(src-&gt;size, false, isWeak);<br> copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)<br> src-&gt;forwarding = copy;  // patch stack to point to heap copy<br> copy-&gt;size = src-&gt;size;<br> // assign byref data block pointer into new Block<br> _Block_assign(src-&gt;forwarding, (void **)destp);<br>}<br>根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。</li>\n<li>UI部分。</li>\n<li>ARC中可以新建一个<strong>weak修饰符修饰的指针（如</strong>weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用<strong>block修饰（如</strong>block typeof(self) weakSelf = self;）。</li>\n<li>(1) Product-&gt;Profile，查看Leaks，如：\n\n</li>\n</ol>\n<p>(2) lldb直接print，查看对象是否为nil。<br>7&amp;9. 优点：不使用继承而为现有类添加新方法。<br>Category用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。<br>8&amp;10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。<br>（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。</p>\n"},{"title":"iOS基础-初学OC","date":"2016-08-16T07:36:56.000Z","_content":"我们知道iOS中的frame由x, y, width, height决定的一个个矩形。\n接下来尝试用一个矩形类来探究如何使用类中的属性和方法。\n\n**坐标类XYPoint。**\n```\n#import <Foundation/Foundation.h>\n\n@interface XYPoint : NSObject\n\n@property int x, y;\n\n- (void)setX:(int)xVal andY:(int)yVal;\n\n@end\n```\n\n```\n#import \"XYPoint.h\"\n\n@implementation XYPoint\n\n-(void)setX:(int)xVal andY:(int)yVal {\n    _x = xVal;\n    _y = yVal;\n}\n\n@end\n```\n\n**矩形类MyRect**\n```\n#import <Foundation/Foundation.h>\n#import \"XYPoint.h\"\n\n@interface MyRect : NSObject\n\n@property (nonatomic) int width, height;\n@property (nonatomic) XYPoint *origin;\n\n- (void)setWidth:(int)w andHeight:(int)h;\n- (int)area;\n- (int)perimeter;\n\n@end\n```\n\n```\n#import \"MyRect.h\"\n\n@implementation MyRect\n\n- (XYPoint *)origin {\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    _origin = origin;\n}\n\n- (void)setWidth:(int)w andHeight:(int)h {\n    _width = w;\n    _height = h;\n}\n\n- (int)area {\n    return _width * _height;\n}\n\n- (int)perimeter {\n    return (_width + _height) * 2;\n}\n\n@end\n```\n\n**main函数**\n```\n#import <Foundation/Foundation.h>\n#import \"MyRect.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyRect *rect = [[MyRect alloc] init];\n        XYPoint *point = [[XYPoint alloc] init];\n        \n        [point setX:100 andY:200];\n        \n        [rect setWidth:5 andHeight:8];\n        rect.origin = point;\n        \n        NSLog(@\"Rect w = %i, h = %i\", rect.width, rect.height);\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        \n        [point setX:50 andY:50];\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n//        NSLog(@\"Area = %i, Perimeter = %i\", [rect area], [rect perimeter]);\n    }\n    return 0;\n}\n```\n\nXYPoint类非常简单，x，y属性，加上其set方法。\nMyRect类中有width，height以及一个XYPoint属性，加上一些方法。\nmain函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。\n\n我们的重点在于MyRect类，这段代码是有问题的。\n首先看头文件，利用@property自动声明get\\set方法。\n再看实现文件，在get方法中报`Use of undeclared indentifier '_origin'`error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为`\"_\" + 属性名`。但是当我们同时重写了get\\set方法时，系统就不再自动帮我生成实例变量了。\n\n现在我们加上`@synthesize origin = _origin;`。error彻底消失，我们也可以自由地重写get\\set方法了。\n运行main函数得到结果。\n```\n2016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 8\n2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)\n2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)\nProgram ended with exit code: 0\n```\n\n回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，\n```\n- (void)setOrigin:(XYPoint *)origin {\n    _origin = origin;\n}\n```\norigin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而`_origin = origin;`只是将这个对象的地址赋值给了实例变量`_origin`，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。\n\n如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。\n\n第一个方案，改造setOrigin方法。\n```\n- (void)setOrigin:(XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    _origin.x = origin.x;\n    _origin.y = origin.y;\n}\n```\n当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。\n运行结果：\n```\n2016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 8\n2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)\n2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)\nProgram ended with exit code: 0\n```\n\n很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。\n```\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    _origin.x = origin.x;\n    _origin.y = origin.y;\n}\n```\n运行代码，期待...\n```\n2016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 8\n2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)\n2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)\nProgram ended with exit code: 0\n```\n然而结果是这样的，x，y的值从始至终都是0。\n\n我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。\n```\nrect.origin;\nrect.origin = point;\n```\n运行，\n```\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 8\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)\nProgram ended with exit code: 0\n```\n很棒，实现了我们的目的。\n\n可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？\n于是...\n```\n@synthesize origin = _origin;\n\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    self.origin.x = origin.x;\n    self.origin.y = origin.y;\n}\n```\n这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。\n\n最后，整理一下思路，`MyRect`类中有一个`origin`属性，我们在它的实现中为它指定了实例变量`_origin`作为它的存储空间。然后我们重写了它的get\\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取`_origin`实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。\n另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。\n\n来看一下改造完的代码。\nMyRect类实现。\n```\n#import \"MyRect.h\"\n\n@implementation MyRect\n\n@synthesize origin = _origin;\n\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    self.origin.x = origin.x;\n    self.origin.y = origin.y;\n}\n\n- (void)setWidth:(int)w andHeight:(int)h {\n    self.width = w;\n    self.height = h;\n}\n\n- (int)area {\n    return self.width * self.height;\n}\n\n- (int)perimeter {\n    return (self.width + self.height) * 2;\n}\n\n@end\n```\n\nmain函数\n```\n#import <Foundation/Foundation.h>\n#import \"MyRect.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyRect *rect = [[MyRect alloc] init];\n        XYPoint *point = [[XYPoint alloc] init];\n        \n        [point setX:100 andY:200];\n        \n        [rect setWidth:5 andHeight:8];\n        rect.origin = point;\n        \n        NSLog(@\"Rect w = %i, h = %i\", rect.width, rect.height);\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        \n        [point setX:50 andY:50];\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        NSLog(@\"Area = %i, Perimeter = %i\", [rect area], [rect perimeter]);\n    }\n    return 0;\n}\n```\n\n运行结果\n```\n2016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 8\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26\nProgram ended with exit code: 0\n```","source":"_posts/iOS基础-初学OC.md","raw":"---\ntitle: iOS基础-初学OC\ndate: 2016-08-16 15:36:56\ncategories: iOS基础知识\ntags:\n    - Objective-C\n    - 类\n    - 属性\n    - 方法\n    - 惰性实例化\n---\n我们知道iOS中的frame由x, y, width, height决定的一个个矩形。\n接下来尝试用一个矩形类来探究如何使用类中的属性和方法。\n\n**坐标类XYPoint。**\n```\n#import <Foundation/Foundation.h>\n\n@interface XYPoint : NSObject\n\n@property int x, y;\n\n- (void)setX:(int)xVal andY:(int)yVal;\n\n@end\n```\n\n```\n#import \"XYPoint.h\"\n\n@implementation XYPoint\n\n-(void)setX:(int)xVal andY:(int)yVal {\n    _x = xVal;\n    _y = yVal;\n}\n\n@end\n```\n\n**矩形类MyRect**\n```\n#import <Foundation/Foundation.h>\n#import \"XYPoint.h\"\n\n@interface MyRect : NSObject\n\n@property (nonatomic) int width, height;\n@property (nonatomic) XYPoint *origin;\n\n- (void)setWidth:(int)w andHeight:(int)h;\n- (int)area;\n- (int)perimeter;\n\n@end\n```\n\n```\n#import \"MyRect.h\"\n\n@implementation MyRect\n\n- (XYPoint *)origin {\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    _origin = origin;\n}\n\n- (void)setWidth:(int)w andHeight:(int)h {\n    _width = w;\n    _height = h;\n}\n\n- (int)area {\n    return _width * _height;\n}\n\n- (int)perimeter {\n    return (_width + _height) * 2;\n}\n\n@end\n```\n\n**main函数**\n```\n#import <Foundation/Foundation.h>\n#import \"MyRect.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyRect *rect = [[MyRect alloc] init];\n        XYPoint *point = [[XYPoint alloc] init];\n        \n        [point setX:100 andY:200];\n        \n        [rect setWidth:5 andHeight:8];\n        rect.origin = point;\n        \n        NSLog(@\"Rect w = %i, h = %i\", rect.width, rect.height);\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        \n        [point setX:50 andY:50];\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n//        NSLog(@\"Area = %i, Perimeter = %i\", [rect area], [rect perimeter]);\n    }\n    return 0;\n}\n```\n\nXYPoint类非常简单，x，y属性，加上其set方法。\nMyRect类中有width，height以及一个XYPoint属性，加上一些方法。\nmain函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。\n\n我们的重点在于MyRect类，这段代码是有问题的。\n首先看头文件，利用@property自动声明get\\set方法。\n再看实现文件，在get方法中报`Use of undeclared indentifier '_origin'`error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为`\"_\" + 属性名`。但是当我们同时重写了get\\set方法时，系统就不再自动帮我生成实例变量了。\n\n现在我们加上`@synthesize origin = _origin;`。error彻底消失，我们也可以自由地重写get\\set方法了。\n运行main函数得到结果。\n```\n2016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 8\n2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)\n2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)\nProgram ended with exit code: 0\n```\n\n回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，\n```\n- (void)setOrigin:(XYPoint *)origin {\n    _origin = origin;\n}\n```\norigin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而`_origin = origin;`只是将这个对象的地址赋值给了实例变量`_origin`，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。\n\n如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。\n\n第一个方案，改造setOrigin方法。\n```\n- (void)setOrigin:(XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    _origin.x = origin.x;\n    _origin.y = origin.y;\n}\n```\n当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。\n运行结果：\n```\n2016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 8\n2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)\n2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)\nProgram ended with exit code: 0\n```\n\n很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。\n```\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    _origin.x = origin.x;\n    _origin.y = origin.y;\n}\n```\n运行代码，期待...\n```\n2016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 8\n2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)\n2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)\nProgram ended with exit code: 0\n```\n然而结果是这样的，x，y的值从始至终都是0。\n\n我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。\n```\nrect.origin;\nrect.origin = point;\n```\n运行，\n```\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 8\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)\nProgram ended with exit code: 0\n```\n很棒，实现了我们的目的。\n\n可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？\n于是...\n```\n@synthesize origin = _origin;\n\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    self.origin.x = origin.x;\n    self.origin.y = origin.y;\n}\n```\n这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。\n\n最后，整理一下思路，`MyRect`类中有一个`origin`属性，我们在它的实现中为它指定了实例变量`_origin`作为它的存储空间。然后我们重写了它的get\\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取`_origin`实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。\n另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。\n\n来看一下改造完的代码。\nMyRect类实现。\n```\n#import \"MyRect.h\"\n\n@implementation MyRect\n\n@synthesize origin = _origin;\n\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    self.origin.x = origin.x;\n    self.origin.y = origin.y;\n}\n\n- (void)setWidth:(int)w andHeight:(int)h {\n    self.width = w;\n    self.height = h;\n}\n\n- (int)area {\n    return self.width * self.height;\n}\n\n- (int)perimeter {\n    return (self.width + self.height) * 2;\n}\n\n@end\n```\n\nmain函数\n```\n#import <Foundation/Foundation.h>\n#import \"MyRect.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyRect *rect = [[MyRect alloc] init];\n        XYPoint *point = [[XYPoint alloc] init];\n        \n        [point setX:100 andY:200];\n        \n        [rect setWidth:5 andHeight:8];\n        rect.origin = point;\n        \n        NSLog(@\"Rect w = %i, h = %i\", rect.width, rect.height);\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        \n        [point setX:50 andY:50];\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        NSLog(@\"Area = %i, Perimeter = %i\", [rect area], [rect perimeter]);\n    }\n    return 0;\n}\n```\n\n运行结果\n```\n2016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 8\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26\nProgram ended with exit code: 0\n```","slug":"iOS基础-初学OC","published":1,"updated":"2019-06-12T05:45:55.320Z","_id":"cjwss6z65000h5mlwzmmtiu80","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我们知道iOS中的frame由x, y, width, height决定的一个个矩形。<br>接下来尝试用一个矩形类来探究如何使用类中的属性和方法。</p>\n<p><strong>坐标类XYPoint。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XYPoint : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property int x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setX:(int)xVal andY:(int)yVal;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XYPoint.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XYPoint</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)setX:(int)xVal andY:(int)yVal &#123;</span><br><span class=\"line\">    _x = xVal;</span><br><span class=\"line\">    _y = yVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>矩形类MyRect</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;XYPoint.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface MyRect : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic) int width, height;</span><br><span class=\"line\">@property (nonatomic) XYPoint *origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h;</span><br><span class=\"line\">- (int)area;</span><br><span class=\"line\">- (int)perimeter;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyRect</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin = origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h &#123;</span><br><span class=\"line\">    _width = w;</span><br><span class=\"line\">    _height = h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)area &#123;</span><br><span class=\"line\">    return _width * _height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)perimeter &#123;</span><br><span class=\"line\">    return (_width + _height) * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>main函数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        MyRect *rect = [[MyRect alloc] init];</span><br><span class=\"line\">        XYPoint *point = [[XYPoint alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:100 andY:200];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [rect setWidth:5 andHeight:8];</span><br><span class=\"line\">        rect.origin = point;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height);</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:50 andY:50];</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">//        NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>XYPoint类非常简单，x，y属性，加上其set方法。<br>MyRect类中有width，height以及一个XYPoint属性，加上一些方法。<br>main函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。</p>\n<p>我们的重点在于MyRect类，这段代码是有问题的。<br>首先看头文件，利用@property自动声明get\\set方法。<br>再看实现文件，在get方法中报<code>Use of undeclared indentifier &#39;_origin&#39;</code>error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为<code>&quot;_&quot; + 属性名</code>。但是当我们同时重写了get\\set方法时，系统就不再自动帮我生成实例变量了。</p>\n<p>现在我们加上<code>@synthesize origin = _origin;</code>。error彻底消失，我们也可以自由地重写get\\set方法了。<br>运行main函数得到结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin = origin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>origin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而<code>_origin = origin;</code>只是将这个对象的地址赋值给了实例变量<code>_origin</code>，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。</p>\n<p>如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。</p>\n<p>第一个方案，改造setOrigin方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _origin.x = origin.x;</span><br><span class=\"line\">    _origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。<br>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin.x = origin.x;</span><br><span class=\"line\">    _origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行代码，期待…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)</span><br><span class=\"line\">2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>然而结果是这样的，x，y的值从始至终都是0。</p>\n<p>我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.origin;</span><br><span class=\"line\">rect.origin = point;</span><br></pre></td></tr></table></figure></p>\n<p>运行，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>很棒，实现了我们的目的。</p>\n<p>可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？<br>于是…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@synthesize origin = _origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    self.origin.x = origin.x;</span><br><span class=\"line\">    self.origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。</p>\n<p>最后，整理一下思路，<code>MyRect</code>类中有一个<code>origin</code>属性，我们在它的实现中为它指定了实例变量<code>_origin</code>作为它的存储空间。然后我们重写了它的get\\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取<code>_origin</code>实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。<br>另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。</p>\n<p>来看一下改造完的代码。<br>MyRect类实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyRect</span><br><span class=\"line\"></span><br><span class=\"line\">@synthesize origin = _origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    self.origin.x = origin.x;</span><br><span class=\"line\">    self.origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h &#123;</span><br><span class=\"line\">    self.width = w;</span><br><span class=\"line\">    self.height = h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)area &#123;</span><br><span class=\"line\">    return self.width * self.height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)perimeter &#123;</span><br><span class=\"line\">    return (self.width + self.height) * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>main函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        MyRect *rect = [[MyRect alloc] init];</span><br><span class=\"line\">        XYPoint *point = [[XYPoint alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:100 andY:200];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [rect setWidth:5 andHeight:8];</span><br><span class=\"line\">        rect.origin = point;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height);</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:50 andY:50];</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们知道iOS中的frame由x, y, width, height决定的一个个矩形。<br>接下来尝试用一个矩形类来探究如何使用类中的属性和方法。</p>\n<p><strong>坐标类XYPoint。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XYPoint : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property int x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setX:(int)xVal andY:(int)yVal;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XYPoint.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XYPoint</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)setX:(int)xVal andY:(int)yVal &#123;</span><br><span class=\"line\">    _x = xVal;</span><br><span class=\"line\">    _y = yVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>矩形类MyRect</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;XYPoint.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface MyRect : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic) int width, height;</span><br><span class=\"line\">@property (nonatomic) XYPoint *origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h;</span><br><span class=\"line\">- (int)area;</span><br><span class=\"line\">- (int)perimeter;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyRect</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin = origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h &#123;</span><br><span class=\"line\">    _width = w;</span><br><span class=\"line\">    _height = h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)area &#123;</span><br><span class=\"line\">    return _width * _height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)perimeter &#123;</span><br><span class=\"line\">    return (_width + _height) * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>main函数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        MyRect *rect = [[MyRect alloc] init];</span><br><span class=\"line\">        XYPoint *point = [[XYPoint alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:100 andY:200];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [rect setWidth:5 andHeight:8];</span><br><span class=\"line\">        rect.origin = point;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height);</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:50 andY:50];</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">//        NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>XYPoint类非常简单，x，y属性，加上其set方法。<br>MyRect类中有width，height以及一个XYPoint属性，加上一些方法。<br>main函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。</p>\n<p>我们的重点在于MyRect类，这段代码是有问题的。<br>首先看头文件，利用@property自动声明get\\set方法。<br>再看实现文件，在get方法中报<code>Use of undeclared indentifier &#39;_origin&#39;</code>error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为<code>&quot;_&quot; + 属性名</code>。但是当我们同时重写了get\\set方法时，系统就不再自动帮我生成实例变量了。</p>\n<p>现在我们加上<code>@synthesize origin = _origin;</code>。error彻底消失，我们也可以自由地重写get\\set方法了。<br>运行main函数得到结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin = origin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>origin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而<code>_origin = origin;</code>只是将这个对象的地址赋值给了实例变量<code>_origin</code>，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。</p>\n<p>如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。</p>\n<p>第一个方案，改造setOrigin方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _origin.x = origin.x;</span><br><span class=\"line\">    _origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。<br>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin.x = origin.x;</span><br><span class=\"line\">    _origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行代码，期待…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)</span><br><span class=\"line\">2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>然而结果是这样的，x，y的值从始至终都是0。</p>\n<p>我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.origin;</span><br><span class=\"line\">rect.origin = point;</span><br></pre></td></tr></table></figure></p>\n<p>运行，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>很棒，实现了我们的目的。</p>\n<p>可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？<br>于是…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@synthesize origin = _origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    self.origin.x = origin.x;</span><br><span class=\"line\">    self.origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。</p>\n<p>最后，整理一下思路，<code>MyRect</code>类中有一个<code>origin</code>属性，我们在它的实现中为它指定了实例变量<code>_origin</code>作为它的存储空间。然后我们重写了它的get\\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取<code>_origin</code>实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。<br>另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。</p>\n<p>来看一下改造完的代码。<br>MyRect类实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyRect</span><br><span class=\"line\"></span><br><span class=\"line\">@synthesize origin = _origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    self.origin.x = origin.x;</span><br><span class=\"line\">    self.origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h &#123;</span><br><span class=\"line\">    self.width = w;</span><br><span class=\"line\">    self.height = h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)area &#123;</span><br><span class=\"line\">    return self.width * self.height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)perimeter &#123;</span><br><span class=\"line\">    return (self.width + self.height) * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>main函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        MyRect *rect = [[MyRect alloc] init];</span><br><span class=\"line\">        XYPoint *point = [[XYPoint alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:100 andY:200];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [rect setWidth:5 andHeight:8];</span><br><span class=\"line\">        rect.origin = point;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height);</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:50 andY:50];</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n"},{"title":"iOS基础-类、对象和方法.md","date":"2016-08-14T08:15:39.000Z","_content":"\n本文是在阅读`Objective-C程序设计  第6版`一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。\n\n# 什么是对象\n我们知道，OC是在C的基础上设计的`面向对象`的程序设计语言，而C则是`过程性语言`。\n以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。\n而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。\n\n我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。\n\n# 类、方法\n**Fraction类**\n```\n#import <Foundation/Foundation.h>\n\n@interface Fraction : NSObject\n\n- (void)print;\n- (void)setNumerator: (int)n;\n- (void)setDenominator: (int)d;\n\n@end\n```\n\n```\n#import \"Fraction.h\"\n\n@implementation Fraction {\n    int numerator;\n    int denominator;\n}\n\n- (void)print {\n    NSLog(@\"%i / %i\", numerator, denominator);\n}\n\n- (void)setNumerator:(int)n {\n    numerator = n;\n}\n\n- (void)setDenominator:(int)d {\n    denominator = d;\n}\n@end\n```\n\n**main函数**\n```\n#import <Foundation/Foundation.h>\n#import \"Fraction.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        // insert code here...\n        Fraction *fraction;\n        \n        fraction = [[Fraction alloc] init];\n        [fraction setNumerator:1];\n        [fraction setDenominator:3];\n        \n        NSLog(@\"The value of fracton is: \");\n        [fraction print];\n    }\n    return 0;\n}\n```\n\n先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。\n另外@符号在\"\"前，表示这是常量NSString对象。\n\n然后来看main函数。\n第一行中，我们就看到了`@autoreleasepool`，这是什么呢？\n## autoreleasepool\n嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。\n什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。\n\n[对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。](http://blog.sina.com.cn/s/blog_8c87ba3b0100tgfs.html)\n\n以下对于autoreleasepool的分析参考了[@雷纯锋的技术博客](http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/)\n文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。\n\n首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。\n### 场景1\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.1\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    string_weak_ = string;\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    \n    NSLog(@\"string_weak_@viewWillAppear: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    \n    NSLog(@\"string_weak_@viewDidAppear: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__strong NSString *string_strong_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.2\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    string_strong_ = string;\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_strong_@viewDidLoad: %@ with retainCount: %@\", string_strong_, [string_strong_ valueForKey:@\"retainCount\"]);\n}\n\n// ...省略\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.3\n    Fraction *fraction = [[Fraction alloc] init];\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    fraction_weak_ = fraction;\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__strong Fraction *fraction_strong_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.4\n    Fraction *fraction = [[Fraction alloc] init];\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    fraction_strong_ = fraction;\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_strong_@viewDidLoad: %@ with retainCount: %@\", fraction_strong_, [fraction_strong_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景1.1(__weak NSString *) 结果 \n2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I'm here! with retainCount: 3\n2016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景1.2(__strong NSString *) 结果 \n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I'm here! with retainCount: 3\n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I'm here! with retainCount: 3\n2016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I'm here! with retainCount: 2\n2016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I'm here! with retainCount: 1\n\n// 场景1.3(__weak Fraction *) 结果\n2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 1\n2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 1\n2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 3\n2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景1.4(__strong Fraction *) 结果\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 2\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 2\n2016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n2016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n```\n> 我们使用了一个全局的 __weak 变量 string_weak_ 来指向它。因为 __weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 \n\n最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。\n场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。\n\n### 场景2\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 2.1\n    @autoreleasepool {\n        NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        string_weak_ = string;\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 2.2\n    @autoreleasepool {\n        Fraction *fraction = [[Fraction alloc] init];\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        fraction_weak_ = fraction;\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景2.1(__weak NSString *) 结果\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)\n2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景2.2(__weak Fraction *) 结果\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 1\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 1\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 3\n2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)\n2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n```\n\n### 场景3\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 3.1\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    @autoreleasepool {\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        string_weak_ = string;\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 3.2\n    Fraction *fraction = [[Fraction alloc] init];\n    @autoreleasepool {\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        fraction_weak_ = fraction;\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景3.1(__weak NSString *) 结果\n2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I'm here! with retainCount: 3\n2016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景3.2(__weak Fraction *) 结果\n2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 3\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 3\n2016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n```\n\n再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];\n向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：\n```\n+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n- (void)dealloc OBJC_SWIFT_UNAVAILABLE(\"use 'deinit' to define a de-initializer\");\n```\n\n随后调用了init方法，同样，这来自于NSObject的实例方法。\n\nfraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。\n\n而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。\nOC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，`[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));`我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。\n\n提前阅读一些runtime的知识\n[iOS~runtime理解](http://www.jianshu.com/p/927c8384855a)\n[iOS中的runtime应用](http://www.jianshu.com/p/364eab29f4f5)\n","source":"_posts/iOS基础-类、对象和方法.md","raw":"---\ntitle: iOS基础-类、对象和方法.md\ndate: 2016-08-14 16:15:39\ncategories: iOS基础知识\ntags:\n    - 类\n    - 对象\n    - 方法\n    - autoreleasepool\n---\n\n本文是在阅读`Objective-C程序设计  第6版`一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。\n\n# 什么是对象\n我们知道，OC是在C的基础上设计的`面向对象`的程序设计语言，而C则是`过程性语言`。\n以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。\n而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。\n\n我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。\n\n# 类、方法\n**Fraction类**\n```\n#import <Foundation/Foundation.h>\n\n@interface Fraction : NSObject\n\n- (void)print;\n- (void)setNumerator: (int)n;\n- (void)setDenominator: (int)d;\n\n@end\n```\n\n```\n#import \"Fraction.h\"\n\n@implementation Fraction {\n    int numerator;\n    int denominator;\n}\n\n- (void)print {\n    NSLog(@\"%i / %i\", numerator, denominator);\n}\n\n- (void)setNumerator:(int)n {\n    numerator = n;\n}\n\n- (void)setDenominator:(int)d {\n    denominator = d;\n}\n@end\n```\n\n**main函数**\n```\n#import <Foundation/Foundation.h>\n#import \"Fraction.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        // insert code here...\n        Fraction *fraction;\n        \n        fraction = [[Fraction alloc] init];\n        [fraction setNumerator:1];\n        [fraction setDenominator:3];\n        \n        NSLog(@\"The value of fracton is: \");\n        [fraction print];\n    }\n    return 0;\n}\n```\n\n先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。\n另外@符号在\"\"前，表示这是常量NSString对象。\n\n然后来看main函数。\n第一行中，我们就看到了`@autoreleasepool`，这是什么呢？\n## autoreleasepool\n嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。\n什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。\n\n[对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。](http://blog.sina.com.cn/s/blog_8c87ba3b0100tgfs.html)\n\n以下对于autoreleasepool的分析参考了[@雷纯锋的技术博客](http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/)\n文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。\n\n首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。\n### 场景1\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.1\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    string_weak_ = string;\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    \n    NSLog(@\"string_weak_@viewWillAppear: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    \n    NSLog(@\"string_weak_@viewDidAppear: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__strong NSString *string_strong_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.2\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    string_strong_ = string;\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_strong_@viewDidLoad: %@ with retainCount: %@\", string_strong_, [string_strong_ valueForKey:@\"retainCount\"]);\n}\n\n// ...省略\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.3\n    Fraction *fraction = [[Fraction alloc] init];\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    fraction_weak_ = fraction;\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__strong Fraction *fraction_strong_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.4\n    Fraction *fraction = [[Fraction alloc] init];\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    fraction_strong_ = fraction;\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_strong_@viewDidLoad: %@ with retainCount: %@\", fraction_strong_, [fraction_strong_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景1.1(__weak NSString *) 结果 \n2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I'm here! with retainCount: 3\n2016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景1.2(__strong NSString *) 结果 \n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I'm here! with retainCount: 3\n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I'm here! with retainCount: 3\n2016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I'm here! with retainCount: 2\n2016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I'm here! with retainCount: 1\n\n// 场景1.3(__weak Fraction *) 结果\n2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 1\n2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 1\n2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 3\n2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景1.4(__strong Fraction *) 结果\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 2\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 2\n2016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n2016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n```\n> 我们使用了一个全局的 __weak 变量 string_weak_ 来指向它。因为 __weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 \n\n最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。\n场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。\n\n### 场景2\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 2.1\n    @autoreleasepool {\n        NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        string_weak_ = string;\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 2.2\n    @autoreleasepool {\n        Fraction *fraction = [[Fraction alloc] init];\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        fraction_weak_ = fraction;\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景2.1(__weak NSString *) 结果\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)\n2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景2.2(__weak Fraction *) 结果\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 1\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 1\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 3\n2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)\n2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n```\n\n### 场景3\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 3.1\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    @autoreleasepool {\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        string_weak_ = string;\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 3.2\n    Fraction *fraction = [[Fraction alloc] init];\n    @autoreleasepool {\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        fraction_weak_ = fraction;\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景3.1(__weak NSString *) 结果\n2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I'm here! with retainCount: 3\n2016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景3.2(__weak Fraction *) 结果\n2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 3\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 3\n2016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n```\n\n再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];\n向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：\n```\n+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n- (void)dealloc OBJC_SWIFT_UNAVAILABLE(\"use 'deinit' to define a de-initializer\");\n```\n\n随后调用了init方法，同样，这来自于NSObject的实例方法。\n\nfraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。\n\n而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。\nOC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，`[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));`我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。\n\n提前阅读一些runtime的知识\n[iOS~runtime理解](http://www.jianshu.com/p/927c8384855a)\n[iOS中的runtime应用](http://www.jianshu.com/p/364eab29f4f5)\n","slug":"iOS基础-类、对象和方法","published":1,"updated":"2019-06-12T05:46:05.244Z","_id":"cjwss6z66000k5mlw7tyd6c8e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文是在阅读<code>Objective-C程序设计  第6版</code>一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。</p>\n<h1 id=\"什么是对象\"><a href=\"#什么是对象\" class=\"headerlink\" title=\"什么是对象\"></a>什么是对象</h1><p>我们知道，OC是在C的基础上设计的<code>面向对象</code>的程序设计语言，而C则是<code>过程性语言</code>。<br>以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。<br>而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。</p>\n<p>我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。</p>\n<h1 id=\"类、方法\"><a href=\"#类、方法\" class=\"headerlink\" title=\"类、方法\"></a>类、方法</h1><p><strong>Fraction类</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface Fraction : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print;</span><br><span class=\"line\">- (void)setNumerator: (int)n;</span><br><span class=\"line\">- (void)setDenominator: (int)d;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Fraction.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Fraction &#123;</span><br><span class=\"line\">    int numerator;</span><br><span class=\"line\">    int denominator;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print &#123;</span><br><span class=\"line\">    NSLog(@&quot;%i / %i&quot;, numerator, denominator);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setNumerator:(int)n &#123;</span><br><span class=\"line\">    numerator = n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setDenominator:(int)d &#123;</span><br><span class=\"line\">    denominator = d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>main函数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Fraction.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        // insert code here...</span><br><span class=\"line\">        Fraction *fraction;</span><br><span class=\"line\">        </span><br><span class=\"line\">        fraction = [[Fraction alloc] init];</span><br><span class=\"line\">        [fraction setNumerator:1];</span><br><span class=\"line\">        [fraction setDenominator:3];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;The value of fracton is: &quot;);</span><br><span class=\"line\">        [fraction print];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。<br>另外@符号在””前，表示这是常量NSString对象。</p>\n<p>然后来看main函数。<br>第一行中，我们就看到了<code>@autoreleasepool</code>，这是什么呢？</p>\n<h2 id=\"autoreleasepool\"><a href=\"#autoreleasepool\" class=\"headerlink\" title=\"autoreleasepool\"></a>autoreleasepool</h2><p>嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。<br>什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_8c87ba3b0100tgfs.html\" target=\"_blank\" rel=\"noopener\">对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</a></p>\n<p>以下对于autoreleasepool的分析参考了<a href=\"http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/\" target=\"_blank\" rel=\"noopener\">@雷纯锋的技术博客</a><br>文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。</p>\n<p>首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。</p>\n<h3 id=\"场景1\"><a href=\"#场景1\" class=\"headerlink\" title=\"场景1\"></a>场景1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.1</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    string_weak_ = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewWillAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__strong NSString *string_strong_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.2</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    string_strong_ = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_strong_@viewDidLoad: %@ with retainCount: %@&quot;, string_strong_, [string_strong_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ...省略</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.3</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    fraction_weak_ = fraction;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__strong Fraction *fraction_strong_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.4</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    fraction_strong_ = fraction;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_strong_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_strong_, [fraction_strong_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景1.1(__weak NSString *) 结果 </span><br><span class=\"line\">2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.2(__strong NSString *) 结果 </span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I&apos;m here! with retainCount: 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.3(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.4(__strong Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们使用了一个全局的 <strong>weak 变量 string_weak_ 来指向它。因为 </strong>weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 </p>\n</blockquote>\n<p>最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。<br>场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。</p>\n<h3 id=\"场景2\"><a href=\"#场景2\" class=\"headerlink\" title=\"场景2\"></a>场景2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 2.1</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        string_weak_ = string;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 2.2</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        fraction_weak_ = fraction;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景2.1(__weak NSString *) 结果</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景2.2(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br></pre></td></tr></table></figure>\n<h3 id=\"场景3\"><a href=\"#场景3\" class=\"headerlink\" title=\"场景3\"></a>场景3</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 3.1</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        string_weak_ = string;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 3.2</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        fraction_weak_ = fraction;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景3.1(__weak NSString *) 结果</span><br><span class=\"line\">2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景3.2(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br></pre></td></tr></table></figure>\n<p>再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];<br>向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">- (void)dealloc OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;deinit&apos; to define a de-initializer&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>随后调用了init方法，同样，这来自于NSObject的实例方法。</p>\n<p>fraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。</p>\n<p>而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。<br>OC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，<code>[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));</code>我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。</p>\n<p>提前阅读一些runtime的知识<br><a href=\"http://www.jianshu.com/p/927c8384855a\" target=\"_blank\" rel=\"noopener\">iOS~runtime理解</a><br><a href=\"http://www.jianshu.com/p/364eab29f4f5\" target=\"_blank\" rel=\"noopener\">iOS中的runtime应用</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是在阅读<code>Objective-C程序设计  第6版</code>一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。</p>\n<h1 id=\"什么是对象\"><a href=\"#什么是对象\" class=\"headerlink\" title=\"什么是对象\"></a>什么是对象</h1><p>我们知道，OC是在C的基础上设计的<code>面向对象</code>的程序设计语言，而C则是<code>过程性语言</code>。<br>以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。<br>而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。</p>\n<p>我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。</p>\n<h1 id=\"类、方法\"><a href=\"#类、方法\" class=\"headerlink\" title=\"类、方法\"></a>类、方法</h1><p><strong>Fraction类</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface Fraction : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print;</span><br><span class=\"line\">- (void)setNumerator: (int)n;</span><br><span class=\"line\">- (void)setDenominator: (int)d;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Fraction.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Fraction &#123;</span><br><span class=\"line\">    int numerator;</span><br><span class=\"line\">    int denominator;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print &#123;</span><br><span class=\"line\">    NSLog(@&quot;%i / %i&quot;, numerator, denominator);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setNumerator:(int)n &#123;</span><br><span class=\"line\">    numerator = n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setDenominator:(int)d &#123;</span><br><span class=\"line\">    denominator = d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>main函数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Fraction.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        // insert code here...</span><br><span class=\"line\">        Fraction *fraction;</span><br><span class=\"line\">        </span><br><span class=\"line\">        fraction = [[Fraction alloc] init];</span><br><span class=\"line\">        [fraction setNumerator:1];</span><br><span class=\"line\">        [fraction setDenominator:3];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;The value of fracton is: &quot;);</span><br><span class=\"line\">        [fraction print];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。<br>另外@符号在””前，表示这是常量NSString对象。</p>\n<p>然后来看main函数。<br>第一行中，我们就看到了<code>@autoreleasepool</code>，这是什么呢？</p>\n<h2 id=\"autoreleasepool\"><a href=\"#autoreleasepool\" class=\"headerlink\" title=\"autoreleasepool\"></a>autoreleasepool</h2><p>嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。<br>什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_8c87ba3b0100tgfs.html\" target=\"_blank\" rel=\"noopener\">对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</a></p>\n<p>以下对于autoreleasepool的分析参考了<a href=\"http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/\" target=\"_blank\" rel=\"noopener\">@雷纯锋的技术博客</a><br>文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。</p>\n<p>首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。</p>\n<h3 id=\"场景1\"><a href=\"#场景1\" class=\"headerlink\" title=\"场景1\"></a>场景1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.1</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    string_weak_ = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewWillAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__strong NSString *string_strong_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.2</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    string_strong_ = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_strong_@viewDidLoad: %@ with retainCount: %@&quot;, string_strong_, [string_strong_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ...省略</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.3</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    fraction_weak_ = fraction;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__strong Fraction *fraction_strong_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.4</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    fraction_strong_ = fraction;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_strong_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_strong_, [fraction_strong_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景1.1(__weak NSString *) 结果 </span><br><span class=\"line\">2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.2(__strong NSString *) 结果 </span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I&apos;m here! with retainCount: 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.3(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.4(__strong Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们使用了一个全局的 <strong>weak 变量 string_weak_ 来指向它。因为 </strong>weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 </p>\n</blockquote>\n<p>最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。<br>场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。</p>\n<h3 id=\"场景2\"><a href=\"#场景2\" class=\"headerlink\" title=\"场景2\"></a>场景2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 2.1</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        string_weak_ = string;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 2.2</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        fraction_weak_ = fraction;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景2.1(__weak NSString *) 结果</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景2.2(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br></pre></td></tr></table></figure>\n<h3 id=\"场景3\"><a href=\"#场景3\" class=\"headerlink\" title=\"场景3\"></a>场景3</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 3.1</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        string_weak_ = string;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 3.2</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        fraction_weak_ = fraction;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景3.1(__weak NSString *) 结果</span><br><span class=\"line\">2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景3.2(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br></pre></td></tr></table></figure>\n<p>再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];<br>向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">- (void)dealloc OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;deinit&apos; to define a de-initializer&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>随后调用了init方法，同样，这来自于NSObject的实例方法。</p>\n<p>fraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。</p>\n<p>而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。<br>OC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，<code>[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));</code>我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。</p>\n<p>提前阅读一些runtime的知识<br><a href=\"http://www.jianshu.com/p/927c8384855a\" target=\"_blank\" rel=\"noopener\">iOS~runtime理解</a><br><a href=\"http://www.jianshu.com/p/364eab29f4f5\" target=\"_blank\" rel=\"noopener\">iOS中的runtime应用</a></p>\n"},{"title":"笔记-iOS中踩坑记录","date":"2016-12-19T07:48:43.000Z","_content":"\n1. NSNumber类型判断是否为0不能使用`aIntegerNum == 0`，而应使用`[aIntegerNum isEqualToNumber:@0]`，前者比较地址，后者比较值。\n2. UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。\n3. 时间戳转换时间时会相差8小时，需要计算时区。\n4. iOS10中UISwitch的特异性\n5. 快速便利Array\\Set时，对元素进行操作必挂\n6. 在block中使用成员变量，会导致循环引用\n7. iOS10以下导航栏问题[http://www.jianshu.com/p/e4448c24d900](导航栏隐藏 && 导航栏错乱) [http://www.jianshu.com/p/4b8af425a7d0](iOS 隐藏导航栏导致导航栏错乱的那些坑)\n8. __block相当于unsafe_unretain，在某些情况下，会导致crash\n```\nself.string1 = @\"String 1\";   \nself.string2 = self.string1;   // unsafe_unretain\nself.string1 = nil;  \nNSLog(@\"String 2 = %@\", self.string2);  \n```\n9. MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。\n10. A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad，拓展：[viewDidAppear和viewDidDisappear的执行顺序](https://www.jianshu.com/p/2ca25b1ebe5a)[iOS--viewDidAppear和viewDidDisappear调用顺序](https://www.jianshu.com/p/9391b8043445)。\n11. iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。\n12. Notification在主线程中是同步执行的。\n13. 若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。\n14. iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。\n15. 虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。\n16. 一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。\n17. UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照[https://www.jianshu.com/p/57b2c41448bf](UIButton选中状态下的点击)。","source":"_posts/笔记-iOS中踩坑记录.md","raw":"---\ntitle: 笔记-iOS中踩坑记录\ndate: 2016-12-19 15:48:43\ncategories: 笔记\ntags: \n    - 踩坑记录\n---\n\n1. NSNumber类型判断是否为0不能使用`aIntegerNum == 0`，而应使用`[aIntegerNum isEqualToNumber:@0]`，前者比较地址，后者比较值。\n2. UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。\n3. 时间戳转换时间时会相差8小时，需要计算时区。\n4. iOS10中UISwitch的特异性\n5. 快速便利Array\\Set时，对元素进行操作必挂\n6. 在block中使用成员变量，会导致循环引用\n7. iOS10以下导航栏问题[http://www.jianshu.com/p/e4448c24d900](导航栏隐藏 && 导航栏错乱) [http://www.jianshu.com/p/4b8af425a7d0](iOS 隐藏导航栏导致导航栏错乱的那些坑)\n8. __block相当于unsafe_unretain，在某些情况下，会导致crash\n```\nself.string1 = @\"String 1\";   \nself.string2 = self.string1;   // unsafe_unretain\nself.string1 = nil;  \nNSLog(@\"String 2 = %@\", self.string2);  \n```\n9. MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。\n10. A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad，拓展：[viewDidAppear和viewDidDisappear的执行顺序](https://www.jianshu.com/p/2ca25b1ebe5a)[iOS--viewDidAppear和viewDidDisappear调用顺序](https://www.jianshu.com/p/9391b8043445)。\n11. iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。\n12. Notification在主线程中是同步执行的。\n13. 若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。\n14. iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。\n15. 虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。\n16. 一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。\n17. UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照[https://www.jianshu.com/p/57b2c41448bf](UIButton选中状态下的点击)。","slug":"笔记-iOS中踩坑记录","published":1,"updated":"2019-06-12T05:11:45.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwss6z68000n5mlw3tuy503w","content":"<ol>\n<li>NSNumber类型判断是否为0不能使用<code>aIntegerNum == 0</code>，而应使用<code>[aIntegerNum isEqualToNumber:@0]</code>，前者比较地址，后者比较值。</li>\n<li>UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。</li>\n<li>时间戳转换时间时会相差8小时，需要计算时区。</li>\n<li>iOS10中UISwitch的特异性</li>\n<li>快速便利Array\\Set时，对元素进行操作必挂</li>\n<li>在block中使用成员变量，会导致循环引用</li>\n<li>iOS10以下导航栏问题<a href=\"导航栏隐藏 &amp;&amp; 导航栏错乱\">http://www.jianshu.com/p/e4448c24d900</a> <a href=\"iOS 隐藏导航栏导致导航栏错乱的那些坑\">http://www.jianshu.com/p/4b8af425a7d0</a></li>\n<li><p>__block相当于unsafe_unretain，在某些情况下，会导致crash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.string1 = @&quot;String 1&quot;;   </span><br><span class=\"line\">self.string2 = self.string1;   // unsafe_unretain</span><br><span class=\"line\">self.string1 = nil;  </span><br><span class=\"line\">NSLog(@&quot;String 2 = %@&quot;, self.string2);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。</p>\n</li>\n<li>A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad，拓展：<a href=\"https://www.jianshu.com/p/2ca25b1ebe5a\" target=\"_blank\" rel=\"noopener\">viewDidAppear和viewDidDisappear的执行顺序</a><a href=\"https://www.jianshu.com/p/9391b8043445\" target=\"_blank\" rel=\"noopener\">iOS–viewDidAppear和viewDidDisappear调用顺序</a>。</li>\n<li>iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。</li>\n<li>Notification在主线程中是同步执行的。</li>\n<li>若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。</li>\n<li>iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。</li>\n<li>虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。</li>\n<li>一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。</li>\n<li>UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照<a href=\"UIButton选中状态下的点击\">https://www.jianshu.com/p/57b2c41448bf</a>。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>NSNumber类型判断是否为0不能使用<code>aIntegerNum == 0</code>，而应使用<code>[aIntegerNum isEqualToNumber:@0]</code>，前者比较地址，后者比较值。</li>\n<li>UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。</li>\n<li>时间戳转换时间时会相差8小时，需要计算时区。</li>\n<li>iOS10中UISwitch的特异性</li>\n<li>快速便利Array\\Set时，对元素进行操作必挂</li>\n<li>在block中使用成员变量，会导致循环引用</li>\n<li>iOS10以下导航栏问题<a href=\"导航栏隐藏 &amp;&amp; 导航栏错乱\">http://www.jianshu.com/p/e4448c24d900</a> <a href=\"iOS 隐藏导航栏导致导航栏错乱的那些坑\">http://www.jianshu.com/p/4b8af425a7d0</a></li>\n<li><p>__block相当于unsafe_unretain，在某些情况下，会导致crash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.string1 = @&quot;String 1&quot;;   </span><br><span class=\"line\">self.string2 = self.string1;   // unsafe_unretain</span><br><span class=\"line\">self.string1 = nil;  </span><br><span class=\"line\">NSLog(@&quot;String 2 = %@&quot;, self.string2);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。</p>\n</li>\n<li>A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad，拓展：<a href=\"https://www.jianshu.com/p/2ca25b1ebe5a\" target=\"_blank\" rel=\"noopener\">viewDidAppear和viewDidDisappear的执行顺序</a><a href=\"https://www.jianshu.com/p/9391b8043445\" target=\"_blank\" rel=\"noopener\">iOS–viewDidAppear和viewDidDisappear调用顺序</a>。</li>\n<li>iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。</li>\n<li>Notification在主线程中是同步执行的。</li>\n<li>若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。</li>\n<li>iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。</li>\n<li>虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。</li>\n<li>一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。</li>\n<li>UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照<a href=\"UIButton选中状态下的点击\">https://www.jianshu.com/p/57b2c41448bf</a>。</li>\n</ol>\n"},{"title":"研发效率-iOS常见warning梳理","date":"2018-07-26T09:57:20.000Z","_content":"# iOS常见warning梳理\n\n## 常见warning类型\n|warning类型 | 影响 | 修复方式 | 严重等级 |\n|---|---|---|\n| 方法有定义无实现 | crash | 补齐或删除方法 | P0 |\n| 调用不存在的方法 | crash | 调用正确方法 | P0 |\n| 调用系统DEPRECATED方法/属性 | crash、bug | 分系统进行调用 | P0 |\n| 方法调用中参数类型错误 | crash、bug | 转化对象类型 | P0 |\n| 赋值类型不一致 | crash、bug | 转化对象类型 | P0 |\n| 未调用super方法 | 内存泄漏、bug | 调用super | P0 |\n| 循环引用 | 内存泄漏 | weak strong dance | P0 |\n| 重名代理 | bug | 改名 | P1 |\n| 重名宏 | bug | 改名 | P1 |\n| 子类与父类有重名同类型属性 | bug | 删除其中一个 | P1 |\n| 子类与父类有重名不同类型属性 | bug | 子类添加忽略警告标记，@dynamic动态合成属性 | P1 |\n| 格式化输出类型不一致 | bug | 强制转换类型 | P1 |\n| @required代理未实现 | bug | 补齐代理方法 | P1 |\n| 工程未按推荐方式配置 | warning提示等级、编译选项等存在风险 | 更新到recommend settings | P1 |\n| MRC文件内存泄漏警告 | 性能浪费 | 修复代码或添加ARC标记 | P1 |\n| 临时变量无初始值 | bug | 赋初始值 | P1 |\n| 枚举赋值类型不一致 | bug | 修改代码 | P1 |\n| 非对象属性加了* | bug | 删除* | P1 |\n| 代码中包含非法字符 | 编译器无法识别 | 删除非法字符 | P1 |\n| Nullable/NonNull标记不全 | 产生大量warning | 删除或补全该文件内的标记 | P2 |\n| 未使用的临时变量 | 性能浪费 | 删除无用变量 | P2 |\n| 未使用的static变量 | 性能浪费 | 删除无用变量 | P2 |\n| 代理类未添加代理标记 | 类型检查警告 | 添加代理 | P2 |\n| performSelector | 不推荐使用的方法调用方式 | 直接调用方法 | P2 |\n| 第三方库最低版本与主工程不一致 | 编译警告 | 添加-w linker标记 | P2 |\n| .c文件的64/32位警告 | 编译警告 | 添加-Wno-shorten-64-to-32文件标记 | P2 |\n| import文件名大小写错误 | 无 | 修复文件名 | P3 |\n| 非法注释 | 注释格式不规范，无法快捷查看定义 | 使用系统快捷注释 | P3 |\n| block定义不规范 | 类型检查警告 | 补齐void | P3 |\n| 工程有文件引用但文件不存在 | 文件索引失败 | bug | P3 |\n| asset有索引无文件 | bug | 删除索引 | P3 |\n| search path存在，文件不存在 | 找不到索引 | 删除search path | P3 |\n\n## 修复warning的方式\n1. 根据编译器提示修复。\n2. 对于暂不修复的warning有三种忽略方式。\n2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。\n2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。\n2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。","source":"_posts/研发效率-iOS常见warning梳理.md","raw":"---\ntitle: 研发效率-iOS常见warning梳理\ndate: 2018-07-26 17:57:20\ncategories: 研发效率\ntags:\n    - warning\n---\n# iOS常见warning梳理\n\n## 常见warning类型\n|warning类型 | 影响 | 修复方式 | 严重等级 |\n|---|---|---|\n| 方法有定义无实现 | crash | 补齐或删除方法 | P0 |\n| 调用不存在的方法 | crash | 调用正确方法 | P0 |\n| 调用系统DEPRECATED方法/属性 | crash、bug | 分系统进行调用 | P0 |\n| 方法调用中参数类型错误 | crash、bug | 转化对象类型 | P0 |\n| 赋值类型不一致 | crash、bug | 转化对象类型 | P0 |\n| 未调用super方法 | 内存泄漏、bug | 调用super | P0 |\n| 循环引用 | 内存泄漏 | weak strong dance | P0 |\n| 重名代理 | bug | 改名 | P1 |\n| 重名宏 | bug | 改名 | P1 |\n| 子类与父类有重名同类型属性 | bug | 删除其中一个 | P1 |\n| 子类与父类有重名不同类型属性 | bug | 子类添加忽略警告标记，@dynamic动态合成属性 | P1 |\n| 格式化输出类型不一致 | bug | 强制转换类型 | P1 |\n| @required代理未实现 | bug | 补齐代理方法 | P1 |\n| 工程未按推荐方式配置 | warning提示等级、编译选项等存在风险 | 更新到recommend settings | P1 |\n| MRC文件内存泄漏警告 | 性能浪费 | 修复代码或添加ARC标记 | P1 |\n| 临时变量无初始值 | bug | 赋初始值 | P1 |\n| 枚举赋值类型不一致 | bug | 修改代码 | P1 |\n| 非对象属性加了* | bug | 删除* | P1 |\n| 代码中包含非法字符 | 编译器无法识别 | 删除非法字符 | P1 |\n| Nullable/NonNull标记不全 | 产生大量warning | 删除或补全该文件内的标记 | P2 |\n| 未使用的临时变量 | 性能浪费 | 删除无用变量 | P2 |\n| 未使用的static变量 | 性能浪费 | 删除无用变量 | P2 |\n| 代理类未添加代理标记 | 类型检查警告 | 添加代理 | P2 |\n| performSelector | 不推荐使用的方法调用方式 | 直接调用方法 | P2 |\n| 第三方库最低版本与主工程不一致 | 编译警告 | 添加-w linker标记 | P2 |\n| .c文件的64/32位警告 | 编译警告 | 添加-Wno-shorten-64-to-32文件标记 | P2 |\n| import文件名大小写错误 | 无 | 修复文件名 | P3 |\n| 非法注释 | 注释格式不规范，无法快捷查看定义 | 使用系统快捷注释 | P3 |\n| block定义不规范 | 类型检查警告 | 补齐void | P3 |\n| 工程有文件引用但文件不存在 | 文件索引失败 | bug | P3 |\n| asset有索引无文件 | bug | 删除索引 | P3 |\n| search path存在，文件不存在 | 找不到索引 | 删除search path | P3 |\n\n## 修复warning的方式\n1. 根据编译器提示修复。\n2. 对于暂不修复的warning有三种忽略方式。\n2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。\n2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。\n2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。","slug":"研发效率-iOS常见warning梳理","published":1,"updated":"2019-06-12T05:12:14.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwss6z69000q5mlwbv10z95w","content":"<h1 id=\"iOS常见warning梳理\"><a href=\"#iOS常见warning梳理\" class=\"headerlink\" title=\"iOS常见warning梳理\"></a>iOS常见warning梳理</h1><h2 id=\"常见warning类型\"><a href=\"#常见warning类型\" class=\"headerlink\" title=\"常见warning类型\"></a>常见warning类型</h2><table>\n<thead>\n<tr>\n<th>warning类型</th>\n<th>影响</th>\n<th>修复方式</th>\n<th>严重等级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方法有定义无实现</td>\n<td>crash</td>\n<td>补齐或删除方法</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>调用不存在的方法</td>\n<td>crash</td>\n<td>调用正确方法</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>调用系统DEPRECATED方法/属性</td>\n<td>crash、bug</td>\n<td>分系统进行调用</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>方法调用中参数类型错误</td>\n<td>crash、bug</td>\n<td>转化对象类型</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>赋值类型不一致</td>\n<td>crash、bug</td>\n<td>转化对象类型</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>未调用super方法</td>\n<td>内存泄漏、bug</td>\n<td>调用super</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>循环引用</td>\n<td>内存泄漏</td>\n<td>weak strong dance</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>重名代理</td>\n<td>bug</td>\n<td>改名</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>重名宏</td>\n<td>bug</td>\n<td>改名</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>子类与父类有重名同类型属性</td>\n<td>bug</td>\n<td>删除其中一个</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>子类与父类有重名不同类型属性</td>\n<td>bug</td>\n<td>子类添加忽略警告标记，@dynamic动态合成属性</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>格式化输出类型不一致</td>\n<td>bug</td>\n<td>强制转换类型</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>@required代理未实现</td>\n<td>bug</td>\n<td>补齐代理方法</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>工程未按推荐方式配置</td>\n<td>warning提示等级、编译选项等存在风险</td>\n<td>更新到recommend settings</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>MRC文件内存泄漏警告</td>\n<td>性能浪费</td>\n<td>修复代码或添加ARC标记</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>临时变量无初始值</td>\n<td>bug</td>\n<td>赋初始值</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>枚举赋值类型不一致</td>\n<td>bug</td>\n<td>修改代码</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>非对象属性加了*</td>\n<td>bug</td>\n<td>删除*</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>代码中包含非法字符</td>\n<td>编译器无法识别</td>\n<td>删除非法字符</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>Nullable/NonNull标记不全</td>\n<td>产生大量warning</td>\n<td>删除或补全该文件内的标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>未使用的临时变量</td>\n<td>性能浪费</td>\n<td>删除无用变量</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>未使用的static变量</td>\n<td>性能浪费</td>\n<td>删除无用变量</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>代理类未添加代理标记</td>\n<td>类型检查警告</td>\n<td>添加代理</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>performSelector</td>\n<td>不推荐使用的方法调用方式</td>\n<td>直接调用方法</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>第三方库最低版本与主工程不一致</td>\n<td>编译警告</td>\n<td>添加-w linker标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>.c文件的64/32位警告</td>\n<td>编译警告</td>\n<td>添加-Wno-shorten-64-to-32文件标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>import文件名大小写错误</td>\n<td>无</td>\n<td>修复文件名</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>非法注释</td>\n<td>注释格式不规范，无法快捷查看定义</td>\n<td>使用系统快捷注释</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>block定义不规范</td>\n<td>类型检查警告</td>\n<td>补齐void</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>工程有文件引用但文件不存在</td>\n<td>文件索引失败</td>\n<td>bug</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>asset有索引无文件</td>\n<td>bug</td>\n<td>删除索引</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>search path存在，文件不存在</td>\n<td>找不到索引</td>\n<td>删除search path</td>\n<td>P3</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修复warning的方式\"><a href=\"#修复warning的方式\" class=\"headerlink\" title=\"修复warning的方式\"></a>修复warning的方式</h2><ol>\n<li>根据编译器提示修复。</li>\n<li>对于暂不修复的warning有三种忽略方式。<br>2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。<br>2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。<br>2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS常见warning梳理\"><a href=\"#iOS常见warning梳理\" class=\"headerlink\" title=\"iOS常见warning梳理\"></a>iOS常见warning梳理</h1><h2 id=\"常见warning类型\"><a href=\"#常见warning类型\" class=\"headerlink\" title=\"常见warning类型\"></a>常见warning类型</h2><table>\n<thead>\n<tr>\n<th>warning类型</th>\n<th>影响</th>\n<th>修复方式</th>\n<th>严重等级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方法有定义无实现</td>\n<td>crash</td>\n<td>补齐或删除方法</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>调用不存在的方法</td>\n<td>crash</td>\n<td>调用正确方法</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>调用系统DEPRECATED方法/属性</td>\n<td>crash、bug</td>\n<td>分系统进行调用</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>方法调用中参数类型错误</td>\n<td>crash、bug</td>\n<td>转化对象类型</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>赋值类型不一致</td>\n<td>crash、bug</td>\n<td>转化对象类型</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>未调用super方法</td>\n<td>内存泄漏、bug</td>\n<td>调用super</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>循环引用</td>\n<td>内存泄漏</td>\n<td>weak strong dance</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>重名代理</td>\n<td>bug</td>\n<td>改名</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>重名宏</td>\n<td>bug</td>\n<td>改名</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>子类与父类有重名同类型属性</td>\n<td>bug</td>\n<td>删除其中一个</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>子类与父类有重名不同类型属性</td>\n<td>bug</td>\n<td>子类添加忽略警告标记，@dynamic动态合成属性</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>格式化输出类型不一致</td>\n<td>bug</td>\n<td>强制转换类型</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>@required代理未实现</td>\n<td>bug</td>\n<td>补齐代理方法</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>工程未按推荐方式配置</td>\n<td>warning提示等级、编译选项等存在风险</td>\n<td>更新到recommend settings</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>MRC文件内存泄漏警告</td>\n<td>性能浪费</td>\n<td>修复代码或添加ARC标记</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>临时变量无初始值</td>\n<td>bug</td>\n<td>赋初始值</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>枚举赋值类型不一致</td>\n<td>bug</td>\n<td>修改代码</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>非对象属性加了*</td>\n<td>bug</td>\n<td>删除*</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>代码中包含非法字符</td>\n<td>编译器无法识别</td>\n<td>删除非法字符</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>Nullable/NonNull标记不全</td>\n<td>产生大量warning</td>\n<td>删除或补全该文件内的标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>未使用的临时变量</td>\n<td>性能浪费</td>\n<td>删除无用变量</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>未使用的static变量</td>\n<td>性能浪费</td>\n<td>删除无用变量</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>代理类未添加代理标记</td>\n<td>类型检查警告</td>\n<td>添加代理</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>performSelector</td>\n<td>不推荐使用的方法调用方式</td>\n<td>直接调用方法</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>第三方库最低版本与主工程不一致</td>\n<td>编译警告</td>\n<td>添加-w linker标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>.c文件的64/32位警告</td>\n<td>编译警告</td>\n<td>添加-Wno-shorten-64-to-32文件标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>import文件名大小写错误</td>\n<td>无</td>\n<td>修复文件名</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>非法注释</td>\n<td>注释格式不规范，无法快捷查看定义</td>\n<td>使用系统快捷注释</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>block定义不规范</td>\n<td>类型检查警告</td>\n<td>补齐void</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>工程有文件引用但文件不存在</td>\n<td>文件索引失败</td>\n<td>bug</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>asset有索引无文件</td>\n<td>bug</td>\n<td>删除索引</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>search path存在，文件不存在</td>\n<td>找不到索引</td>\n<td>删除search path</td>\n<td>P3</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修复warning的方式\"><a href=\"#修复warning的方式\" class=\"headerlink\" title=\"修复warning的方式\"></a>修复warning的方式</h2><ol>\n<li>根据编译器提示修复。</li>\n<li>对于暂不修复的warning有三种忽略方式。<br>2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。<br>2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。<br>2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。</li>\n</ol>\n"},{"title":"开源库阅读笔记-YYModel","date":"2017-03-13T10:33:05.000Z","_content":"\nYYKit，作者ibireme，[Blog](http://blog.ibireme.com)，[YYKitDemo](https://github.com/ibireme/YYKit)。\n\n# YYModel\nYYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。\nJSON解析过程如下：\n1. 判空，获取class。\n2. 若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。\n3. 根据JSON转化Model。\n自定义class属于扩展功能，先分析JSON转化Model这一主要功能。\n\n## JSON转化Model\n此功能核心方法如下：\n```\n- (BOOL)modelSetWithDictionary:(NSDictionary *)dic {\n    if (!dic || dic == (id)kCFNull) return NO;\n    if (![dic isKindOfClass:[NSDictionary class]]) return NO;\n    \n    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];\n    if (modelMeta->_keyMappedCount == 0) return NO;\n    \n    if (modelMeta->_hasCustomWillTransformFromDictionary) {\n        dic = [((id<YYModel>)self) modelCustomWillTransformFromDictionary:dic];\n        if (![dic isKindOfClass:[NSDictionary class]]) return NO;\n    }\n    \n    ModelSetContext context = {0};\n    context.modelMeta = (__bridge void *)(modelMeta);\n    context.model = (__bridge void *)(self);\n    context.dictionary = (__bridge void *)(dic);\n    \n    if (modelMeta->_keyMappedCount >= CFDictionaryGetCount((CFDictionaryRef)dic)) {\n        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &context);\n        if (modelMeta->_keyPathPropertyMetas) {\n            CFArrayApplyFunction((CFArrayRef)modelMeta->_keyPathPropertyMetas,\n                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_keyPathPropertyMetas)),\n                                 ModelSetWithPropertyMetaArrayFunction,\n                                 &context);\n        }\n        if (modelMeta->_multiKeysPropertyMetas) {\n            CFArrayApplyFunction((CFArrayRef)modelMeta->_multiKeysPropertyMetas,\n                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_multiKeysPropertyMetas)),\n                                 ModelSetWithPropertyMetaArrayFunction,\n                                 &context);\n        }\n    } else {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_allPropertyMetas,\n                             CFRangeMake(0, modelMeta->_keyMappedCount),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n    \n    if (modelMeta->_hasCustomTransformFromDictionary) {\n        return [((id<YYModel>)self) modelCustomTransformFromDictionary:dic];\n    }\n    return YES;\n}\n```\n其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。\n\n### 异常处理\n首先对传入的NSDictionary进行了判空处理，如下。\n```\nif (!dic || dic == (id)kCFNull) return NO;\nif (![dic isKindOfClass:[NSDictionary class]]) return NO;\n```\n> 在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？\n> iOS中的空值类型有5种：nil\\Nil\\NULL\\NSNull\\kCFNull。\n> nil：指向一个实例对象的空指针。\n> Nil：指向一个类的空指针。\n> NULL：定义基本类型、C类型的空指针。\n> NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。\n> kCFNull：NSNull的单例。\n> 参考：[IOS 空值 nil Nil NULL NSNull kCFNull](http://www.jianshu.com/p/3aaefb3bcf73)\n\n### 获取元类\n```\n_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];\n```\n要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。\n> {% asset_img 对象模型图.png 对象模型图 %}\n> 可参考：[Objective-C中的类和对象](http://blog.ibireme.com/2013/11/25/objc-object/)\n> [object_getClass(obj)与[obj class]的区别](http://www.jianshu.com/p/ae5c32708bc6)\n> 测试代码如下：\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    TestClass *obj1 = [[TestClass alloc] init];\n    TestClass *obj2 = [[TestClass alloc] init];\n    \n    Class cls1 = object_getClass(obj1);\n    Class cls2 = object_getClass(cls1);\n    Class cls3 = object_getClass(cls2);\n    NSLog(@\"%@, %p\", obj1, obj1);\n    NSLog(@\"%@, %p\", cls1, cls1);\n    NSLog(@\"%@, %p\", cls2, cls2);\n    NSLog(@\"%@, %p\", cls3, cls3);\n    \n    Class cls4 = [obj1 class];\n    Class cls5 = [cls4 class];\n    Class cls6 = [cls5 class];\n    NSLog(@\"%@, %p\", obj2, obj2);\n    NSLog(@\"%@, %p\", cls4, cls4);\n    NSLog(@\"%@, %p\", cls5, cls5);\n    NSLog(@\"%@, %p\", cls6, cls6);\n    \n    Class cls7 = [cls1 class];\n    Class cls8 = [cls2 class];\n    Class cls9 = [cls3 class];\n    NSLog(@\"%@, %p\", cls7, cls7);\n    NSLog(@\"%@, %p\", cls8, cls8);\n    NSLog(@\"%@, %p\", cls9, cls9);\n}\n```\n> \n> 其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。\n> 结果如下：\n```\n2017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] <TestClass: 0x174007f90>, 0x174007f90\n2017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x100101258\n2017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8\n2017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] <TestClass: 0x174007fa0>, 0x174007fa0\n2017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x100101258\n2017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8\n```\n> \n> 可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。\n\n然后我们来看看YYModel中的元类`_YYModelMeta`，其数据结构如下：\n```\n@interface _YYModelMeta : NSObject {\n    @package\n    YYClassInfo *_classInfo;\n    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.\n    NSDictionary *_mapper;\n    /// Array<_YYModelPropertyMeta>, all property meta of this model.\n    NSArray *_allPropertyMetas;\n    /// Array<_YYModelPropertyMeta>, property meta which is mapped to a key path.\n    NSArray *_keyPathPropertyMetas;\n    /// Array<_YYModelPropertyMeta>, property meta which is mapped to multi keys.\n    NSArray *_multiKeysPropertyMetas;\n    /// The number of mapped key (and key path), same to _mapper.count.\n    NSUInteger _keyMappedCount;\n    /// Model class type.\n    YYEncodingNSType _nsType;\n    \n    BOOL _hasCustomWillTransformFromDictionary;\n    BOOL _hasCustomTransformFromDictionary;\n    BOOL _hasCustomTransformToDictionary;\n    BOOL _hasCustomClassFromDictionary;\n}\n@end\n```\n> Objective-C中有4种访问控制符：\n> @private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。\n> @package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。\n> @protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。\n> @public（公共访问权限）：成员可以在任意地方访问。\n\n`_YYModelMeta`存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给`_YYModelPropertyMeta`处理。\n```\n@interface _YYModelPropertyMeta : NSObject {\n    @package\n    NSString *_name;             ///< property's name\n    YYEncodingType _type;        ///< property's type\n    YYEncodingNSType _nsType;    ///< property's Foundation type\n    BOOL _isCNumber;             ///< is c number type\n    Class _cls;                  ///< property's class, or nil\n    Class _genericCls;           ///< container's generic class, or nil if threr's no generic class\n    SEL _getter;                 ///< getter, or nil if the instances cannot respond\n    SEL _setter;                 ///< setter, or nil if the instances cannot respond\n    BOOL _isKVCCompatible;       ///< YES if it can access with key-value coding\n    BOOL _isStructAvailableForKeyedArchiver; ///< YES if the struct can encoded with keyed archiver/unarchiver\n    BOOL _hasCustomClassFromDictionary; ///< class/generic class implements +modelCustomClassForDictionary:\n    \n    /*\n     property->key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil\n     property->keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil\n     property->keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)\n     */\n    NSString *_mappedToKey;      ///< the key mapped to\n    NSArray *_mappedToKeyPath;   ///< the key path mapped to (nil if the name is not key path)\n    NSArray *_mappedToKeyArray;  ///< the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys)\n    YYClassPropertyInfo *_info;  ///< property's info\n    _YYModelPropertyMeta *_next; ///< next meta if there are multiple properties mapped to the same key.\n}\n@end\n\n@interface YYClassPropertyInfo : NSObject\n@property (nonatomic, assign, readonly) objc_property_t property; ///< property's opaque struct\n@property (nonatomic, strong, readonly) NSString *name;           ///< property's name\n@property (nonatomic, assign, readonly) YYEncodingType type;      ///< property's type\n@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///< property's encoding value\n@property (nonatomic, strong, readonly) NSString *ivarName;       ///< property's ivar name\n@property (nullable, nonatomic, assign, readonly) Class cls;      ///< may be nil\n@property (nullable, nonatomic, strong, readonly) NSArray<NSString *> *protocols; ///< may nil\n@property (nonatomic, assign, readonly) SEL getter;               ///< getter (nonnull)\n@property (nonatomic, assign, readonly) SEL setter;               ///< setter (nonnull)\n@end\n```\n\n`YYClassInfo`则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。\n```\n@interface YYClassInfo : NSObject\n@property (nonatomic, assign, readonly) Class cls; ///< class object\n@property (nullable, nonatomic, assign, readonly) Class superCls; ///< super class object\n@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///< class's meta class object\n@property (nonatomic, readonly) BOOL isMeta; ///< whether this class is meta class\n@property (nonatomic, strong, readonly) NSString *name; ///< class name\n@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///< super class's class info\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassIvarInfo *> *ivarInfos; ///< ivars\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassMethodInfo *> *methodInfos; ///< methods\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassPropertyInfo *> *propertyInfos; ///< properties\n\n- (void)setNeedUpdate;\n- (BOOL)needUpdate;\n+ (nullable instancetype)classInfoWithClass:(Class)cls;\n+ (nullable instancetype)classInfoWithClassName:(NSString *)className;\n@end\n```\n> ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。\n\n随后通过`+ (instancetype)metaWithClass:(Class)cls;`进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下：\n> 1. [CFMutableDictionaryRef](https://developer.apple.com/reference/corefoundation/cfmutabledictionary-rpl)是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要\n> 2. dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看[资料1](http://www.jianshu.com/p/a84c2bf0d77b)[资料2](http://blog.ibireme.com/2015/10/26/yycache/)\n> 3. 两个时间宏\n> #define DISPATCH_TIME_NOW (0ull)\n> #define DISPATCH_TIME_FOREVER (~0ull)\n> 0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数\n\n真正的初始化方法是`- (instancetype)initWithClass:(Class)cls;`，其流程如下：\n1. 获取YYClassInfo。\n2. 获取黑名单。\n3. 获取白名单。\n4. 获取用户自定义属性。\n5. 循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入`_allPropertyMetas`、`_keyPathPropertyMetas`、`_multiKeysPropertyMetas`。\n6. 设置属性映射mapper。\n\n至此已获取YYModel元类，包括key/value属性映射关系，回到`- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;`进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。\n```\nModelSetContext context = {0};\ncontext.modelMeta = (__bridge void *)(modelMeta);\ncontext.model = (__bridge void *)(self);\ncontext.dictionary = (__bridge void *)(dic);\n\nif (modelMeta->_keyMappedCount >= CFDictionaryGetCount((CFDictionaryRef)dic)) {\n    CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &context);\n    if (modelMeta->_keyPathPropertyMetas) {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_keyPathPropertyMetas,\n                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_keyPathPropertyMetas)),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n    if (modelMeta->_multiKeysPropertyMetas) {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_multiKeysPropertyMetas,\n                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_multiKeysPropertyMetas)),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n} else {\n    CFArrayApplyFunction((CFArrayRef)modelMeta->_allPropertyMetas,\n                         CFRangeMake(0, modelMeta->_keyMappedCount),\n                         ModelSetWithPropertyMetaArrayFunction,\n                         &context);\n}\n\ntypedef struct {\n    void *modelMeta;  ///< _YYModelMeta\n    void *model;      ///< id (self)\n    void *dictionary; ///< NSDictionary (json)\n} ModelSetContext;\n```\n> SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。\n> IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。\n> \n> KVC(key value coding)\n> KVC涉及以下4个方法\n```\n- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值\n- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值\n- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值\n- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值\n```\n> [iOS开发技巧系列---详解KVC](http://www.jianshu.com/p/45cbd324ea65)\n> \n> KVO(key value obeserveing)\n> KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。\n```\n- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;\n- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;\n```\n> [IOS 开发中的KVC 和KVO](http://www.jianshu.com/p/c1dd046d9ce2)\n\n扩展阅读：\n[看 YYModel 源码的一些收获](http://www.cocoachina.com/cms/wap.php?action=article&id=17874)\n> 性能优化Tip\n> 缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。\n> 查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。\n> 避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。\n> 避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。\n> 避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。\n> 遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。\n> 尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。\n> 减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。","source":"_posts/开源库阅读笔记-YYModel.md","raw":"---\ntitle: 开源库阅读笔记-YYModel\ndate: 2017-03-13 18:33:05\ncategories: 开源库阅读笔记\ntags: \n    - YYModel\n---\n\nYYKit，作者ibireme，[Blog](http://blog.ibireme.com)，[YYKitDemo](https://github.com/ibireme/YYKit)。\n\n# YYModel\nYYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。\nJSON解析过程如下：\n1. 判空，获取class。\n2. 若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。\n3. 根据JSON转化Model。\n自定义class属于扩展功能，先分析JSON转化Model这一主要功能。\n\n## JSON转化Model\n此功能核心方法如下：\n```\n- (BOOL)modelSetWithDictionary:(NSDictionary *)dic {\n    if (!dic || dic == (id)kCFNull) return NO;\n    if (![dic isKindOfClass:[NSDictionary class]]) return NO;\n    \n    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];\n    if (modelMeta->_keyMappedCount == 0) return NO;\n    \n    if (modelMeta->_hasCustomWillTransformFromDictionary) {\n        dic = [((id<YYModel>)self) modelCustomWillTransformFromDictionary:dic];\n        if (![dic isKindOfClass:[NSDictionary class]]) return NO;\n    }\n    \n    ModelSetContext context = {0};\n    context.modelMeta = (__bridge void *)(modelMeta);\n    context.model = (__bridge void *)(self);\n    context.dictionary = (__bridge void *)(dic);\n    \n    if (modelMeta->_keyMappedCount >= CFDictionaryGetCount((CFDictionaryRef)dic)) {\n        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &context);\n        if (modelMeta->_keyPathPropertyMetas) {\n            CFArrayApplyFunction((CFArrayRef)modelMeta->_keyPathPropertyMetas,\n                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_keyPathPropertyMetas)),\n                                 ModelSetWithPropertyMetaArrayFunction,\n                                 &context);\n        }\n        if (modelMeta->_multiKeysPropertyMetas) {\n            CFArrayApplyFunction((CFArrayRef)modelMeta->_multiKeysPropertyMetas,\n                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_multiKeysPropertyMetas)),\n                                 ModelSetWithPropertyMetaArrayFunction,\n                                 &context);\n        }\n    } else {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_allPropertyMetas,\n                             CFRangeMake(0, modelMeta->_keyMappedCount),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n    \n    if (modelMeta->_hasCustomTransformFromDictionary) {\n        return [((id<YYModel>)self) modelCustomTransformFromDictionary:dic];\n    }\n    return YES;\n}\n```\n其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。\n\n### 异常处理\n首先对传入的NSDictionary进行了判空处理，如下。\n```\nif (!dic || dic == (id)kCFNull) return NO;\nif (![dic isKindOfClass:[NSDictionary class]]) return NO;\n```\n> 在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？\n> iOS中的空值类型有5种：nil\\Nil\\NULL\\NSNull\\kCFNull。\n> nil：指向一个实例对象的空指针。\n> Nil：指向一个类的空指针。\n> NULL：定义基本类型、C类型的空指针。\n> NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。\n> kCFNull：NSNull的单例。\n> 参考：[IOS 空值 nil Nil NULL NSNull kCFNull](http://www.jianshu.com/p/3aaefb3bcf73)\n\n### 获取元类\n```\n_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];\n```\n要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。\n> {% asset_img 对象模型图.png 对象模型图 %}\n> 可参考：[Objective-C中的类和对象](http://blog.ibireme.com/2013/11/25/objc-object/)\n> [object_getClass(obj)与[obj class]的区别](http://www.jianshu.com/p/ae5c32708bc6)\n> 测试代码如下：\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    TestClass *obj1 = [[TestClass alloc] init];\n    TestClass *obj2 = [[TestClass alloc] init];\n    \n    Class cls1 = object_getClass(obj1);\n    Class cls2 = object_getClass(cls1);\n    Class cls3 = object_getClass(cls2);\n    NSLog(@\"%@, %p\", obj1, obj1);\n    NSLog(@\"%@, %p\", cls1, cls1);\n    NSLog(@\"%@, %p\", cls2, cls2);\n    NSLog(@\"%@, %p\", cls3, cls3);\n    \n    Class cls4 = [obj1 class];\n    Class cls5 = [cls4 class];\n    Class cls6 = [cls5 class];\n    NSLog(@\"%@, %p\", obj2, obj2);\n    NSLog(@\"%@, %p\", cls4, cls4);\n    NSLog(@\"%@, %p\", cls5, cls5);\n    NSLog(@\"%@, %p\", cls6, cls6);\n    \n    Class cls7 = [cls1 class];\n    Class cls8 = [cls2 class];\n    Class cls9 = [cls3 class];\n    NSLog(@\"%@, %p\", cls7, cls7);\n    NSLog(@\"%@, %p\", cls8, cls8);\n    NSLog(@\"%@, %p\", cls9, cls9);\n}\n```\n> \n> 其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。\n> 结果如下：\n```\n2017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] <TestClass: 0x174007f90>, 0x174007f90\n2017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x100101258\n2017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8\n2017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] <TestClass: 0x174007fa0>, 0x174007fa0\n2017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x100101258\n2017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8\n```\n> \n> 可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。\n\n然后我们来看看YYModel中的元类`_YYModelMeta`，其数据结构如下：\n```\n@interface _YYModelMeta : NSObject {\n    @package\n    YYClassInfo *_classInfo;\n    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.\n    NSDictionary *_mapper;\n    /// Array<_YYModelPropertyMeta>, all property meta of this model.\n    NSArray *_allPropertyMetas;\n    /// Array<_YYModelPropertyMeta>, property meta which is mapped to a key path.\n    NSArray *_keyPathPropertyMetas;\n    /// Array<_YYModelPropertyMeta>, property meta which is mapped to multi keys.\n    NSArray *_multiKeysPropertyMetas;\n    /// The number of mapped key (and key path), same to _mapper.count.\n    NSUInteger _keyMappedCount;\n    /// Model class type.\n    YYEncodingNSType _nsType;\n    \n    BOOL _hasCustomWillTransformFromDictionary;\n    BOOL _hasCustomTransformFromDictionary;\n    BOOL _hasCustomTransformToDictionary;\n    BOOL _hasCustomClassFromDictionary;\n}\n@end\n```\n> Objective-C中有4种访问控制符：\n> @private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。\n> @package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。\n> @protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。\n> @public（公共访问权限）：成员可以在任意地方访问。\n\n`_YYModelMeta`存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给`_YYModelPropertyMeta`处理。\n```\n@interface _YYModelPropertyMeta : NSObject {\n    @package\n    NSString *_name;             ///< property's name\n    YYEncodingType _type;        ///< property's type\n    YYEncodingNSType _nsType;    ///< property's Foundation type\n    BOOL _isCNumber;             ///< is c number type\n    Class _cls;                  ///< property's class, or nil\n    Class _genericCls;           ///< container's generic class, or nil if threr's no generic class\n    SEL _getter;                 ///< getter, or nil if the instances cannot respond\n    SEL _setter;                 ///< setter, or nil if the instances cannot respond\n    BOOL _isKVCCompatible;       ///< YES if it can access with key-value coding\n    BOOL _isStructAvailableForKeyedArchiver; ///< YES if the struct can encoded with keyed archiver/unarchiver\n    BOOL _hasCustomClassFromDictionary; ///< class/generic class implements +modelCustomClassForDictionary:\n    \n    /*\n     property->key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil\n     property->keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil\n     property->keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)\n     */\n    NSString *_mappedToKey;      ///< the key mapped to\n    NSArray *_mappedToKeyPath;   ///< the key path mapped to (nil if the name is not key path)\n    NSArray *_mappedToKeyArray;  ///< the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys)\n    YYClassPropertyInfo *_info;  ///< property's info\n    _YYModelPropertyMeta *_next; ///< next meta if there are multiple properties mapped to the same key.\n}\n@end\n\n@interface YYClassPropertyInfo : NSObject\n@property (nonatomic, assign, readonly) objc_property_t property; ///< property's opaque struct\n@property (nonatomic, strong, readonly) NSString *name;           ///< property's name\n@property (nonatomic, assign, readonly) YYEncodingType type;      ///< property's type\n@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///< property's encoding value\n@property (nonatomic, strong, readonly) NSString *ivarName;       ///< property's ivar name\n@property (nullable, nonatomic, assign, readonly) Class cls;      ///< may be nil\n@property (nullable, nonatomic, strong, readonly) NSArray<NSString *> *protocols; ///< may nil\n@property (nonatomic, assign, readonly) SEL getter;               ///< getter (nonnull)\n@property (nonatomic, assign, readonly) SEL setter;               ///< setter (nonnull)\n@end\n```\n\n`YYClassInfo`则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。\n```\n@interface YYClassInfo : NSObject\n@property (nonatomic, assign, readonly) Class cls; ///< class object\n@property (nullable, nonatomic, assign, readonly) Class superCls; ///< super class object\n@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///< class's meta class object\n@property (nonatomic, readonly) BOOL isMeta; ///< whether this class is meta class\n@property (nonatomic, strong, readonly) NSString *name; ///< class name\n@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///< super class's class info\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassIvarInfo *> *ivarInfos; ///< ivars\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassMethodInfo *> *methodInfos; ///< methods\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassPropertyInfo *> *propertyInfos; ///< properties\n\n- (void)setNeedUpdate;\n- (BOOL)needUpdate;\n+ (nullable instancetype)classInfoWithClass:(Class)cls;\n+ (nullable instancetype)classInfoWithClassName:(NSString *)className;\n@end\n```\n> ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。\n\n随后通过`+ (instancetype)metaWithClass:(Class)cls;`进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下：\n> 1. [CFMutableDictionaryRef](https://developer.apple.com/reference/corefoundation/cfmutabledictionary-rpl)是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要\n> 2. dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看[资料1](http://www.jianshu.com/p/a84c2bf0d77b)[资料2](http://blog.ibireme.com/2015/10/26/yycache/)\n> 3. 两个时间宏\n> #define DISPATCH_TIME_NOW (0ull)\n> #define DISPATCH_TIME_FOREVER (~0ull)\n> 0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数\n\n真正的初始化方法是`- (instancetype)initWithClass:(Class)cls;`，其流程如下：\n1. 获取YYClassInfo。\n2. 获取黑名单。\n3. 获取白名单。\n4. 获取用户自定义属性。\n5. 循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入`_allPropertyMetas`、`_keyPathPropertyMetas`、`_multiKeysPropertyMetas`。\n6. 设置属性映射mapper。\n\n至此已获取YYModel元类，包括key/value属性映射关系，回到`- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;`进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。\n```\nModelSetContext context = {0};\ncontext.modelMeta = (__bridge void *)(modelMeta);\ncontext.model = (__bridge void *)(self);\ncontext.dictionary = (__bridge void *)(dic);\n\nif (modelMeta->_keyMappedCount >= CFDictionaryGetCount((CFDictionaryRef)dic)) {\n    CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &context);\n    if (modelMeta->_keyPathPropertyMetas) {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_keyPathPropertyMetas,\n                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_keyPathPropertyMetas)),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n    if (modelMeta->_multiKeysPropertyMetas) {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_multiKeysPropertyMetas,\n                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_multiKeysPropertyMetas)),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n} else {\n    CFArrayApplyFunction((CFArrayRef)modelMeta->_allPropertyMetas,\n                         CFRangeMake(0, modelMeta->_keyMappedCount),\n                         ModelSetWithPropertyMetaArrayFunction,\n                         &context);\n}\n\ntypedef struct {\n    void *modelMeta;  ///< _YYModelMeta\n    void *model;      ///< id (self)\n    void *dictionary; ///< NSDictionary (json)\n} ModelSetContext;\n```\n> SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。\n> IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。\n> \n> KVC(key value coding)\n> KVC涉及以下4个方法\n```\n- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值\n- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值\n- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值\n- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值\n```\n> [iOS开发技巧系列---详解KVC](http://www.jianshu.com/p/45cbd324ea65)\n> \n> KVO(key value obeserveing)\n> KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。\n```\n- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;\n- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;\n```\n> [IOS 开发中的KVC 和KVO](http://www.jianshu.com/p/c1dd046d9ce2)\n\n扩展阅读：\n[看 YYModel 源码的一些收获](http://www.cocoachina.com/cms/wap.php?action=article&id=17874)\n> 性能优化Tip\n> 缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。\n> 查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。\n> 避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。\n> 避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。\n> 避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。\n> 遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。\n> 尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。\n> 减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。","slug":"开源库阅读笔记-YYModel","published":1,"updated":"2019-06-12T05:45:26.829Z","_id":"cjwss6z6a000t5mlwibziqrxw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>YYKit，作者ibireme，<a href=\"http://blog.ibireme.com\" target=\"_blank\" rel=\"noopener\">Blog</a>，<a href=\"https://github.com/ibireme/YYKit\" target=\"_blank\" rel=\"noopener\">YYKitDemo</a>。</p>\n<h1 id=\"YYModel\"><a href=\"#YYModel\" class=\"headerlink\" title=\"YYModel\"></a>YYModel</h1><p>YYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。<br>JSON解析过程如下：</p>\n<ol>\n<li>判空，获取class。</li>\n<li>若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。</li>\n<li>根据JSON转化Model。<br>自定义class属于扩展功能，先分析JSON转化Model这一主要功能。</li>\n</ol>\n<h2 id=\"JSON转化Model\"><a href=\"#JSON转化Model\" class=\"headerlink\" title=\"JSON转化Model\"></a>JSON转化Model</h2><p>此功能核心方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)modelSetWithDictionary:(NSDictionary *)dic &#123;</span><br><span class=\"line\">    if (!dic || dic == (id)kCFNull) return NO;</span><br><span class=\"line\">    if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br><span class=\"line\">    if (modelMeta-&gt;_keyMappedCount == 0) return NO;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class=\"line\">        dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic];</span><br><span class=\"line\">        if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ModelSetContext context = &#123;0&#125;;</span><br><span class=\"line\">    context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class=\"line\">    context.model = (__bridge void *)(self);</span><br><span class=\"line\">    context.dictionary = (__bridge void *)(dic);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class=\"line\">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class=\"line\">        if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class=\"line\">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class=\"line\">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class=\"line\">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                                 &amp;context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class=\"line\">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class=\"line\">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class=\"line\">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                                 &amp;context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class=\"line\">        return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。</p>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>首先对传入的NSDictionary进行了判空处理，如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!dic || dic == (id)kCFNull) return NO;</span><br><span class=\"line\">if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？<br>iOS中的空值类型有5种：nil\\Nil\\NULL\\NSNull\\kCFNull。<br>nil：指向一个实例对象的空指针。<br>Nil：指向一个类的空指针。<br>NULL：定义基本类型、C类型的空指针。<br>NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。<br>kCFNull：NSNull的单例。<br>参考：<a href=\"http://www.jianshu.com/p/3aaefb3bcf73\" target=\"_blank\" rel=\"noopener\">IOS 空值 nil Nil NULL NSNull kCFNull</a></p>\n</blockquote>\n<h3 id=\"获取元类\"><a href=\"#获取元类\" class=\"headerlink\" title=\"获取元类\"></a>获取元类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br></pre></td></tr></table></figure>\n<p>要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。</p>\n<blockquote>\n\n<p>可参考：<a href=\"http://blog.ibireme.com/2013/11/25/objc-object/\" target=\"_blank\" rel=\"noopener\">Objective-C中的类和对象</a><br><a href=\"http://www.jianshu.com/p/ae5c32708bc6\" target=\"_blank\" rel=\"noopener\">object_getClass(obj)与[obj class]的区别</a><br>测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    TestClass *obj1 = [[TestClass alloc] init];</span><br><span class=\"line\">    TestClass *obj2 = [[TestClass alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls1 = object_getClass(obj1);</span><br><span class=\"line\">    Class cls2 = object_getClass(cls1);</span><br><span class=\"line\">    Class cls3 = object_getClass(cls2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, obj1, obj1);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls1, cls1);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls2, cls2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls3, cls3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls4 = [obj1 class];</span><br><span class=\"line\">    Class cls5 = [cls4 class];</span><br><span class=\"line\">    Class cls6 = [cls5 class];</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, obj2, obj2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls4, cls4);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls5, cls5);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls6, cls6);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls7 = [cls1 class];</span><br><span class=\"line\">    Class cls8 = [cls2 class];</span><br><span class=\"line\">    Class cls9 = [cls3 class];</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls7, cls7);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls8, cls8);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls9, cls9);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。<br>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007f90&gt;, 0x174007f90</span><br><span class=\"line\">2017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x100101258</span><br><span class=\"line\">2017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8</span><br><span class=\"line\">2017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007fa0&gt;, 0x174007fa0</span><br><span class=\"line\">2017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x100101258</span><br><span class=\"line\">2017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。</p>\n</blockquote>\n<p>然后我们来看看YYModel中的元类<code>_YYModelMeta</code>，其数据结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface _YYModelMeta : NSObject &#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    YYClassInfo *_classInfo;</span><br><span class=\"line\">    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.</span><br><span class=\"line\">    NSDictionary *_mapper;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, all property meta of this model.</span><br><span class=\"line\">    NSArray *_allPropertyMetas;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to a key path.</span><br><span class=\"line\">    NSArray *_keyPathPropertyMetas;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to multi keys.</span><br><span class=\"line\">    NSArray *_multiKeysPropertyMetas;</span><br><span class=\"line\">    /// The number of mapped key (and key path), same to _mapper.count.</span><br><span class=\"line\">    NSUInteger _keyMappedCount;</span><br><span class=\"line\">    /// Model class type.</span><br><span class=\"line\">    YYEncodingNSType _nsType;</span><br><span class=\"line\">    </span><br><span class=\"line\">    BOOL _hasCustomWillTransformFromDictionary;</span><br><span class=\"line\">    BOOL _hasCustomTransformFromDictionary;</span><br><span class=\"line\">    BOOL _hasCustomTransformToDictionary;</span><br><span class=\"line\">    BOOL _hasCustomClassFromDictionary;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Objective-C中有4种访问控制符：<br>@private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。<br>@package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。<br>@protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。<br>@public（公共访问权限）：成员可以在任意地方访问。</p>\n</blockquote>\n<p><code>_YYModelMeta</code>存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给<code>_YYModelPropertyMeta</code>处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface _YYModelPropertyMeta : NSObject &#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    NSString *_name;             ///&lt; property&apos;s name</span><br><span class=\"line\">    YYEncodingType _type;        ///&lt; property&apos;s type</span><br><span class=\"line\">    YYEncodingNSType _nsType;    ///&lt; property&apos;s Foundation type</span><br><span class=\"line\">    BOOL _isCNumber;             ///&lt; is c number type</span><br><span class=\"line\">    Class _cls;                  ///&lt; property&apos;s class, or nil</span><br><span class=\"line\">    Class _genericCls;           ///&lt; container&apos;s generic class, or nil if threr&apos;s no generic class</span><br><span class=\"line\">    SEL _getter;                 ///&lt; getter, or nil if the instances cannot respond</span><br><span class=\"line\">    SEL _setter;                 ///&lt; setter, or nil if the instances cannot respond</span><br><span class=\"line\">    BOOL _isKVCCompatible;       ///&lt; YES if it can access with key-value coding</span><br><span class=\"line\">    BOOL _isStructAvailableForKeyedArchiver; ///&lt; YES if the struct can encoded with keyed archiver/unarchiver</span><br><span class=\"line\">    BOOL _hasCustomClassFromDictionary; ///&lt; class/generic class implements +modelCustomClassForDictionary:</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     property-&gt;key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil</span><br><span class=\"line\">     property-&gt;keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil</span><br><span class=\"line\">     property-&gt;keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    NSString *_mappedToKey;      ///&lt; the key mapped to</span><br><span class=\"line\">    NSArray *_mappedToKeyPath;   ///&lt; the key path mapped to (nil if the name is not key path)</span><br><span class=\"line\">    NSArray *_mappedToKeyArray;  ///&lt; the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys)</span><br><span class=\"line\">    YYClassPropertyInfo *_info;  ///&lt; property&apos;s info</span><br><span class=\"line\">    _YYModelPropertyMeta *_next; ///&lt; next meta if there are multiple properties mapped to the same key.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface YYClassPropertyInfo : NSObject</span><br><span class=\"line\">@property (nonatomic, assign, readonly) objc_property_t property; ///&lt; property&apos;s opaque struct</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *name;           ///&lt; property&apos;s name</span><br><span class=\"line\">@property (nonatomic, assign, readonly) YYEncodingType type;      ///&lt; property&apos;s type</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///&lt; property&apos;s encoding value</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *ivarName;       ///&lt; property&apos;s ivar name</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class cls;      ///&lt; may be nil</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols; ///&lt; may nil</span><br><span class=\"line\">@property (nonatomic, assign, readonly) SEL getter;               ///&lt; getter (nonnull)</span><br><span class=\"line\">@property (nonatomic, assign, readonly) SEL setter;               ///&lt; setter (nonnull)</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p><code>YYClassInfo</code>则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface YYClassInfo : NSObject</span><br><span class=\"line\">@property (nonatomic, assign, readonly) Class cls; ///&lt; class object</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class superCls; ///&lt; super class object</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///&lt; class&apos;s meta class object</span><br><span class=\"line\">@property (nonatomic, readonly) BOOL isMeta; ///&lt; whether this class is meta class</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *name; ///&lt; class name</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///&lt; super class&apos;s class info</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos; ///&lt; ivars</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos; ///&lt; methods</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos; ///&lt; properties</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setNeedUpdate;</span><br><span class=\"line\">- (BOOL)needUpdate;</span><br><span class=\"line\">+ (nullable instancetype)classInfoWithClass:(Class)cls;</span><br><span class=\"line\">+ (nullable instancetype)classInfoWithClassName:(NSString *)className;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。</p>\n</blockquote>\n<p>随后通过<code>+ (instancetype)metaWithClass:(Class)cls;</code>进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下：</p>\n<blockquote>\n<ol>\n<li><a href=\"https://developer.apple.com/reference/corefoundation/cfmutabledictionary-rpl\" target=\"_blank\" rel=\"noopener\">CFMutableDictionaryRef</a>是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要</li>\n<li>dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看<a href=\"http://www.jianshu.com/p/a84c2bf0d77b\" target=\"_blank\" rel=\"noopener\">资料1</a><a href=\"http://blog.ibireme.com/2015/10/26/yycache/\" target=\"_blank\" rel=\"noopener\">资料2</a></li>\n<li>两个时间宏<br>#define DISPATCH_TIME_NOW (0ull)<br>#define DISPATCH_TIME_FOREVER (~0ull)<br>0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数</li>\n</ol>\n</blockquote>\n<p>真正的初始化方法是<code>- (instancetype)initWithClass:(Class)cls;</code>，其流程如下：</p>\n<ol>\n<li>获取YYClassInfo。</li>\n<li>获取黑名单。</li>\n<li>获取白名单。</li>\n<li>获取用户自定义属性。</li>\n<li>循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入<code>_allPropertyMetas</code>、<code>_keyPathPropertyMetas</code>、<code>_multiKeysPropertyMetas</code>。</li>\n<li>设置属性映射mapper。</li>\n</ol>\n<p>至此已获取YYModel元类，包括key/value属性映射关系，回到<code>- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;</code>进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ModelSetContext context = &#123;0&#125;;</span><br><span class=\"line\">context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class=\"line\">context.model = (__bridge void *)(self);</span><br><span class=\"line\">context.dictionary = (__bridge void *)(dic);</span><br><span class=\"line\"></span><br><span class=\"line\">if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class=\"line\">    CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class=\"line\">    if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class=\"line\">                         CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class=\"line\">                         ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                         &amp;context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    void *modelMeta;  ///&lt; _YYModelMeta</span><br><span class=\"line\">    void *model;      ///&lt; id (self)</span><br><span class=\"line\">    void *dictionary; ///&lt; NSDictionary (json)</span><br><span class=\"line\">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。<br>IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。</p>\n<p>KVC(key value coding)<br>KVC涉及以下4个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值</span><br><span class=\"line\">- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值</span><br><span class=\"line\">- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值</span><br><span class=\"line\">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/45cbd324ea65\" target=\"_blank\" rel=\"noopener\">iOS开发技巧系列—详解KVC</a></p>\n<p>KVO(key value obeserveing)<br>KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class=\"line\">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/c1dd046d9ce2\" target=\"_blank\" rel=\"noopener\">IOS 开发中的KVC 和KVO</a></p>\n</blockquote>\n<p>扩展阅读：<br><a href=\"http://www.cocoachina.com/cms/wap.php?action=article&amp;id=17874\" target=\"_blank\" rel=\"noopener\">看 YYModel 源码的一些收获</a></p>\n<blockquote>\n<p>性能优化Tip<br>缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。<br>查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。<br>避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。<br>避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。<br>避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。<br>遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。<br>尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。<br>减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>YYKit，作者ibireme，<a href=\"http://blog.ibireme.com\" target=\"_blank\" rel=\"noopener\">Blog</a>，<a href=\"https://github.com/ibireme/YYKit\" target=\"_blank\" rel=\"noopener\">YYKitDemo</a>。</p>\n<h1 id=\"YYModel\"><a href=\"#YYModel\" class=\"headerlink\" title=\"YYModel\"></a>YYModel</h1><p>YYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。<br>JSON解析过程如下：</p>\n<ol>\n<li>判空，获取class。</li>\n<li>若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。</li>\n<li>根据JSON转化Model。<br>自定义class属于扩展功能，先分析JSON转化Model这一主要功能。</li>\n</ol>\n<h2 id=\"JSON转化Model\"><a href=\"#JSON转化Model\" class=\"headerlink\" title=\"JSON转化Model\"></a>JSON转化Model</h2><p>此功能核心方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)modelSetWithDictionary:(NSDictionary *)dic &#123;</span><br><span class=\"line\">    if (!dic || dic == (id)kCFNull) return NO;</span><br><span class=\"line\">    if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br><span class=\"line\">    if (modelMeta-&gt;_keyMappedCount == 0) return NO;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class=\"line\">        dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic];</span><br><span class=\"line\">        if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ModelSetContext context = &#123;0&#125;;</span><br><span class=\"line\">    context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class=\"line\">    context.model = (__bridge void *)(self);</span><br><span class=\"line\">    context.dictionary = (__bridge void *)(dic);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class=\"line\">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class=\"line\">        if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class=\"line\">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class=\"line\">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class=\"line\">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                                 &amp;context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class=\"line\">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class=\"line\">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class=\"line\">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                                 &amp;context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class=\"line\">        return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。</p>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>首先对传入的NSDictionary进行了判空处理，如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!dic || dic == (id)kCFNull) return NO;</span><br><span class=\"line\">if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？<br>iOS中的空值类型有5种：nil\\Nil\\NULL\\NSNull\\kCFNull。<br>nil：指向一个实例对象的空指针。<br>Nil：指向一个类的空指针。<br>NULL：定义基本类型、C类型的空指针。<br>NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。<br>kCFNull：NSNull的单例。<br>参考：<a href=\"http://www.jianshu.com/p/3aaefb3bcf73\" target=\"_blank\" rel=\"noopener\">IOS 空值 nil Nil NULL NSNull kCFNull</a></p>\n</blockquote>\n<h3 id=\"获取元类\"><a href=\"#获取元类\" class=\"headerlink\" title=\"获取元类\"></a>获取元类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br></pre></td></tr></table></figure>\n<p>要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。</p>\n<blockquote>\n\n<p>可参考：<a href=\"http://blog.ibireme.com/2013/11/25/objc-object/\" target=\"_blank\" rel=\"noopener\">Objective-C中的类和对象</a><br><a href=\"http://www.jianshu.com/p/ae5c32708bc6\" target=\"_blank\" rel=\"noopener\">object_getClass(obj)与[obj class]的区别</a><br>测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    TestClass *obj1 = [[TestClass alloc] init];</span><br><span class=\"line\">    TestClass *obj2 = [[TestClass alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls1 = object_getClass(obj1);</span><br><span class=\"line\">    Class cls2 = object_getClass(cls1);</span><br><span class=\"line\">    Class cls3 = object_getClass(cls2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, obj1, obj1);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls1, cls1);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls2, cls2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls3, cls3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls4 = [obj1 class];</span><br><span class=\"line\">    Class cls5 = [cls4 class];</span><br><span class=\"line\">    Class cls6 = [cls5 class];</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, obj2, obj2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls4, cls4);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls5, cls5);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls6, cls6);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls7 = [cls1 class];</span><br><span class=\"line\">    Class cls8 = [cls2 class];</span><br><span class=\"line\">    Class cls9 = [cls3 class];</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls7, cls7);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls8, cls8);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls9, cls9);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。<br>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007f90&gt;, 0x174007f90</span><br><span class=\"line\">2017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x100101258</span><br><span class=\"line\">2017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8</span><br><span class=\"line\">2017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007fa0&gt;, 0x174007fa0</span><br><span class=\"line\">2017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x100101258</span><br><span class=\"line\">2017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。</p>\n</blockquote>\n<p>然后我们来看看YYModel中的元类<code>_YYModelMeta</code>，其数据结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface _YYModelMeta : NSObject &#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    YYClassInfo *_classInfo;</span><br><span class=\"line\">    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.</span><br><span class=\"line\">    NSDictionary *_mapper;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, all property meta of this model.</span><br><span class=\"line\">    NSArray *_allPropertyMetas;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to a key path.</span><br><span class=\"line\">    NSArray *_keyPathPropertyMetas;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to multi keys.</span><br><span class=\"line\">    NSArray *_multiKeysPropertyMetas;</span><br><span class=\"line\">    /// The number of mapped key (and key path), same to _mapper.count.</span><br><span class=\"line\">    NSUInteger _keyMappedCount;</span><br><span class=\"line\">    /// Model class type.</span><br><span class=\"line\">    YYEncodingNSType _nsType;</span><br><span class=\"line\">    </span><br><span class=\"line\">    BOOL _hasCustomWillTransformFromDictionary;</span><br><span class=\"line\">    BOOL _hasCustomTransformFromDictionary;</span><br><span class=\"line\">    BOOL _hasCustomTransformToDictionary;</span><br><span class=\"line\">    BOOL _hasCustomClassFromDictionary;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Objective-C中有4种访问控制符：<br>@private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。<br>@package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。<br>@protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。<br>@public（公共访问权限）：成员可以在任意地方访问。</p>\n</blockquote>\n<p><code>_YYModelMeta</code>存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给<code>_YYModelPropertyMeta</code>处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface _YYModelPropertyMeta : NSObject &#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    NSString *_name;             ///&lt; property&apos;s name</span><br><span class=\"line\">    YYEncodingType _type;        ///&lt; property&apos;s type</span><br><span class=\"line\">    YYEncodingNSType _nsType;    ///&lt; property&apos;s Foundation type</span><br><span class=\"line\">    BOOL _isCNumber;             ///&lt; is c number type</span><br><span class=\"line\">    Class _cls;                  ///&lt; property&apos;s class, or nil</span><br><span class=\"line\">    Class _genericCls;           ///&lt; container&apos;s generic class, or nil if threr&apos;s no generic class</span><br><span class=\"line\">    SEL _getter;                 ///&lt; getter, or nil if the instances cannot respond</span><br><span class=\"line\">    SEL _setter;                 ///&lt; setter, or nil if the instances cannot respond</span><br><span class=\"line\">    BOOL _isKVCCompatible;       ///&lt; YES if it can access with key-value coding</span><br><span class=\"line\">    BOOL _isStructAvailableForKeyedArchiver; ///&lt; YES if the struct can encoded with keyed archiver/unarchiver</span><br><span class=\"line\">    BOOL _hasCustomClassFromDictionary; ///&lt; class/generic class implements +modelCustomClassForDictionary:</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     property-&gt;key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil</span><br><span class=\"line\">     property-&gt;keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil</span><br><span class=\"line\">     property-&gt;keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    NSString *_mappedToKey;      ///&lt; the key mapped to</span><br><span class=\"line\">    NSArray *_mappedToKeyPath;   ///&lt; the key path mapped to (nil if the name is not key path)</span><br><span class=\"line\">    NSArray *_mappedToKeyArray;  ///&lt; the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys)</span><br><span class=\"line\">    YYClassPropertyInfo *_info;  ///&lt; property&apos;s info</span><br><span class=\"line\">    _YYModelPropertyMeta *_next; ///&lt; next meta if there are multiple properties mapped to the same key.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface YYClassPropertyInfo : NSObject</span><br><span class=\"line\">@property (nonatomic, assign, readonly) objc_property_t property; ///&lt; property&apos;s opaque struct</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *name;           ///&lt; property&apos;s name</span><br><span class=\"line\">@property (nonatomic, assign, readonly) YYEncodingType type;      ///&lt; property&apos;s type</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///&lt; property&apos;s encoding value</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *ivarName;       ///&lt; property&apos;s ivar name</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class cls;      ///&lt; may be nil</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols; ///&lt; may nil</span><br><span class=\"line\">@property (nonatomic, assign, readonly) SEL getter;               ///&lt; getter (nonnull)</span><br><span class=\"line\">@property (nonatomic, assign, readonly) SEL setter;               ///&lt; setter (nonnull)</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p><code>YYClassInfo</code>则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface YYClassInfo : NSObject</span><br><span class=\"line\">@property (nonatomic, assign, readonly) Class cls; ///&lt; class object</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class superCls; ///&lt; super class object</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///&lt; class&apos;s meta class object</span><br><span class=\"line\">@property (nonatomic, readonly) BOOL isMeta; ///&lt; whether this class is meta class</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *name; ///&lt; class name</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///&lt; super class&apos;s class info</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos; ///&lt; ivars</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos; ///&lt; methods</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos; ///&lt; properties</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setNeedUpdate;</span><br><span class=\"line\">- (BOOL)needUpdate;</span><br><span class=\"line\">+ (nullable instancetype)classInfoWithClass:(Class)cls;</span><br><span class=\"line\">+ (nullable instancetype)classInfoWithClassName:(NSString *)className;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。</p>\n</blockquote>\n<p>随后通过<code>+ (instancetype)metaWithClass:(Class)cls;</code>进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下：</p>\n<blockquote>\n<ol>\n<li><a href=\"https://developer.apple.com/reference/corefoundation/cfmutabledictionary-rpl\" target=\"_blank\" rel=\"noopener\">CFMutableDictionaryRef</a>是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要</li>\n<li>dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看<a href=\"http://www.jianshu.com/p/a84c2bf0d77b\" target=\"_blank\" rel=\"noopener\">资料1</a><a href=\"http://blog.ibireme.com/2015/10/26/yycache/\" target=\"_blank\" rel=\"noopener\">资料2</a></li>\n<li>两个时间宏<br>#define DISPATCH_TIME_NOW (0ull)<br>#define DISPATCH_TIME_FOREVER (~0ull)<br>0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数</li>\n</ol>\n</blockquote>\n<p>真正的初始化方法是<code>- (instancetype)initWithClass:(Class)cls;</code>，其流程如下：</p>\n<ol>\n<li>获取YYClassInfo。</li>\n<li>获取黑名单。</li>\n<li>获取白名单。</li>\n<li>获取用户自定义属性。</li>\n<li>循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入<code>_allPropertyMetas</code>、<code>_keyPathPropertyMetas</code>、<code>_multiKeysPropertyMetas</code>。</li>\n<li>设置属性映射mapper。</li>\n</ol>\n<p>至此已获取YYModel元类，包括key/value属性映射关系，回到<code>- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;</code>进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ModelSetContext context = &#123;0&#125;;</span><br><span class=\"line\">context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class=\"line\">context.model = (__bridge void *)(self);</span><br><span class=\"line\">context.dictionary = (__bridge void *)(dic);</span><br><span class=\"line\"></span><br><span class=\"line\">if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class=\"line\">    CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class=\"line\">    if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class=\"line\">                         CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class=\"line\">                         ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                         &amp;context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    void *modelMeta;  ///&lt; _YYModelMeta</span><br><span class=\"line\">    void *model;      ///&lt; id (self)</span><br><span class=\"line\">    void *dictionary; ///&lt; NSDictionary (json)</span><br><span class=\"line\">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。<br>IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。</p>\n<p>KVC(key value coding)<br>KVC涉及以下4个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值</span><br><span class=\"line\">- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值</span><br><span class=\"line\">- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值</span><br><span class=\"line\">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/45cbd324ea65\" target=\"_blank\" rel=\"noopener\">iOS开发技巧系列—详解KVC</a></p>\n<p>KVO(key value obeserveing)<br>KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class=\"line\">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/c1dd046d9ce2\" target=\"_blank\" rel=\"noopener\">IOS 开发中的KVC 和KVO</a></p>\n</blockquote>\n<p>扩展阅读：<br><a href=\"http://www.cocoachina.com/cms/wap.php?action=article&amp;id=17874\" target=\"_blank\" rel=\"noopener\">看 YYModel 源码的一些收获</a></p>\n<blockquote>\n<p>性能优化Tip<br>缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。<br>查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。<br>避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。<br>避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。<br>避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。<br>遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。<br>尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。<br>减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。</p>\n</blockquote>\n"},{"title":"配置-SublimeText","date":"2016-09-21T03:09:54.000Z","_content":"# 快捷键（Eclipse风格）\nSublime Text -> Preferences -> Key Bindings - User\n```\n[\n    /**\n     * 代码格式化\n     */\n    { \"keys\": [\"command+r\"], \"command\": \"markdown_preview\", \"args\": { \"target\": \"browser\"} },\n    {\n        \"keys\": [\"alt+shift+f\"],\n        \"command\": \"reindent\"\n    },\n    /**\n     * json格式化\n     */\n    { \"keys\": [\"command+shift+x\"], \"command\": \"tidy_xml\" },\n    { \"keys\": [\"command+shift+j\"], \"command\": \"pretty_json\" }, \n    { \"keys\": [\"command+shift+m\"], \"command\": \"un_pretty_json\" },\n    /**\n     * 适配eclipse快捷键\n     */\n    { \"keys\": [\"alt+/\"], \"command\": \"auto_complete\" },\n    { \"keys\": [\"command+i\"], \"command\": \"reindent\" },\n    // 当前行和下面一行交互位置\n    { \"keys\": [\"alt+up\"], \"command\": \"swap_line_up\" },\n    { \"keys\": [\"alt+down\"], \"command\": \"swap_line_down\" },\n    // 复制当前行到上一行\n    { \"keys\": [\"command+alt+up\"], \"command\": \"duplicate_line\" },\n    // 复制当前行到下一行\n    { \"keys\": [\"command+alt+down\"], \"command\": \"duplicate_line\" },\n    // 删除整行\n    { \"keys\": [\"command+d\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/Default/Delete Line.sublime-macro\"} },\n    // 光标移动到指定行\n    { \"keys\": [\"command+l\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \":\"} },\n    // 快速定位到选中的文字\n    { \"keys\": [\"command+k\"], \"command\": \"find_under_expand_skip\" },\n    // { \"keys\": [\"command+shift+x\"], \"command\": \"swap_case\" },\n    { \"keys\": [\"command+shift+x\"], \"command\": \"upper_case\" },\n    { \"keys\": [\"command+shift+y\"], \"command\": \"lower_case\" },\n    // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后)\n    { \"keys\": [\"shift+enter\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/Default/Add Line.sublime-macro\"} },\n    // 定位到对于的匹配符(譬如{})(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)\n    { \"keys\": [\"command+p\"], \"command\": \"move_to\", \"args\": {\"to\": \"brackets\"} },\n    // outline\n    { \"keys\": [\"command+o\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \"@\"} },\n    // 当前文件中的关键字(方便快速查找内容)\n    { \"keys\": [\"command+alt+o\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \"#\"} },\n    // open resource\n    { \"keys\": [\"command+shift+r\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"show_files\": true} },\n    // 文件内查找/替换\n    { \"keys\": [\"command+f\"], \"command\": \"show_panel\", \"args\": {\"panel\": \"replace\"} },\n    // 全局查找/替换, 在查询结果中双击跳转到匹配位置\n    {\"keys\": [\"command+h\"], \"command\": \"show_panel\", \"args\": {\"panel\": \"find_in_files\"} },\n \n    // plugin配置\n    { \"keys\": [\"alt+a\"], \"command\": \"alignment\" },\n    {\"keys\": [\"command+shift+f\"], \"command\": \"js_format\"}\n]\n```\n\n# Color Scheme\nMonokai\n\n# Package Control\n安装方法各版本不同，以最新搜索结果为准。\n## 常用插件\nMarkdown Preview\nMarkdown Editing\n[Pretty Json](https://github.com/dzhibas/SublimePrettyJson)\n(也可以在chrome浏览器中安装JSON Formatter插件)\n\n# 激活\n原则上支持正版XD。\n","source":"_posts/配置-SublimeText.md","raw":"---\ntitle: 配置-SublimeText\ndate: 2016-09-21 11:09:54\ncategories: 配置\ntags:\n    - Sublime Text\n---\n# 快捷键（Eclipse风格）\nSublime Text -> Preferences -> Key Bindings - User\n```\n[\n    /**\n     * 代码格式化\n     */\n    { \"keys\": [\"command+r\"], \"command\": \"markdown_preview\", \"args\": { \"target\": \"browser\"} },\n    {\n        \"keys\": [\"alt+shift+f\"],\n        \"command\": \"reindent\"\n    },\n    /**\n     * json格式化\n     */\n    { \"keys\": [\"command+shift+x\"], \"command\": \"tidy_xml\" },\n    { \"keys\": [\"command+shift+j\"], \"command\": \"pretty_json\" }, \n    { \"keys\": [\"command+shift+m\"], \"command\": \"un_pretty_json\" },\n    /**\n     * 适配eclipse快捷键\n     */\n    { \"keys\": [\"alt+/\"], \"command\": \"auto_complete\" },\n    { \"keys\": [\"command+i\"], \"command\": \"reindent\" },\n    // 当前行和下面一行交互位置\n    { \"keys\": [\"alt+up\"], \"command\": \"swap_line_up\" },\n    { \"keys\": [\"alt+down\"], \"command\": \"swap_line_down\" },\n    // 复制当前行到上一行\n    { \"keys\": [\"command+alt+up\"], \"command\": \"duplicate_line\" },\n    // 复制当前行到下一行\n    { \"keys\": [\"command+alt+down\"], \"command\": \"duplicate_line\" },\n    // 删除整行\n    { \"keys\": [\"command+d\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/Default/Delete Line.sublime-macro\"} },\n    // 光标移动到指定行\n    { \"keys\": [\"command+l\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \":\"} },\n    // 快速定位到选中的文字\n    { \"keys\": [\"command+k\"], \"command\": \"find_under_expand_skip\" },\n    // { \"keys\": [\"command+shift+x\"], \"command\": \"swap_case\" },\n    { \"keys\": [\"command+shift+x\"], \"command\": \"upper_case\" },\n    { \"keys\": [\"command+shift+y\"], \"command\": \"lower_case\" },\n    // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后)\n    { \"keys\": [\"shift+enter\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/Default/Add Line.sublime-macro\"} },\n    // 定位到对于的匹配符(譬如{})(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)\n    { \"keys\": [\"command+p\"], \"command\": \"move_to\", \"args\": {\"to\": \"brackets\"} },\n    // outline\n    { \"keys\": [\"command+o\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \"@\"} },\n    // 当前文件中的关键字(方便快速查找内容)\n    { \"keys\": [\"command+alt+o\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \"#\"} },\n    // open resource\n    { \"keys\": [\"command+shift+r\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"show_files\": true} },\n    // 文件内查找/替换\n    { \"keys\": [\"command+f\"], \"command\": \"show_panel\", \"args\": {\"panel\": \"replace\"} },\n    // 全局查找/替换, 在查询结果中双击跳转到匹配位置\n    {\"keys\": [\"command+h\"], \"command\": \"show_panel\", \"args\": {\"panel\": \"find_in_files\"} },\n \n    // plugin配置\n    { \"keys\": [\"alt+a\"], \"command\": \"alignment\" },\n    {\"keys\": [\"command+shift+f\"], \"command\": \"js_format\"}\n]\n```\n\n# Color Scheme\nMonokai\n\n# Package Control\n安装方法各版本不同，以最新搜索结果为准。\n## 常用插件\nMarkdown Preview\nMarkdown Editing\n[Pretty Json](https://github.com/dzhibas/SublimePrettyJson)\n(也可以在chrome浏览器中安装JSON Formatter插件)\n\n# 激活\n原则上支持正版XD。\n","slug":"配置-SublimeText","published":1,"updated":"2019-06-12T05:45:38.248Z","_id":"cjwss6z6b000x5mlwuhet7y1l","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"快捷键（Eclipse风格）\"><a href=\"#快捷键（Eclipse风格）\" class=\"headerlink\" title=\"快捷键（Eclipse风格）\"></a>快捷键（Eclipse风格）</h1><p>Sublime Text -&gt; Preferences -&gt; Key Bindings - User<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 代码格式化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+r&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123; &quot;target&quot;: &quot;browser&quot;&#125; &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;keys&quot;: [&quot;alt+shift+f&quot;],</span><br><span class=\"line\">        &quot;command&quot;: &quot;reindent&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * json格式化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;tidy_xml&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;, </span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 适配eclipse快捷键</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;auto_complete&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+i&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;,</span><br><span class=\"line\">    // 当前行和下面一行交互位置</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;,</span><br><span class=\"line\">    // 复制当前行到上一行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+up&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;,</span><br><span class=\"line\">    // 复制当前行到下一行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+down&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;,</span><br><span class=\"line\">    // 删除整行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;,</span><br><span class=\"line\">    // 光标移动到指定行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+l&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;,</span><br><span class=\"line\">    // 快速定位到选中的文字</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+k&quot;], &quot;command&quot;: &quot;find_under_expand_skip&quot; &#125;,</span><br><span class=\"line\">    // &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;swap_case&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;upper_case&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+y&quot;], &quot;command&quot;: &quot;lower_case&quot; &#125;,</span><br><span class=\"line\">    // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;shift+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Add Line.sublime-macro&quot;&#125; &#125;,</span><br><span class=\"line\">    // 定位到对于的匹配符(譬如&#123;&#125;)(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+p&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;,</span><br><span class=\"line\">    // outline</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;@&quot;&#125; &#125;,</span><br><span class=\"line\">    // 当前文件中的关键字(方便快速查找内容)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;#&quot;&#125; &#125;,</span><br><span class=\"line\">    // open resource</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+r&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;show_files&quot;: true&#125; &#125;,</span><br><span class=\"line\">    // 文件内查找/替换</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;replace&quot;&#125; &#125;,</span><br><span class=\"line\">    // 全局查找/替换, 在查询结果中双击跳转到匹配位置</span><br><span class=\"line\">    &#123;&quot;keys&quot;: [&quot;command+h&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;find_in_files&quot;&#125; &#125;,</span><br><span class=\"line\"> </span><br><span class=\"line\">    // plugin配置</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+a&quot;], &quot;command&quot;: &quot;alignment&quot; &#125;,</span><br><span class=\"line\">    &#123;&quot;keys&quot;: [&quot;command+shift+f&quot;], &quot;command&quot;: &quot;js_format&quot;&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Color-Scheme\"><a href=\"#Color-Scheme\" class=\"headerlink\" title=\"Color Scheme\"></a>Color Scheme</h1><p>Monokai</p>\n<h1 id=\"Package-Control\"><a href=\"#Package-Control\" class=\"headerlink\" title=\"Package Control\"></a>Package Control</h1><p>安装方法各版本不同，以最新搜索结果为准。</p>\n<h2 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h2><p>Markdown Preview<br>Markdown Editing<br><a href=\"https://github.com/dzhibas/SublimePrettyJson\" target=\"_blank\" rel=\"noopener\">Pretty Json</a><br>(也可以在chrome浏览器中安装JSON Formatter插件)</p>\n<h1 id=\"激活\"><a href=\"#激活\" class=\"headerlink\" title=\"激活\"></a>激活</h1><p>原则上支持正版XD。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"快捷键（Eclipse风格）\"><a href=\"#快捷键（Eclipse风格）\" class=\"headerlink\" title=\"快捷键（Eclipse风格）\"></a>快捷键（Eclipse风格）</h1><p>Sublime Text -&gt; Preferences -&gt; Key Bindings - User<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 代码格式化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+r&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123; &quot;target&quot;: &quot;browser&quot;&#125; &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;keys&quot;: [&quot;alt+shift+f&quot;],</span><br><span class=\"line\">        &quot;command&quot;: &quot;reindent&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * json格式化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;tidy_xml&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;, </span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 适配eclipse快捷键</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;auto_complete&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+i&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;,</span><br><span class=\"line\">    // 当前行和下面一行交互位置</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;,</span><br><span class=\"line\">    // 复制当前行到上一行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+up&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;,</span><br><span class=\"line\">    // 复制当前行到下一行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+down&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;,</span><br><span class=\"line\">    // 删除整行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;,</span><br><span class=\"line\">    // 光标移动到指定行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+l&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;,</span><br><span class=\"line\">    // 快速定位到选中的文字</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+k&quot;], &quot;command&quot;: &quot;find_under_expand_skip&quot; &#125;,</span><br><span class=\"line\">    // &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;swap_case&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;upper_case&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+y&quot;], &quot;command&quot;: &quot;lower_case&quot; &#125;,</span><br><span class=\"line\">    // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;shift+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Add Line.sublime-macro&quot;&#125; &#125;,</span><br><span class=\"line\">    // 定位到对于的匹配符(譬如&#123;&#125;)(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+p&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;,</span><br><span class=\"line\">    // outline</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;@&quot;&#125; &#125;,</span><br><span class=\"line\">    // 当前文件中的关键字(方便快速查找内容)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;#&quot;&#125; &#125;,</span><br><span class=\"line\">    // open resource</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+r&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;show_files&quot;: true&#125; &#125;,</span><br><span class=\"line\">    // 文件内查找/替换</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;replace&quot;&#125; &#125;,</span><br><span class=\"line\">    // 全局查找/替换, 在查询结果中双击跳转到匹配位置</span><br><span class=\"line\">    &#123;&quot;keys&quot;: [&quot;command+h&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;find_in_files&quot;&#125; &#125;,</span><br><span class=\"line\"> </span><br><span class=\"line\">    // plugin配置</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+a&quot;], &quot;command&quot;: &quot;alignment&quot; &#125;,</span><br><span class=\"line\">    &#123;&quot;keys&quot;: [&quot;command+shift+f&quot;], &quot;command&quot;: &quot;js_format&quot;&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Color-Scheme\"><a href=\"#Color-Scheme\" class=\"headerlink\" title=\"Color Scheme\"></a>Color Scheme</h1><p>Monokai</p>\n<h1 id=\"Package-Control\"><a href=\"#Package-Control\" class=\"headerlink\" title=\"Package Control\"></a>Package Control</h1><p>安装方法各版本不同，以最新搜索结果为准。</p>\n<h2 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h2><p>Markdown Preview<br>Markdown Editing<br><a href=\"https://github.com/dzhibas/SublimePrettyJson\" target=\"_blank\" rel=\"noopener\">Pretty Json</a><br>(也可以在chrome浏览器中安装JSON Formatter插件)</p>\n<h1 id=\"激活\"><a href=\"#激活\" class=\"headerlink\" title=\"激活\"></a>激活</h1><p>原则上支持正版XD。</p>\n"},{"title":"配置-Xcode快捷键","date":"2016-09-21T02:12:12.000Z","_content":"部分内容来自：[简书：为Xcode添加删除当前行、复制当前行快捷键](http://www.jianshu.com/p/2ed2c7ac6d53?nomobile=yes) 感谢作者的分享。\n本文仅为记录个人的开发配置。\n\nXcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。\n有一些eclipse带过来的快捷键习惯该如何设置呢？\n\n# 上下移动当前行\nXcode -> Preference -> Key Bindings -> Move Line Up & Move Line Down\n\n# 复制当前行\n## 修改权限\n```\nsudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n\nsudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/\n```\n## 添加快捷键\n```\nopen /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n```\n在`Insertions and Indentations`中添加`Duplicate Current Line` - `selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:`\n## 设置快捷键\n重启后\nXcode -> Preference -> Key Bindings -> Insertions and Indentations\n\n# 删除当前行\n## 添加快捷键\n```\nopen /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n```\n在`Deletions`中添加`Delete Current Line` - `deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:`\n## 设置快捷键\n重启后\nXcode -> Preference -> Key Bindings -> Delete Current Line\n","source":"_posts/配置-Xcode快捷键.md","raw":"---\ntitle: 配置-Xcode快捷键\ndate: 2016-09-21 10:12:12\ncategories: 配置\ntags:\n    - Xcode\n---\n部分内容来自：[简书：为Xcode添加删除当前行、复制当前行快捷键](http://www.jianshu.com/p/2ed2c7ac6d53?nomobile=yes) 感谢作者的分享。\n本文仅为记录个人的开发配置。\n\nXcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。\n有一些eclipse带过来的快捷键习惯该如何设置呢？\n\n# 上下移动当前行\nXcode -> Preference -> Key Bindings -> Move Line Up & Move Line Down\n\n# 复制当前行\n## 修改权限\n```\nsudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n\nsudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/\n```\n## 添加快捷键\n```\nopen /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n```\n在`Insertions and Indentations`中添加`Duplicate Current Line` - `selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:`\n## 设置快捷键\n重启后\nXcode -> Preference -> Key Bindings -> Insertions and Indentations\n\n# 删除当前行\n## 添加快捷键\n```\nopen /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n```\n在`Deletions`中添加`Delete Current Line` - `deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:`\n## 设置快捷键\n重启后\nXcode -> Preference -> Key Bindings -> Delete Current Line\n","slug":"配置-Xcode快捷键","published":1,"updated":"2019-06-12T05:45:47.193Z","_id":"cjwss6z6c00115mlwcqz2ugyd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>部分内容来自：<a href=\"http://www.jianshu.com/p/2ed2c7ac6d53?nomobile=yes\" target=\"_blank\" rel=\"noopener\">简书：为Xcode添加删除当前行、复制当前行快捷键</a> 感谢作者的分享。<br>本文仅为记录个人的开发配置。</p>\n<p>Xcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。<br>有一些eclipse带过来的快捷键习惯该如何设置呢？</p>\n<h1 id=\"上下移动当前行\"><a href=\"#上下移动当前行\" class=\"headerlink\" title=\"上下移动当前行\"></a>上下移动当前行</h1><p>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Move Line Up &amp; Move Line Down</p>\n<h1 id=\"复制当前行\"><a href=\"#复制当前行\" class=\"headerlink\" title=\"复制当前行\"></a>复制当前行</h1><h2 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加快捷键\"><a href=\"#添加快捷键\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure>\n<p>在<code>Insertions and Indentations</code>中添加<code>Duplicate Current Line</code> - <code>selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:</code></p>\n<h2 id=\"设置快捷键\"><a href=\"#设置快捷键\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h2><p>重启后<br>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Insertions and Indentations</p>\n<h1 id=\"删除当前行\"><a href=\"#删除当前行\" class=\"headerlink\" title=\"删除当前行\"></a>删除当前行</h1><h2 id=\"添加快捷键-1\"><a href=\"#添加快捷键-1\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure>\n<p>在<code>Deletions</code>中添加<code>Delete Current Line</code> - <code>deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:</code></p>\n<h2 id=\"设置快捷键-1\"><a href=\"#设置快捷键-1\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h2><p>重启后<br>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Delete Current Line</p>\n","site":{"data":{}},"excerpt":"","more":"<p>部分内容来自：<a href=\"http://www.jianshu.com/p/2ed2c7ac6d53?nomobile=yes\" target=\"_blank\" rel=\"noopener\">简书：为Xcode添加删除当前行、复制当前行快捷键</a> 感谢作者的分享。<br>本文仅为记录个人的开发配置。</p>\n<p>Xcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。<br>有一些eclipse带过来的快捷键习惯该如何设置呢？</p>\n<h1 id=\"上下移动当前行\"><a href=\"#上下移动当前行\" class=\"headerlink\" title=\"上下移动当前行\"></a>上下移动当前行</h1><p>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Move Line Up &amp; Move Line Down</p>\n<h1 id=\"复制当前行\"><a href=\"#复制当前行\" class=\"headerlink\" title=\"复制当前行\"></a>复制当前行</h1><h2 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加快捷键\"><a href=\"#添加快捷键\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure>\n<p>在<code>Insertions and Indentations</code>中添加<code>Duplicate Current Line</code> - <code>selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:</code></p>\n<h2 id=\"设置快捷键\"><a href=\"#设置快捷键\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h2><p>重启后<br>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Insertions and Indentations</p>\n<h1 id=\"删除当前行\"><a href=\"#删除当前行\" class=\"headerlink\" title=\"删除当前行\"></a>删除当前行</h1><h2 id=\"添加快捷键-1\"><a href=\"#添加快捷键-1\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure>\n<p>在<code>Deletions</code>中添加<code>Delete Current Line</code> - <code>deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:</code></p>\n<h2 id=\"设置快捷键-1\"><a href=\"#设置快捷键-1\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h2><p>重启后<br>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Delete Current Line</p>\n"},{"title":"iOS基础-属性变量、实例变量、成员变量的内存泄漏","date":"2018-07-18T03:33:56.000Z","_content":"\n直接上代码\n```\n@interface TestViewController () {\n@private\n    NSString *name1;\n}\n\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, strong) TestObject *testObj;\n\n@property (nonatomic, strong) TestObject *testObj1;\n\n@property (nonatomic, copy) NSString *name2;\n@property (nonatomic, strong) TestObject *testObj2;\n@end\n```\n```\n// 无泄漏\n- (void)testBlock {\n    __weak typeof(self) weakSelf = self;\n    [self.testObj requestData:^(NSString *str) {\n        weakSelf.name = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock1 {\n    [self.testObj1 requestData:^(NSString *str) {\n        name1 = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock1_2 {\n    [self.testObj1 requestData:^(NSString *str) {\n        self->name1 = str;\n    }];\n}\n\n// 无泄漏\n- (void)testBlock1_3 {\n    __weak typeof(self) weakSelf = self;\n    [self.testObj1 requestData:^(NSString *str) {\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        strongSelf->name1 = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock2 {\n    [self.testObj2 requestData:^(NSString *str) {\n        _name2 = str;\n    }];\n}\n```\n\n属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self->name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。\n","source":"_posts/iOS基础-属性变量、实例变量、成员变量的内存泄漏.md","raw":"---\ntitle: iOS基础-属性变量、实例变量、成员变量的内存泄漏\ndate: 2018-07-18 11:33:56\ncategories: iOS基础知识\ntags:\n    - 内存泄漏\n---\n\n直接上代码\n```\n@interface TestViewController () {\n@private\n    NSString *name1;\n}\n\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, strong) TestObject *testObj;\n\n@property (nonatomic, strong) TestObject *testObj1;\n\n@property (nonatomic, copy) NSString *name2;\n@property (nonatomic, strong) TestObject *testObj2;\n@end\n```\n```\n// 无泄漏\n- (void)testBlock {\n    __weak typeof(self) weakSelf = self;\n    [self.testObj requestData:^(NSString *str) {\n        weakSelf.name = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock1 {\n    [self.testObj1 requestData:^(NSString *str) {\n        name1 = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock1_2 {\n    [self.testObj1 requestData:^(NSString *str) {\n        self->name1 = str;\n    }];\n}\n\n// 无泄漏\n- (void)testBlock1_3 {\n    __weak typeof(self) weakSelf = self;\n    [self.testObj1 requestData:^(NSString *str) {\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        strongSelf->name1 = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock2 {\n    [self.testObj2 requestData:^(NSString *str) {\n        _name2 = str;\n    }];\n}\n```\n\n属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self->name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。\n","slug":"iOS基础-属性变量、实例变量、成员变量的内存泄漏","published":1,"updated":"2019-06-12T05:06:53.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwss6z6d00135mlwfxzy45rl","content":"<p>直接上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface TestViewController () &#123;</span><br><span class=\"line\">@private</span><br><span class=\"line\">    NSString *name1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name;</span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj1;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name2;</span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj2;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 无泄漏</span><br><span class=\"line\">- (void)testBlock &#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testObj requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        weakSelf.name = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock1 &#123;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock1_2 &#123;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        self-&gt;name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 无泄漏</span><br><span class=\"line\">- (void)testBlock1_3 &#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">        strongSelf-&gt;name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock2 &#123;</span><br><span class=\"line\">    [self.testObj2 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        _name2 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self-&gt;name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>直接上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface TestViewController () &#123;</span><br><span class=\"line\">@private</span><br><span class=\"line\">    NSString *name1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name;</span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj1;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name2;</span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj2;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 无泄漏</span><br><span class=\"line\">- (void)testBlock &#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testObj requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        weakSelf.name = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock1 &#123;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock1_2 &#123;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        self-&gt;name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 无泄漏</span><br><span class=\"line\">- (void)testBlock1_3 &#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">        strongSelf-&gt;name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock2 &#123;</span><br><span class=\"line\">    [self.testObj2 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        _name2 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self-&gt;name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。</p>\n"},{"title":"配置-Vim、Git、SVN","date":"2016-09-21T02:57:19.000Z","_content":"# bash\n`vim /etc/profile`，添加如下\n```\n# base\nalias ll=\"ls -la\"\n```\n\n# Vim\n`vim /etc/profile`，添加`export TERM=xterm`。\n\n## 样式\n`vim ~/.vimrc`，配置如下\n```\nsyntax on\nset tabstop=4\nset softtabstop=4\nset shiftwidth=4\nset autoindent\nset cindent\nset cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,>1s,=1s,:1s\n\nif &term==\"xterm\"\nset t_Co=8\nset t_Sb=^[[4%dm\nset t_Sf=^[[3%dm\nendif\n```\n\n## 命令\n[vim命令大全](http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html)\n\n# Git\n## alias\n```\nvim ~/.gitconfig\n```\n```\n[alias]\n    co = checkout\n    ad = add\n    aa = add -A\n    au = add -u\n    ci = commit\n    ca = commit -a\n    st = status\n    pl = pull\n    pr = pull --rebase\n    ps = push\n    dt = difftool\n    l = log --stat\n    cp = cherry-pick\n    b = branch\n    lg = log --stat\n    lgp = log --stat -p\n    lgg = log --graph\n    lgga = log --graph --decorate --all\n    lgm = log --graph --max-count=10\n    lo = log --oneline --decorate\n    lol = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n    lola = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all\n    log = log --oneline --decorate --graph\n    loga = log --oneline --decorate --graph --all\n```\n\np.s.\n```\n# 三种add命令的区别\n1.  git add -A   保存所有的修改\n2.  git add .     保存新的添加和修改，但是不包括删除\n3.  git add -u   保存修改和删除，但是不包括新建文件\n\n# 查看命令帮助\ngit xxx -h\n```\n\n## 添加中文支持\nbash中输入`git config --global core.quotepath false`（已使用UTF-8字符集）。\n\n## ignore\n`vim ~/.gitignore_global`\n添加\n```\n*~\n.DS_Store\n# Xcode\n#\n# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore\n\n## Build generated\n#build/\nDerivedData/\n\n## Various settings\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\nxcuserdata/\n*.xcuserdatad\n\n## Other\n*.moved-aside\n*.xcuserstate\n\n## Obj-C/Swift specific\n*.hmap\n*.ipa\n*.dSYM.zip\n*.dSYM\n\n# CocoaPods\n#\n# We recommend against adding the Pods directory to your .gitignore. However\n# you should judge for yourself, the pros and cons are mentioned at:\n# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control\n#\n# Pods/\n\n# Carthage\n#\n# Add this line if you want to avoid checking in source code from Carthage dependencies.\n# Carthage/Checkouts\n\nCarthage/Build\n\n# fastlane\n#\n# It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the \n# screenshots whenever they are needed.\n# For more information about the recommended setup visit:\n# https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.md\n\nfastlane/report.xml\nfastlane/Preview.html\nfastlane/screenshots\nfastlane/test_output\n\n# Code Injection\n#\n# After new code Injection tools there's a generated folder /iOSInjectionProject\n# https://github.com/johnno1962/injectionforxcode\n\niOSInjectionProject/\n```\n\nGerrit审查模式配置\n切换到相应的git库目录下，执行`git config remote.origin.push refs/heads/*:refs/for/*`命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。\n\np.s.\n删除误提交的xcuserdata\n```\n// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。\ngit rm -r -n --cached  */src/\\*\n\n// 删除文件的版本控制\ngit rm -r --cached  */src/\\*      \n```\n\n# SVN\n`vim /etc/profile`，添加`export SVN_EDITOR=vim`。\n全局和局部参数配置用户信息，略。","source":"_posts/配置-Vim、Git、SVN.md","raw":"---\ntitle: 配置-Vim、Git、SVN\ndate: 2016-09-21 10:57:19\ncategories: 配置\ntags:\n    - bash\n    - Vim\n    - Git\n    - SVN\n---\n# bash\n`vim /etc/profile`，添加如下\n```\n# base\nalias ll=\"ls -la\"\n```\n\n# Vim\n`vim /etc/profile`，添加`export TERM=xterm`。\n\n## 样式\n`vim ~/.vimrc`，配置如下\n```\nsyntax on\nset tabstop=4\nset softtabstop=4\nset shiftwidth=4\nset autoindent\nset cindent\nset cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,>1s,=1s,:1s\n\nif &term==\"xterm\"\nset t_Co=8\nset t_Sb=^[[4%dm\nset t_Sf=^[[3%dm\nendif\n```\n\n## 命令\n[vim命令大全](http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html)\n\n# Git\n## alias\n```\nvim ~/.gitconfig\n```\n```\n[alias]\n    co = checkout\n    ad = add\n    aa = add -A\n    au = add -u\n    ci = commit\n    ca = commit -a\n    st = status\n    pl = pull\n    pr = pull --rebase\n    ps = push\n    dt = difftool\n    l = log --stat\n    cp = cherry-pick\n    b = branch\n    lg = log --stat\n    lgp = log --stat -p\n    lgg = log --graph\n    lgga = log --graph --decorate --all\n    lgm = log --graph --max-count=10\n    lo = log --oneline --decorate\n    lol = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n    lola = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all\n    log = log --oneline --decorate --graph\n    loga = log --oneline --decorate --graph --all\n```\n\np.s.\n```\n# 三种add命令的区别\n1.  git add -A   保存所有的修改\n2.  git add .     保存新的添加和修改，但是不包括删除\n3.  git add -u   保存修改和删除，但是不包括新建文件\n\n# 查看命令帮助\ngit xxx -h\n```\n\n## 添加中文支持\nbash中输入`git config --global core.quotepath false`（已使用UTF-8字符集）。\n\n## ignore\n`vim ~/.gitignore_global`\n添加\n```\n*~\n.DS_Store\n# Xcode\n#\n# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore\n\n## Build generated\n#build/\nDerivedData/\n\n## Various settings\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\nxcuserdata/\n*.xcuserdatad\n\n## Other\n*.moved-aside\n*.xcuserstate\n\n## Obj-C/Swift specific\n*.hmap\n*.ipa\n*.dSYM.zip\n*.dSYM\n\n# CocoaPods\n#\n# We recommend against adding the Pods directory to your .gitignore. However\n# you should judge for yourself, the pros and cons are mentioned at:\n# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control\n#\n# Pods/\n\n# Carthage\n#\n# Add this line if you want to avoid checking in source code from Carthage dependencies.\n# Carthage/Checkouts\n\nCarthage/Build\n\n# fastlane\n#\n# It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the \n# screenshots whenever they are needed.\n# For more information about the recommended setup visit:\n# https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.md\n\nfastlane/report.xml\nfastlane/Preview.html\nfastlane/screenshots\nfastlane/test_output\n\n# Code Injection\n#\n# After new code Injection tools there's a generated folder /iOSInjectionProject\n# https://github.com/johnno1962/injectionforxcode\n\niOSInjectionProject/\n```\n\nGerrit审查模式配置\n切换到相应的git库目录下，执行`git config remote.origin.push refs/heads/*:refs/for/*`命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。\n\np.s.\n删除误提交的xcuserdata\n```\n// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。\ngit rm -r -n --cached  */src/\\*\n\n// 删除文件的版本控制\ngit rm -r --cached  */src/\\*      \n```\n\n# SVN\n`vim /etc/profile`，添加`export SVN_EDITOR=vim`。\n全局和局部参数配置用户信息，略。","slug":"配置-Vim、Git、SVN","published":1,"updated":"2019-06-12T05:45:42.768Z","_id":"cjwss6z6s001q5mlwd2xepzdb","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"bash\"><a href=\"#bash\" class=\"headerlink\" title=\"bash\"></a>bash</h1><p><code>vim /etc/profile</code>，添加如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># base</span><br><span class=\"line\">alias ll=&quot;ls -la&quot;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h1><p><code>vim /etc/profile</code>，添加<code>export TERM=xterm</code>。</p>\n<h2 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h2><p><code>vim ~/.vimrc</code>，配置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax on</span><br><span class=\"line\">set tabstop=4</span><br><span class=\"line\">set softtabstop=4</span><br><span class=\"line\">set shiftwidth=4</span><br><span class=\"line\">set autoindent</span><br><span class=\"line\">set cindent</span><br><span class=\"line\">set cinoptions=&#123;0,1s,t0,n-2,p2s,(03s,=.5s,&gt;1s,=1s,:1s</span><br><span class=\"line\"></span><br><span class=\"line\">if &amp;term==&quot;xterm&quot;</span><br><span class=\"line\">set t_Co=8</span><br><span class=\"line\">set t_Sb=^[[4%dm</span><br><span class=\"line\">set t_Sf=^[[3%dm</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p><a href=\"http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html\" target=\"_blank\" rel=\"noopener\">vim命令大全</a></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h2 id=\"alias\"><a href=\"#alias\" class=\"headerlink\" title=\"alias\"></a>alias</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.gitconfig</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[alias]</span><br><span class=\"line\">    co = checkout</span><br><span class=\"line\">    ad = add</span><br><span class=\"line\">    aa = add -A</span><br><span class=\"line\">    au = add -u</span><br><span class=\"line\">    ci = commit</span><br><span class=\"line\">    ca = commit -a</span><br><span class=\"line\">    st = status</span><br><span class=\"line\">    pl = pull</span><br><span class=\"line\">    pr = pull --rebase</span><br><span class=\"line\">    ps = push</span><br><span class=\"line\">    dt = difftool</span><br><span class=\"line\">    l = log --stat</span><br><span class=\"line\">    cp = cherry-pick</span><br><span class=\"line\">    b = branch</span><br><span class=\"line\">    lg = log --stat</span><br><span class=\"line\">    lgp = log --stat -p</span><br><span class=\"line\">    lgg = log --graph</span><br><span class=\"line\">    lgga = log --graph --decorate --all</span><br><span class=\"line\">    lgm = log --graph --max-count=10</span><br><span class=\"line\">    lo = log --oneline --decorate</span><br><span class=\"line\">    lol = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class=\"line\">    lola = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --all</span><br><span class=\"line\">    log = log --oneline --decorate --graph</span><br><span class=\"line\">    loga = log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure>\n<p>p.s.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 三种add命令的区别</span><br><span class=\"line\">1.  git add -A   保存所有的修改</span><br><span class=\"line\">2.  git add .     保存新的添加和修改，但是不包括删除</span><br><span class=\"line\">3.  git add -u   保存修改和删除，但是不包括新建文件</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看命令帮助</span><br><span class=\"line\">git xxx -h</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"添加中文支持\"><a href=\"#添加中文支持\" class=\"headerlink\" title=\"添加中文支持\"></a>添加中文支持</h2><p>bash中输入<code>git config --global core.quotepath false</code>（已使用UTF-8字符集）。</p>\n<h2 id=\"ignore\"><a href=\"#ignore\" class=\"headerlink\" title=\"ignore\"></a>ignore</h2><p><code>vim ~/.gitignore_global</code><br>添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*~</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\"># Xcode</span><br><span class=\"line\">#</span><br><span class=\"line\"># gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore</span><br><span class=\"line\"></span><br><span class=\"line\">## Build generated</span><br><span class=\"line\">#build/</span><br><span class=\"line\">DerivedData/</span><br><span class=\"line\"></span><br><span class=\"line\">## Various settings</span><br><span class=\"line\">*.pbxuser</span><br><span class=\"line\">!default.pbxuser</span><br><span class=\"line\">*.mode1v3</span><br><span class=\"line\">!default.mode1v3</span><br><span class=\"line\">*.mode2v3</span><br><span class=\"line\">!default.mode2v3</span><br><span class=\"line\">*.perspectivev3</span><br><span class=\"line\">!default.perspectivev3</span><br><span class=\"line\">xcuserdata/</span><br><span class=\"line\">*.xcuserdatad</span><br><span class=\"line\"></span><br><span class=\"line\">## Other</span><br><span class=\"line\">*.moved-aside</span><br><span class=\"line\">*.xcuserstate</span><br><span class=\"line\"></span><br><span class=\"line\">## Obj-C/Swift specific</span><br><span class=\"line\">*.hmap</span><br><span class=\"line\">*.ipa</span><br><span class=\"line\">*.dSYM.zip</span><br><span class=\"line\">*.dSYM</span><br><span class=\"line\"></span><br><span class=\"line\"># CocoaPods</span><br><span class=\"line\">#</span><br><span class=\"line\"># We recommend against adding the Pods directory to your .gitignore. However</span><br><span class=\"line\"># you should judge for yourself, the pros and cons are mentioned at:</span><br><span class=\"line\"># https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control</span><br><span class=\"line\">#</span><br><span class=\"line\"># Pods/</span><br><span class=\"line\"></span><br><span class=\"line\"># Carthage</span><br><span class=\"line\">#</span><br><span class=\"line\"># Add this line if you want to avoid checking in source code from Carthage dependencies.</span><br><span class=\"line\"># Carthage/Checkouts</span><br><span class=\"line\"></span><br><span class=\"line\">Carthage/Build</span><br><span class=\"line\"></span><br><span class=\"line\"># fastlane</span><br><span class=\"line\">#</span><br><span class=\"line\"># It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the </span><br><span class=\"line\"># screenshots whenever they are needed.</span><br><span class=\"line\"># For more information about the recommended setup visit:</span><br><span class=\"line\"># https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.md</span><br><span class=\"line\"></span><br><span class=\"line\">fastlane/report.xml</span><br><span class=\"line\">fastlane/Preview.html</span><br><span class=\"line\">fastlane/screenshots</span><br><span class=\"line\">fastlane/test_output</span><br><span class=\"line\"></span><br><span class=\"line\"># Code Injection</span><br><span class=\"line\">#</span><br><span class=\"line\"># After new code Injection tools there&apos;s a generated folder /iOSInjectionProject</span><br><span class=\"line\"># https://github.com/johnno1962/injectionforxcode</span><br><span class=\"line\"></span><br><span class=\"line\">iOSInjectionProject/</span><br></pre></td></tr></table></figure></p>\n<p>Gerrit审查模式配置<br>切换到相应的git库目录下，执行<code>git config remote.origin.push refs/heads/*:refs/for/*</code>命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。</p>\n<p>p.s.<br>删除误提交的xcuserdata<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span><br><span class=\"line\">git rm -r -n --cached  */src/\\*</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除文件的版本控制</span><br><span class=\"line\">git rm -r --cached  */src/\\*</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"SVN\"><a href=\"#SVN\" class=\"headerlink\" title=\"SVN\"></a>SVN</h1><p><code>vim /etc/profile</code>，添加<code>export SVN_EDITOR=vim</code>。<br>全局和局部参数配置用户信息，略。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"bash\"><a href=\"#bash\" class=\"headerlink\" title=\"bash\"></a>bash</h1><p><code>vim /etc/profile</code>，添加如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># base</span><br><span class=\"line\">alias ll=&quot;ls -la&quot;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h1><p><code>vim /etc/profile</code>，添加<code>export TERM=xterm</code>。</p>\n<h2 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h2><p><code>vim ~/.vimrc</code>，配置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax on</span><br><span class=\"line\">set tabstop=4</span><br><span class=\"line\">set softtabstop=4</span><br><span class=\"line\">set shiftwidth=4</span><br><span class=\"line\">set autoindent</span><br><span class=\"line\">set cindent</span><br><span class=\"line\">set cinoptions=&#123;0,1s,t0,n-2,p2s,(03s,=.5s,&gt;1s,=1s,:1s</span><br><span class=\"line\"></span><br><span class=\"line\">if &amp;term==&quot;xterm&quot;</span><br><span class=\"line\">set t_Co=8</span><br><span class=\"line\">set t_Sb=^[[4%dm</span><br><span class=\"line\">set t_Sf=^[[3%dm</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p><a href=\"http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html\" target=\"_blank\" rel=\"noopener\">vim命令大全</a></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h2 id=\"alias\"><a href=\"#alias\" class=\"headerlink\" title=\"alias\"></a>alias</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.gitconfig</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[alias]</span><br><span class=\"line\">    co = checkout</span><br><span class=\"line\">    ad = add</span><br><span class=\"line\">    aa = add -A</span><br><span class=\"line\">    au = add -u</span><br><span class=\"line\">    ci = commit</span><br><span class=\"line\">    ca = commit -a</span><br><span class=\"line\">    st = status</span><br><span class=\"line\">    pl = pull</span><br><span class=\"line\">    pr = pull --rebase</span><br><span class=\"line\">    ps = push</span><br><span class=\"line\">    dt = difftool</span><br><span class=\"line\">    l = log --stat</span><br><span class=\"line\">    cp = cherry-pick</span><br><span class=\"line\">    b = branch</span><br><span class=\"line\">    lg = log --stat</span><br><span class=\"line\">    lgp = log --stat -p</span><br><span class=\"line\">    lgg = log --graph</span><br><span class=\"line\">    lgga = log --graph --decorate --all</span><br><span class=\"line\">    lgm = log --graph --max-count=10</span><br><span class=\"line\">    lo = log --oneline --decorate</span><br><span class=\"line\">    lol = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class=\"line\">    lola = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --all</span><br><span class=\"line\">    log = log --oneline --decorate --graph</span><br><span class=\"line\">    loga = log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure>\n<p>p.s.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 三种add命令的区别</span><br><span class=\"line\">1.  git add -A   保存所有的修改</span><br><span class=\"line\">2.  git add .     保存新的添加和修改，但是不包括删除</span><br><span class=\"line\">3.  git add -u   保存修改和删除，但是不包括新建文件</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看命令帮助</span><br><span class=\"line\">git xxx -h</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"添加中文支持\"><a href=\"#添加中文支持\" class=\"headerlink\" title=\"添加中文支持\"></a>添加中文支持</h2><p>bash中输入<code>git config --global core.quotepath false</code>（已使用UTF-8字符集）。</p>\n<h2 id=\"ignore\"><a href=\"#ignore\" class=\"headerlink\" title=\"ignore\"></a>ignore</h2><p><code>vim ~/.gitignore_global</code><br>添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*~</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\"># Xcode</span><br><span class=\"line\">#</span><br><span class=\"line\"># gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore</span><br><span class=\"line\"></span><br><span class=\"line\">## Build generated</span><br><span class=\"line\">#build/</span><br><span class=\"line\">DerivedData/</span><br><span class=\"line\"></span><br><span class=\"line\">## Various settings</span><br><span class=\"line\">*.pbxuser</span><br><span class=\"line\">!default.pbxuser</span><br><span class=\"line\">*.mode1v3</span><br><span class=\"line\">!default.mode1v3</span><br><span class=\"line\">*.mode2v3</span><br><span class=\"line\">!default.mode2v3</span><br><span class=\"line\">*.perspectivev3</span><br><span class=\"line\">!default.perspectivev3</span><br><span class=\"line\">xcuserdata/</span><br><span class=\"line\">*.xcuserdatad</span><br><span class=\"line\"></span><br><span class=\"line\">## Other</span><br><span class=\"line\">*.moved-aside</span><br><span class=\"line\">*.xcuserstate</span><br><span class=\"line\"></span><br><span class=\"line\">## Obj-C/Swift specific</span><br><span class=\"line\">*.hmap</span><br><span class=\"line\">*.ipa</span><br><span class=\"line\">*.dSYM.zip</span><br><span class=\"line\">*.dSYM</span><br><span class=\"line\"></span><br><span class=\"line\"># CocoaPods</span><br><span class=\"line\">#</span><br><span class=\"line\"># We recommend against adding the Pods directory to your .gitignore. However</span><br><span class=\"line\"># you should judge for yourself, the pros and cons are mentioned at:</span><br><span class=\"line\"># https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control</span><br><span class=\"line\">#</span><br><span class=\"line\"># Pods/</span><br><span class=\"line\"></span><br><span class=\"line\"># Carthage</span><br><span class=\"line\">#</span><br><span class=\"line\"># Add this line if you want to avoid checking in source code from Carthage dependencies.</span><br><span class=\"line\"># Carthage/Checkouts</span><br><span class=\"line\"></span><br><span class=\"line\">Carthage/Build</span><br><span class=\"line\"></span><br><span class=\"line\"># fastlane</span><br><span class=\"line\">#</span><br><span class=\"line\"># It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the </span><br><span class=\"line\"># screenshots whenever they are needed.</span><br><span class=\"line\"># For more information about the recommended setup visit:</span><br><span class=\"line\"># https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.md</span><br><span class=\"line\"></span><br><span class=\"line\">fastlane/report.xml</span><br><span class=\"line\">fastlane/Preview.html</span><br><span class=\"line\">fastlane/screenshots</span><br><span class=\"line\">fastlane/test_output</span><br><span class=\"line\"></span><br><span class=\"line\"># Code Injection</span><br><span class=\"line\">#</span><br><span class=\"line\"># After new code Injection tools there&apos;s a generated folder /iOSInjectionProject</span><br><span class=\"line\"># https://github.com/johnno1962/injectionforxcode</span><br><span class=\"line\"></span><br><span class=\"line\">iOSInjectionProject/</span><br></pre></td></tr></table></figure></p>\n<p>Gerrit审查模式配置<br>切换到相应的git库目录下，执行<code>git config remote.origin.push refs/heads/*:refs/for/*</code>命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。</p>\n<p>p.s.<br>删除误提交的xcuserdata<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span><br><span class=\"line\">git rm -r -n --cached  */src/\\*</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除文件的版本控制</span><br><span class=\"line\">git rm -r --cached  */src/\\*</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"SVN\"><a href=\"#SVN\" class=\"headerlink\" title=\"SVN\"></a>SVN</h1><p><code>vim /etc/profile</code>，添加<code>export SVN_EDITOR=vim</code>。<br>全局和局部参数配置用户信息，略。</p>\n"},{"title":"配置-迁移hexo","date":"2016-09-02T16:21:26.000Z","_content":"\nBlog托管在github，拉取代码后。\n- 下载nodejs，[Node.js官网](https://nodejs.org/en/)\n- 安装hexo，`sudo npm install -g hexo`\n- 保留原有deploy配置，执行`sudo npm install hexo-deployer-git --save`\n- 安装server，`sudo npm install hexo-server`\n\n如发生github pages init错误，删除.deploy_git文件\n\ntheme中配置`_config.yml`文件，将被墙资源改为cdn资源。\n另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。\n目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。\n\n记录NEXT theme中一个bug：\npost_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。\n```\n  // 旧方法存在bug，无法选中指定toc\n  // $('.post-toc a').on('click', function (e) {\n  //   e.preventDefault();\n  //   var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));\n  //   var offset = $(targetSelector).offset().top;\n\n  //   hasVelocity ?\n  //     html.velocity('stop').velocity('scroll', {\n  //       offset: offset  + 'px',\n  //       mobileHA: false\n  //     }) :\n  //     $('html, body').stop().animate({\n  //       scrollTop: offset\n  //     }, 500);\n  // });\n```\n修改如下：\n```\n  $('.post-toc a').on('click', function (e) {\n    e.preventDefault();\n    $('html, body').animate({\n        scrollTop: $( $.attr(this, 'href') ).offset().top\n    }, 500);\n  });\n```\n\n## 如遇到hexo g无法生成source的情况，`npm ls --depth 0`列出缺失包，`npm install xxx --save`逐个下载\n\n入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。","source":"_posts/配置-迁移hexo.md","raw":"---\ntitle: 配置-迁移hexo\ndate: 2016-09-03 00:21:26\ncategories: 配置\ntags:\n    - hexo\n---\n\nBlog托管在github，拉取代码后。\n- 下载nodejs，[Node.js官网](https://nodejs.org/en/)\n- 安装hexo，`sudo npm install -g hexo`\n- 保留原有deploy配置，执行`sudo npm install hexo-deployer-git --save`\n- 安装server，`sudo npm install hexo-server`\n\n如发生github pages init错误，删除.deploy_git文件\n\ntheme中配置`_config.yml`文件，将被墙资源改为cdn资源。\n另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。\n目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。\n\n记录NEXT theme中一个bug：\npost_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。\n```\n  // 旧方法存在bug，无法选中指定toc\n  // $('.post-toc a').on('click', function (e) {\n  //   e.preventDefault();\n  //   var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));\n  //   var offset = $(targetSelector).offset().top;\n\n  //   hasVelocity ?\n  //     html.velocity('stop').velocity('scroll', {\n  //       offset: offset  + 'px',\n  //       mobileHA: false\n  //     }) :\n  //     $('html, body').stop().animate({\n  //       scrollTop: offset\n  //     }, 500);\n  // });\n```\n修改如下：\n```\n  $('.post-toc a').on('click', function (e) {\n    e.preventDefault();\n    $('html, body').animate({\n        scrollTop: $( $.attr(this, 'href') ).offset().top\n    }, 500);\n  });\n```\n\n## 如遇到hexo g无法生成source的情况，`npm ls --depth 0`列出缺失包，`npm install xxx --save`逐个下载\n\n入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。","slug":"配置-迁移hexo","published":1,"updated":"2019-06-12T05:45:34.705Z","_id":"cjwss6z74001r5mlwgvn2lask","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Blog托管在github，拉取代码后。</p>\n<ul>\n<li>下载nodejs，<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js官网</a></li>\n<li>安装hexo，<code>sudo npm install -g hexo</code></li>\n<li>保留原有deploy配置，执行<code>sudo npm install hexo-deployer-git --save</code></li>\n<li>安装server，<code>sudo npm install hexo-server</code></li>\n</ul>\n<p>如发生github pages init错误，删除.deploy_git文件</p>\n<p>theme中配置<code>_config.yml</code>文件，将被墙资源改为cdn资源。<br>另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。<br>目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。</p>\n<p>记录NEXT theme中一个bug：<br>post_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 旧方法存在bug，无法选中指定toc</span><br><span class=\"line\">// $(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">//   e.preventDefault();</span><br><span class=\"line\">//   var targetSelector = NexT.utils.escapeSelector(this.getAttribute(&apos;href&apos;));</span><br><span class=\"line\">//   var offset = $(targetSelector).offset().top;</span><br><span class=\"line\"></span><br><span class=\"line\">//   hasVelocity ?</span><br><span class=\"line\">//     html.velocity(&apos;stop&apos;).velocity(&apos;scroll&apos;, &#123;</span><br><span class=\"line\">//       offset: offset  + &apos;px&apos;,</span><br><span class=\"line\">//       mobileHA: false</span><br><span class=\"line\">//     &#125;) :</span><br><span class=\"line\">//     $(&apos;html, body&apos;).stop().animate(&#123;</span><br><span class=\"line\">//       scrollTop: offset</span><br><span class=\"line\">//     &#125;, 500);</span><br><span class=\"line\">// &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">  e.preventDefault();</span><br><span class=\"line\">  $(&apos;html, body&apos;).animate(&#123;</span><br><span class=\"line\">      scrollTop: $( $.attr(this, &apos;href&apos;) ).offset().top</span><br><span class=\"line\">  &#125;, 500);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"如遇到hexo-g无法生成source的情况，npm-ls-depth-0列出缺失包，npm-install-xxx-save逐个下载\"><a href=\"#如遇到hexo-g无法生成source的情况，npm-ls-depth-0列出缺失包，npm-install-xxx-save逐个下载\" class=\"headerlink\" title=\"如遇到hexo g无法生成source的情况，npm ls --depth 0列出缺失包，npm install xxx --save逐个下载\"></a>如遇到hexo g无法生成source的情况，<code>npm ls --depth 0</code>列出缺失包，<code>npm install xxx --save</code>逐个下载</h2><p>入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Blog托管在github，拉取代码后。</p>\n<ul>\n<li>下载nodejs，<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js官网</a></li>\n<li>安装hexo，<code>sudo npm install -g hexo</code></li>\n<li>保留原有deploy配置，执行<code>sudo npm install hexo-deployer-git --save</code></li>\n<li>安装server，<code>sudo npm install hexo-server</code></li>\n</ul>\n<p>如发生github pages init错误，删除.deploy_git文件</p>\n<p>theme中配置<code>_config.yml</code>文件，将被墙资源改为cdn资源。<br>另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。<br>目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。</p>\n<p>记录NEXT theme中一个bug：<br>post_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 旧方法存在bug，无法选中指定toc</span><br><span class=\"line\">// $(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">//   e.preventDefault();</span><br><span class=\"line\">//   var targetSelector = NexT.utils.escapeSelector(this.getAttribute(&apos;href&apos;));</span><br><span class=\"line\">//   var offset = $(targetSelector).offset().top;</span><br><span class=\"line\"></span><br><span class=\"line\">//   hasVelocity ?</span><br><span class=\"line\">//     html.velocity(&apos;stop&apos;).velocity(&apos;scroll&apos;, &#123;</span><br><span class=\"line\">//       offset: offset  + &apos;px&apos;,</span><br><span class=\"line\">//       mobileHA: false</span><br><span class=\"line\">//     &#125;) :</span><br><span class=\"line\">//     $(&apos;html, body&apos;).stop().animate(&#123;</span><br><span class=\"line\">//       scrollTop: offset</span><br><span class=\"line\">//     &#125;, 500);</span><br><span class=\"line\">// &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">  e.preventDefault();</span><br><span class=\"line\">  $(&apos;html, body&apos;).animate(&#123;</span><br><span class=\"line\">      scrollTop: $( $.attr(this, &apos;href&apos;) ).offset().top</span><br><span class=\"line\">  &#125;, 500);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"如遇到hexo-g无法生成source的情况，npm-ls-depth-0列出缺失包，npm-install-xxx-save逐个下载\"><a href=\"#如遇到hexo-g无法生成source的情况，npm-ls-depth-0列出缺失包，npm-install-xxx-save逐个下载\" class=\"headerlink\" title=\"如遇到hexo g无法生成source的情况，npm ls --depth 0列出缺失包，npm install xxx --save逐个下载\"></a>如遇到hexo g无法生成source的情况，<code>npm ls --depth 0</code>列出缺失包，<code>npm install xxx --save</code>逐个下载</h2><p>入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Flutter-基础知识/Widget生命周期.png","slug":"Widget生命周期.png","post":"cjwrfi4wn0000rrlwon0uo3oi","modified":0,"renderable":0},{"_id":"source/_posts/Flutter-基础知识/架构.jpeg","slug":"架构.jpeg","post":"cjwrfi4wn0000rrlwon0uo3oi","modified":0,"renderable":0},{"_id":"source/_posts/Flutter-基础知识/线程模型.png","slug":"线程模型.png","post":"cjwrfi4wn0000rrlwon0uo3oi","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjwrfi4wn0000rrlwon0uo3oi","category_id":"cjwrfi4wt0003rrlw7hdnzttp","_id":"cjwrfi4x0000drrlwqjrrziiw"},{"post_id":"cjwrfi4wz000brrlwm8jz8xq5","category_id":"cjwrfi4wx0008rrlw1j26l2is","_id":"cjwrfi4x4000jrrlwoemmjnm3"},{"post_id":"cjwrfi4wr0002rrlw6hajc2h5","category_id":"cjwrfi4wx0008rrlw1j26l2is","_id":"cjwrfi4x7000nrrlw8of8seaq"},{"post_id":"cjwrfi4x0000crrlw7xbioenp","category_id":"cjwrfi4wx0008rrlw1j26l2is","_id":"cjwrfi4x8000prrlwl677c0ec"},{"post_id":"cjwrfi4ww0006rrlwcadjivze","category_id":"cjwrfi4wx0008rrlw1j26l2is","_id":"cjwrfi4xe0014rrlw9s6z8gx7"},{"post_id":"cjwrfi4x1000grrlwudl95bby","category_id":"cjwrfi4xc000xrrlwfswiydih","_id":"cjwrfi4xk001irrlwg1bl69sj"},{"post_id":"cjwss6z5300005mlwh6hs4poc","category_id":"cjwrfi4wt0003rrlw7hdnzttp","_id":"cjwss6z6100065mlwytuo52zk"},{"post_id":"cjwss6z5a00015mlws9617c8p","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z6200095mlwaxghosya"},{"post_id":"cjwss6z5x00035mlwuxhaqjli","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z63000c5mlwu9v5fcy4"},{"post_id":"cjwss6z6000055mlwkn39i8ri","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z64000f5mlwkdjtfdjb"},{"post_id":"cjwss6z6200085mlwf19llik2","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z66000i5mlw1xwy1ymp"},{"post_id":"cjwss6z63000b5mlw3hjaiovq","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z67000l5mlwkp525w34"},{"post_id":"cjwss6z64000e5mlwsay9fpiw","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z68000o5mlwbvu7lfa4"},{"post_id":"cjwss6z65000h5mlwzmmtiu80","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z69000r5mlw4a1kvh6f"},{"post_id":"cjwss6z66000k5mlw7tyd6c8e","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z6a000u5mlw05sirw55"},{"post_id":"cjwss6z68000n5mlw3tuy503w","category_id":"cjwrfi4xc000xrrlwfswiydih","_id":"cjwss6z6c000y5mlwuojr8ld0"},{"post_id":"cjwss6z69000q5mlwbv10z95w","category_id":"cjwss6z6b000v5mlwglb1ejfl","_id":"cjwss6z6e00175mlwduc69fwi"},{"post_id":"cjwss6z6d00135mlwfxzy45rl","category_id":"cjwrfi4x1000errlwdf6jw445","_id":"cjwss6z6f001a5mlwfq5q8x21"},{"post_id":"cjwss6z6a000t5mlwibziqrxw","category_id":"cjwss6z6d00145mlw0h6e0m8j","_id":"cjwss6z6f001c5mlwos8azor9"},{"post_id":"cjwss6z6b000x5mlwuhet7y1l","category_id":"cjwss6z6e00185mlwfmvm35ev","_id":"cjwss6z6g001g5mlwum01fvv3"},{"post_id":"cjwss6z6c00115mlwcqz2ugyd","category_id":"cjwss6z6e00185mlwfmvm35ev","_id":"cjwss6z6g001j5mlw8b7u4ij9"},{"post_id":"cjwss6z6s001q5mlwd2xepzdb","category_id":"cjwss6z6e00185mlwfmvm35ev","_id":"cjwss6z82001u5mlwulxyxnpi"},{"post_id":"cjwss6z74001r5mlwgvn2lask","category_id":"cjwss6z6e00185mlwfmvm35ev","_id":"cjwss6z84001w5mlwoujqfl8t"}],"PostTag":[{"post_id":"cjwrfi4wn0000rrlwon0uo3oi","tag_id":"cjwrfi4wu0004rrlw9imgobzq","_id":"cjwrfi4wy000arrlwxvmtymj5"},{"post_id":"cjwrfi4wr0002rrlw6hajc2h5","tag_id":"cjwrfi4wy0009rrlw9t2yk7px","_id":"cjwrfi4x2000hrrlwmjlq1nzw"},{"post_id":"cjwrfi4ww0006rrlwcadjivze","tag_id":"cjwrfi4x9000rrrlwovievksl","_id":"cjwrfi4xd0012rrlwokvifonm"},{"post_id":"cjwrfi4wz000brrlwm8jz8xq5","tag_id":"cjwrfi4xf0018rrlwjc4uh0tt","_id":"cjwrfi4xl001nrrlwiefq3sl6"},{"post_id":"cjwrfi4wz000brrlwm8jz8xq5","tag_id":"cjwrfi4xi001errlwi36t2ji0","_id":"cjwrfi4xm001qrrlwet7khtrm"},{"post_id":"cjwrfi4x0000crrlw7xbioenp","tag_id":"cjwrfi4xk001jrrlwrr8msiqc","_id":"cjwrfi4xp001yrrlwtnd6958s"},{"post_id":"cjwrfi4x0000crrlw7xbioenp","tag_id":"cjwrfi4xm001rrrlwx7o6v7zj","_id":"cjwrfi4xp0020rrlw0v95qem6"},{"post_id":"cjwrfi4x1000grrlwudl95bby","tag_id":"cjwrfi4xq0022rrlwwgyzc7zj","_id":"cjwrfi4xs0029rrlw0mz0l4m8"},{"post_id":"cjwrfi4x1000grrlwudl95bby","tag_id":"cjwrfi4xq0025rrlwfxhnzpzc","_id":"cjwrfi4xs002brrlwy27dasyq"},{"post_id":"cjwss6z5a00015mlws9617c8p","tag_id":"cjwrfi4yc002irrlws9oplepv","_id":"cjwss6z6100075mlwqlukcn1t"},{"post_id":"cjwss6z5x00035mlwuxhaqjli","tag_id":"cjwrfi4x5000lrrlwjzk43pfa","_id":"cjwss6z63000a5mlwzx700ko8"},{"post_id":"cjwss6z6000055mlwkn39i8ri","tag_id":"cjwrfi4xs002arrlwxhgk9lms","_id":"cjwss6z64000d5mlwv747u688"},{"post_id":"cjwss6z6000055mlwkn39i8ri","tag_id":"cjwrfi4xt002crrlw3au3kmeq","_id":"cjwss6z65000g5mlw3edzlz1k"},{"post_id":"cjwss6z5300005mlwh6hs4poc","tag_id":"cjwrfi4wu0004rrlw9imgobzq","_id":"cjwss6z66000j5mlwyj2smsx5"},{"post_id":"cjwss6z5300005mlwh6hs4poc","tag_id":"cjwrfi4yi003errlwayu0ffrh","_id":"cjwss6z68000m5mlwramamfne"},{"post_id":"cjwss6z5300005mlwh6hs4poc","tag_id":"cjwss6z5o00025mlwhqxz7gay","_id":"cjwss6z69000p5mlw2xbygfxm"},{"post_id":"cjwss6z6200085mlwf19llik2","tag_id":"cjwrfi4yd002mrrlwachvzz3g","_id":"cjwss6z6a000s5mlweimh350z"},{"post_id":"cjwss6z63000b5mlw3hjaiovq","tag_id":"cjwrfi4yh0038rrlwx7f44kqc","_id":"cjwss6z6b000w5mlwx7l48so5"},{"post_id":"cjwss6z64000e5mlwsay9fpiw","tag_id":"cjwrfi4x1000frrlwlbmsi9jh","_id":"cjwss6z6c00105mlwzw2jzaww"},{"post_id":"cjwss6z65000h5mlwzmmtiu80","tag_id":"cjwrfi4x1000frrlwlbmsi9jh","_id":"cjwss6z6d00125mlwwhisgtdf"},{"post_id":"cjwss6z65000h5mlwzmmtiu80","tag_id":"cjwrfi4ye002vrrlw0gmak1bj","_id":"cjwss6z6e00155mlwlhklmzd7"},{"post_id":"cjwss6z65000h5mlwzmmtiu80","tag_id":"cjwrfi4yg0032rrlws4htqqg0","_id":"cjwss6z6e00165mlwzcnyrop4"},{"post_id":"cjwss6z65000h5mlwzmmtiu80","tag_id":"cjwrfi4yf002xrrlw6foch0w6","_id":"cjwss6z6f00195mlwctck0wa2"},{"post_id":"cjwss6z65000h5mlwzmmtiu80","tag_id":"cjwrfi4yh0037rrlw7ows8yn1","_id":"cjwss6z6f001b5mlwv2p7ggvc"},{"post_id":"cjwss6z66000k5mlw7tyd6c8e","tag_id":"cjwrfi4ye002vrrlw0gmak1bj","_id":"cjwss6z6g001e5mlwabfq2p9i"},{"post_id":"cjwss6z66000k5mlw7tyd6c8e","tag_id":"cjwrfi4yf002wrrlwr2pd6adz","_id":"cjwss6z6g001f5mlw3t9e58ed"},{"post_id":"cjwss6z66000k5mlw7tyd6c8e","tag_id":"cjwrfi4yf002xrrlw6foch0w6","_id":"cjwss6z6g001h5mlw9jvcepsb"},{"post_id":"cjwss6z66000k5mlw7tyd6c8e","tag_id":"cjwrfi4yf002yrrlw3gqtk5p3","_id":"cjwss6z6g001i5mlwv2v0ud71"},{"post_id":"cjwss6z68000n5mlw3tuy503w","tag_id":"cjwss6z5o00025mlwhqxz7gay","_id":"cjwss6z6g001k5mlwwnb8nefl"},{"post_id":"cjwss6z69000q5mlwbv10z95w","tag_id":"cjwrfi4ye002rrrlw52bp01im","_id":"cjwss6z6h001l5mlw8wg79i5k"},{"post_id":"cjwss6z6b000x5mlwuhet7y1l","tag_id":"cjwrfi4ym003prrlwxtvqcwbd","_id":"cjwss6z6h001m5mlwld7u0zzm"},{"post_id":"cjwss6z6c00115mlwcqz2ugyd","tag_id":"cjwrfi4yn003trrlwrfoyz8li","_id":"cjwss6z6h001n5mlwot5r0vav"},{"post_id":"cjwss6z6d00135mlwfxzy45rl","tag_id":"cjwrfi4yj003hrrlw9w5o68dw","_id":"cjwss6z6h001o5mlwfpnodqex"},{"post_id":"cjwss6z6a000t5mlwibziqrxw","tag_id":"cjwss6z6c000z5mlwu7x4kmv2","_id":"cjwss6z6h001p5mlw67s4j3v7"},{"post_id":"cjwss6z6s001q5mlwd2xepzdb","tag_id":"cjwrfi4yt0043rrlwfusc777o","_id":"cjwss6z7u001s5mlw4cirsg4k"},{"post_id":"cjwss6z6s001q5mlwd2xepzdb","tag_id":"cjwrfi4yt0044rrlwbdk5tmp8","_id":"cjwss6z80001t5mlwdyofqikc"},{"post_id":"cjwss6z6s001q5mlwd2xepzdb","tag_id":"cjwrfi4yu0045rrlw0769jk8o","_id":"cjwss6z84001v5mlw7kvc52tc"},{"post_id":"cjwss6z6s001q5mlwd2xepzdb","tag_id":"cjwrfi4yv0046rrlwrbomnjtw","_id":"cjwss6z85001x5mlwuzyoqhqf"},{"post_id":"cjwss6z74001r5mlwgvn2lask","tag_id":"cjwrfi4yq003yrrlw3l5o0ek7","_id":"cjwss6z86001y5mlwxny4k87g"}],"Tag":[{"name":"Flutter","_id":"cjwrfi4wu0004rrlw9imgobzq"},{"name":"ivar","_id":"cjwrfi4wy0009rrlw9t2yk7px"},{"name":"Objective-C","_id":"cjwrfi4x1000frrlwlbmsi9jh"},{"name":"NSNotificationCenter","_id":"cjwrfi4x5000lrrlwjzk43pfa"},{"name":"OC对象","_id":"cjwrfi4x9000rrrlwovievksl"},{"name":"load","_id":"cjwrfi4xf0018rrlwjc4uh0tt"},{"name":"initialize","_id":"cjwrfi4xi001errlwi36t2ji0"},{"name":"引用计数","_id":"cjwrfi4xk001jrrlwrr8msiqc"},{"name":"Weak表","_id":"cjwrfi4xm001rrrlwx7o6v7zj"},{"name":"iOS","_id":"cjwrfi4xp001xrrlwzv83m1cj"},{"name":"iOS 10","_id":"cjwrfi4xq0022rrlwwgyzc7zj"},{"name":"BUG","_id":"cjwrfi4xq0025rrlwfxhnzpzc"},{"name":"多线程","_id":"cjwrfi4xs002arrlwxhgk9lms"},{"name":"GCD","_id":"cjwrfi4xt002crrlw3au3kmeq"},{"name":"UIControl","_id":"cjwrfi4y7002grrlwxlbaj69b"},{"name":"UIControlState","_id":"cjwrfi4yc002irrlws9oplepv"},{"name":"UIViewController","_id":"cjwrfi4yd002mrrlwachvzz3g"},{"name":"warning","_id":"cjwrfi4ye002rrrlw52bp01im"},{"name":"类","_id":"cjwrfi4ye002vrrlw0gmak1bj"},{"name":"对象","_id":"cjwrfi4yf002wrrlwr2pd6adz"},{"name":"方法","_id":"cjwrfi4yf002xrrlw6foch0w6"},{"name":"autoreleasepool","_id":"cjwrfi4yf002yrrlw3gqtk5p3"},{"name":"属性","_id":"cjwrfi4yg0032rrlws4htqqg0"},{"name":"惰性实例化","_id":"cjwrfi4yh0037rrlw7ows8yn1"},{"name":"iOS基础知识","_id":"cjwrfi4yh0038rrlwx7f44kqc"},{"name":"笔记","_id":"cjwrfi4yi003errlwayu0ffrh"},{"name":"内存泄漏","_id":"cjwrfi4yj003hrrlw9w5o68dw"},{"name":"开源库阅读笔记","_id":"cjwrfi4yk003krrlwlam067nm"},{"name":"开发环境配置","_id":"cjwrfi4yl003nrrlwrv5o1rzk"},{"name":"Sublime Text","_id":"cjwrfi4ym003prrlwxtvqcwbd"},{"name":"Xcode","_id":"cjwrfi4yn003trrlwrfoyz8li"},{"name":"flutter","_id":"cjwrfi4yo003urrlwtwp2nuf9"},{"name":"hexo","_id":"cjwrfi4yq003yrrlw3l5o0ek7"},{"name":"bash","_id":"cjwrfi4yt0043rrlwfusc777o"},{"name":"Vim","_id":"cjwrfi4yt0044rrlwbdk5tmp8"},{"name":"Git","_id":"cjwrfi4yu0045rrlw0769jk8o"},{"name":"SVN","_id":"cjwrfi4yv0046rrlwrbomnjtw"},{"name":"踩坑记录","_id":"cjwss6z5o00025mlwhqxz7gay"},{"name":"YYModel","_id":"cjwss6z6c000z5mlwu7x4kmv2"}]}}