{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/proxy.pac","path":"proxy.pac","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"54735b4b06c1a145cd4ba0ecb1ce8147d94f85cc","modified":1534903881338},{"_id":"source/proxy.pac","hash":"22eb9c7dabf87da364301df511d7b28c69b5253a","modified":1534903881352},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1534903881353},{"_id":"source/favicon.ico","hash":"f5c47ad31dc1e6003379c88b562786bc7e2d114f","modified":1534903881352},{"_id":"themes/next/.DS_Store","hash":"f39d74071f6f79a6a42dd14ac9be2cf1bbf4d4f2","modified":1534903881353},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1534903881353},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1534903881353},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1534903881353},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1534903881353},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1534903881354},{"_id":"themes/next/_config.yml","hash":"a1bea3aa6e607e3b89506bcbe73c5193eb4e4c2c","modified":1552297805877},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1534903881354},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1534903881354},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1534903881354},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1534903881364},{"_id":"source/_posts/NSNotificationCenter小结.md","hash":"50200c3e13fcc8edbbd0ad8ed35a185924dd7f7c","modified":1552296792377},{"_id":"source/categories/index.md","hash":"acfa5cd4303e752e19079750e81b72ebc81a0013","modified":1534903881352},{"_id":"source/_posts/Objective-C基础知识小结.md","hash":"75ea4748c8975212ecdde401979e47ab97453739","modified":1552296796167},{"_id":"source/_posts/UISwitch在iOS 10中的BUG.md","hash":"c6102af77d77af88df5e1a5cbe3da8f2910127ea","modified":1552296800887},{"_id":"source/_posts/iOS基础：UIControlState.md","hash":"c9d40a6b19a4f6774baca3ac76dc362a5a0dc86c","modified":1552296780937},{"_id":"source/_posts/iOS基础：GCD.md","hash":"1eaa90b846c57b10a3f17adc2c60de2f41b4f38f","modified":1552296777811},{"_id":"source/_posts/iOS基础：UIViewController生命周期.md","hash":"d51cf7b8a4c60f139dafa26d223e417fc92d8d12","modified":1552296784077},{"_id":"source/_posts/iOS常见warning梳理.md","hash":"21cbbd172417335ea1991bb9301a040af0bc8101","modified":1552296807027},{"_id":"source/_posts/iOS基础：类、对象和方法.md","hash":"d262dca64b3cd145a9d5290e9a0343f1f9b1cdfa","modified":1552296775335},{"_id":"source/_posts/开发笔记：flutter中的好多坑.md","hash":"e433e86c47af0538a221aa92eeda5d182cf78fd6","modified":1554879592512},{"_id":"source/_posts/初学Objective-C.md","hash":"ab63c9db336dcaf35d85c3d791a60fc7a214e681","modified":1552296733740},{"_id":"source/_posts/开发笔记：Flutter.md","hash":"b63b00b57b0596cdcb7f2e526d94d9332483f317","modified":1552637991585},{"_id":"source/_posts/属性变量、实例变量、成员变量的内存泄漏测试.md","hash":"10ab833613b2b8e542e48183ed18dee21349e703","modified":1552296737413},{"_id":"source/_posts/开发笔记：iOS中的好多坑.md","hash":"9d9684ffba93a9818fe2adf3a162869526de2985","modified":1552296582822},{"_id":"source/_posts/开源库阅读笔记：YYKit-YYModel.md","hash":"fcb1077dca786de403a9bac29a8be1e5bef1aa4b","modified":1552296749765},{"_id":"source/_posts/配置：Sublime-Text3.md","hash":"42d09e90209937562c6d0ebb108dc1811d6bd74d","modified":1552297122978},{"_id":"source/_posts/配置：Xcode快捷键配置.md","hash":"13b78907fdb56bf5dd00326d79e55fd27d2cd85e","modified":1552296770730},{"_id":"source/_posts/配置：Vim-Git-SVN.md","hash":"77211fa98f88671592772ad56f10907dd8ff10d7","modified":1552296766753},{"_id":"source/_posts/配置：迁移hexo.md","hash":"5b02f5d1d8631f34d53ac593f4d0155764aef50d","modified":1552296757065},{"_id":"source/tags/index.md","hash":"17c523c2eac460241f5623b04b7a1ceb02e62c08","modified":1534903881352},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1534903881354},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1534903881354},{"_id":"themes/next/languages/en.yml","hash":"6fb5375936d6943bbda0a5272297d1b725ba9471","modified":1534903881354},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1534903881355},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1534903881355},{"_id":"themes/next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1534903881355},{"_id":"themes/next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1534903881355},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1534903881355},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1534903881355},{"_id":"themes/next/languages/zh-Hans.yml","hash":"69ac1d5dfa02d91b6cc4d881d86a68336c08e731","modified":1534903881355},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1534903881356},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1534903881356},{"_id":"themes/next/layout/_layout.swig","hash":"dd5ffebbf9bf09d3f0326110f4b796d4743a2e89","modified":1534903881356},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1534903881363},{"_id":"themes/next/layout/archive.swig","hash":"c9383f8b1dd07a1018ce11a9884b9c51e0731525","modified":1534903881363},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1534903881364},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1534903881363},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1534903881364},{"_id":"themes/next/layout/index.swig","hash":"e4da19270fd7d53d1ae345d14ea35f84fd9853e5","modified":1534903881363},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1534903881364},{"_id":"themes/next/scripts/.DS_Store","hash":"de653034730e766ecdf333bb705d0bec0dbb123e","modified":1534903881364},{"_id":"themes/next/source/.DS_Store","hash":"6d85854ca2216dd3fd326ce5e834a6a7ed8cc8e8","modified":1534903881365},{"_id":"themes/next/test/.DS_Store","hash":"86aaef889514f63213877b6166c2177fd70fc322","modified":1534903881407},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1534903881407},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1534903881407},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1534903881407},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881384},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1534903881356},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1534903881356},{"_id":"themes/next/layout/_macro/post.swig","hash":"f3e7b2ac16c431f9e836f80259e06354b3637fc2","modified":1534903881356},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1a77843ce5eac62151dc3d38f0a36c43e19e1a74","modified":1534903881357},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1534903881357},{"_id":"themes/next/layout/_partials/comments.swig","hash":"b73f9443bee2d3ea383aad52e49ffca8aa97dcc2","modified":1534903881357},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1534903881357},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4fe588ff8ba8587885c2936db2df490774f89e10","modified":1534903881357},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b0c495b8154ef8b2d2cb0a554e164ff22cdc962","modified":1534903881357},{"_id":"themes/next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1534903881358},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1534903881358},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1534903881358},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1534903881360},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1534903881360},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1534903881360},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1534903881363},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1534903881365},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1534903881365},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1534903881365},{"_id":"themes/next/source/images/.DS_Store","hash":"58244c2df0bdade6749a9c1493dedfd6dad142ce","modified":1534903881384},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1534903881384},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1534903881385},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1534903881385},{"_id":"themes/next/source/images/avatar.gif","hash":"f5c47ad31dc1e6003379c88b562786bc7e2d114f","modified":1534903881385},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1534903881385},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1534903881385},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1534903881385},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1534903881385},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1534903881386},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1534903881386},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1534903881386},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1534903881387},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1534903881387},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1534903881387},{"_id":"source/_posts/Objective-C基础知识小结/调试01.png","hash":"f2ef6cf8a42ac2d08c22ca8d3f80eba65933b107","modified":1534903881346},{"_id":"source/_posts/Objective-C基础知识小结/内存空间.png","hash":"226115752acce15576132ce87ebbe837c82ba9d3","modified":1534903881346},{"_id":"source/_posts/开源库阅读笔记：YYKit-YYModel/对象模型图.png","hash":"d01543706db03c16aa6ebd09c3f631429cfc4d77","modified":1534903881351},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881360},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881360},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881376},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881376},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881376},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881383},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534903881384},{"_id":"source/_posts/Objective-C基础知识小结/GCD03.png","hash":"59085025d36af03f694f6d71f5924b8ed67d8146","modified":1534903881345},{"_id":"source/_posts/Objective-C基础知识小结/调试02.png","hash":"60697049b326a1bb58b9105fdbe9689b0cfdde68","modified":1534903881347},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1534903881357},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1534903881358},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1534903881359},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1534903881358},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1534903881359},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1534903881359},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1534903881359},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1534903881359},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1534903881360},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1534903881360},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"7f7148c8f52e4d3cfc070d964160362179fa8e91","modified":1534903881363},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1534903881363},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1534903881363},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"656c60c7d93f110a9e941a5fca617ee277fed707","modified":1534903881376},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1534903881376},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1534903881376},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e2ff8aab16ce9b5282c4cdf6375c152466fb804c","modified":1534903881384},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f5a47ced09d79389ac8c682b925914c5e43b868c","modified":1534903881383},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1534903881383},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1534903881388},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1534903881389},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1534903881388},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1534903881389},{"_id":"themes/next/source/js/src/post-details.js","hash":"cd067c34beb799df5ee8736352786f8fffe15ae5","modified":1534903881389},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1534903881390},{"_id":"themes/next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1534903881390},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1534903881390},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1534903881390},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1534903881395},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1534903881395},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1534903881395},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1534903881395},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1534903881397},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1534903881397},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1534903881397},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1534903881397},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1534903881398},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1534903881403},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1534903881404},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1534903881405},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1534903881405},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1534903881405},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1534903881406},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1534903881406},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1534903881406},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1534903881404},{"_id":"source/_posts/Objective-C基础知识小结/GCD02.png","hash":"c880d194ae36e56673eedb6b1b15022df7cbb66d","modified":1534903881344},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"f9c6ee91c2a615edd8ca26edcc8a66b71883c238","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1534903881361},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"bff3b18f56175c53f3bc6d733166c4d998e08732","modified":1534903881362},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1534903881362},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1534903881375},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1534903881366},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1534903881365},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1534903881366},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1534903881366},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1534903881373},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1534903881375},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1534903881375},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1534903881375},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1534903881376},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1534903881376},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"399f896e6c0d8adbfc870cc5284eddf4b557e783","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"7eb54d3b01c704797ef048401da40dbe1dcc02e7","modified":1534903881377},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1534903881378},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1534903881378},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1534903881379},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1534903881380},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1534903881380},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1534903881381},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1534903881382},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1534903881383},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1534903881389},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1534903881391},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1534903881391},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1534903881392},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1534903881392},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1534903881392},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1534903881393},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1534903881394},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1534903881394},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1534903881395},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1534903881396},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1534903881396},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1534903881398},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1534903881399},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1534903881399},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1534903881405},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1534903881405},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1534903881403},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1534903881401},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1534903881400},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"e63dc7cea055ca60a95d286f32349d88b10c5a4d","modified":1534903881406},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1534903881403},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1534903881366},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1534903881368},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1534903881368},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4da051c7f3924fa2db1e73c55b2baf1c2c150255","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1534903881369},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1534903881370},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d8d28120ee267f12d576577164b259b7fc7abc8d","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1534903881371},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"4eb18b12fa0ea6c35925d9a64f64e2a7dae8c7fd","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1534903881372},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1534903881373},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1534903881374},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1534903881375},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1534903881375},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1534903881378},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1534903881378},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1534903881380},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1534903881393},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1534903881393},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1534903881393},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1534903881394},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1534903881394},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1534903881394},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1534903881402},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1534903881401},{"_id":"source/_posts/Objective-C基础知识小结/GCD01.png","hash":"923d04db1606dcad66289c1675af1a06b89dcac8","modified":1534903881343},{"_id":"public/categories/index.html","hash":"abe3b446778191d68cd8e3569105aacc5588b777","modified":1554879670136},{"_id":"public/tags/index.html","hash":"5d5af343f153f05c9e3e7cf03a273072340147a7","modified":1554879670136},{"_id":"public/2019/03/11/开发笔记：Flutter/index.html","hash":"11fa22f550111bb37c1a6ac4954b6c4b8feb53d2","modified":1554879670137},{"_id":"public/categories/iOS基础知识/index.html","hash":"afe017933fa2e0a2898b992ddf3022717d7e1d15","modified":1554879670137},{"_id":"public/categories/笔记/index.html","hash":"2a658a18ebc981b69048d85b2b4f99419b4aa23a","modified":1554879670137},{"_id":"public/categories/开发配置/index.html","hash":"721754393be6aaa089261fc912dc1aeea675e63e","modified":1554879670137},{"_id":"public/tags/Objective-C/index.html","hash":"431371526f77035225b4ceee3e1a6d56376e3792","modified":1554879670137},{"_id":"public/tags/NSNotificationCenter/index.html","hash":"8665189d49c202a268583d3da95f65e867c3aa6a","modified":1554879670137},{"_id":"public/tags/iOS/index.html","hash":"d78aa26c14ead751a9d20812d554f49c12bcacaf","modified":1554879670137},{"_id":"public/tags/iOS-10/index.html","hash":"74bd64f2ffc891825d06468fc96c897a30424745","modified":1554879670137},{"_id":"public/tags/BUG/index.html","hash":"ef5219828ffe7281ebcecc14632d8b225e0dba07","modified":1554879670137},{"_id":"public/tags/UIControl/index.html","hash":"90fc7f3ea3703753c823816108be2fa66eddc0ca","modified":1554879670138},{"_id":"public/tags/UIControlState/index.html","hash":"2080bc0f7bf7f013d4fa0e49cfb2f3696e162183","modified":1554879670138},{"_id":"public/tags/UIViewController/index.html","hash":"c96fff3b80fdda636d531bcd24e1bef4e9b32bd8","modified":1554879670138},{"_id":"public/tags/多线程/index.html","hash":"a793d12f7bb2ea241632473f940def6ea99de47b","modified":1554879670138},{"_id":"public/tags/GCD/index.html","hash":"612548b0500603af2fd865d1add1131a1c319172","modified":1554879670138},{"_id":"public/tags/warning/index.html","hash":"70470da1ce2b3a20393b80075f1bd91a61b3eac8","modified":1554879670138},{"_id":"public/tags/笔记/index.html","hash":"5307cbea3566fa17b081707b2f7ad0efb8ff9a33","modified":1554879670138},{"_id":"public/tags/flutter/index.html","hash":"77e5be4ae3f0cc42b0cce18287fdd02093fe18b3","modified":1554879670138},{"_id":"public/tags/程序设计基础/index.html","hash":"9da5ed22973b9c91af4bf70b4543b19ac3bd2cdd","modified":1554879670138},{"_id":"public/tags/类/index.html","hash":"257df9ef73d10cc27a7b6885003c356af614b294","modified":1554879670138},{"_id":"public/tags/对象/index.html","hash":"289845ca70da61dd211fa445260a371878f9dd59","modified":1554879670138},{"_id":"public/tags/方法/index.html","hash":"e5267faea0651cf06e38634589d4c9cd055963b0","modified":1554879670138},{"_id":"public/tags/autoreleasepool/index.html","hash":"8a5f0b76c6f8acd245eb69962a714745d465e3cb","modified":1554879670139},{"_id":"public/tags/属性/index.html","hash":"1c2e0ed1ad86b37439521a5cb945cdfafe89d8b4","modified":1554879670139},{"_id":"public/tags/惰性实例化/index.html","hash":"b5661b934d2d39072be26846d2183e064f46656d","modified":1554879670139},{"_id":"public/tags/Flutter/index.html","hash":"c29cfd6161775f9b39322b4246f21341549e644b","modified":1554879670139},{"_id":"public/tags/内存泄漏/index.html","hash":"8026326c96de01a3adccd7958497f29136b9917c","modified":1554879670139},{"_id":"public/tags/开源库阅读笔记/index.html","hash":"d1facb5d390a81b794dcb21167a41518d0d5cd9e","modified":1554879670139},{"_id":"public/tags/开发环境配置/index.html","hash":"5b40a0699400445e9dcfac738c039894b80ab0a2","modified":1554879670139},{"_id":"public/tags/Sublime-Text/index.html","hash":"d72c40edb099114bf0f1b5adbb7164ec3a818d19","modified":1554879670139},{"_id":"public/tags/Xcode/index.html","hash":"404a59047d9c1d35910f6519cb7e3948a4d314e4","modified":1554879670139},{"_id":"public/tags/bash/index.html","hash":"cb04ddaa151e4ffd0b015161400e54ad433622d6","modified":1554879670139},{"_id":"public/tags/Vim/index.html","hash":"7925c45cfc326196ad70821978ec842652a6f803","modified":1554879670139},{"_id":"public/tags/Git/index.html","hash":"f7217846938986a7cdd5915ff424a4147f1589ec","modified":1554879670139},{"_id":"public/tags/hexo/index.html","hash":"df702e18cfe6efd0ebac8d55ceefd008478a7980","modified":1554879670139},{"_id":"public/tags/SVN/index.html","hash":"168b233c60cea65b143fc8c98bcfc084703f921a","modified":1554879670139},{"_id":"public/archives/page/2/index.html","hash":"36233f1394dcbddf2cfade8a6bd68c751d13d0f6","modified":1554879670140},{"_id":"public/archives/2016/page/2/index.html","hash":"0760ec61479c5af0842ba625b3f11c37bff84578","modified":1554879670140},{"_id":"public/archives/2016/08/index.html","hash":"13e42e16e812c704564179b16e19c9636689276b","modified":1554879670140},{"_id":"public/archives/2016/09/index.html","hash":"b702c1684c159fe088c3fd83e9fb67787dbd9311","modified":1554879670140},{"_id":"public/archives/2016/10/index.html","hash":"8c69a90fd568a0b43bd5c7c30c51edf4125e995b","modified":1554879670140},{"_id":"public/archives/2016/12/index.html","hash":"a2053199496d00df4bdb7c6c5128c7e9c12da3fc","modified":1554879670140},{"_id":"public/archives/2017/index.html","hash":"d82599ffab9925b9bab05885861c3e99dee3f880","modified":1554879670140},{"_id":"public/archives/2017/01/index.html","hash":"562385ea6a225835e023e313ff0cd2754d1f8f9d","modified":1554879670140},{"_id":"public/archives/2017/03/index.html","hash":"15863447e247910b38808a05ecf7b20c498a4c3a","modified":1554879670140},{"_id":"public/archives/2018/index.html","hash":"03f64cb1eb927d7f9c3b5d87f73af0becdd6ea3e","modified":1554879670140},{"_id":"public/archives/2018/01/index.html","hash":"ec215a41f9ee37ab57d506295ddb48c8fc3839eb","modified":1554879670140},{"_id":"public/archives/2018/07/index.html","hash":"ad413bee35d3fd97b6ea49a53a870fd6ce29394c","modified":1554879670140},{"_id":"public/archives/2019/index.html","hash":"e7cb5e5160b07473ed9555bc6ef486a9ca519710","modified":1554879670140},{"_id":"public/archives/2019/03/index.html","hash":"3da29afc3e209e6d19c9fedd869294e38381bf5e","modified":1554879670140},{"_id":"public/2018/07/26/iOS常见warning梳理/index.html","hash":"96b0ce57fb4955dbc6c435df8df37f56dd984570","modified":1554879670140},{"_id":"public/2018/07/18/属性变量、实例变量、成员变量的内存泄漏测试/index.html","hash":"4f14733fcd24888ee4de5e981ed0fd83d94e178d","modified":1554879670141},{"_id":"public/2018/01/02/NSNotificationCenter小结/index.html","hash":"58e72321cf5ade3e30c3860731538b293509fdcc","modified":1554879670141},{"_id":"public/2017/03/13/开源库阅读笔记：YYKit-YYModel/index.html","hash":"8fdb659e7ceab15a7af55cd560fc2fffd5dce8de","modified":1554879670141},{"_id":"public/2017/01/04/iOS基础：UIViewController生命周期/index.html","hash":"5a71c1291a3df5af90236a7ea4d34412f2378c6c","modified":1554879670141},{"_id":"public/2016/12/19/开发笔记：iOS中的好多坑/index.html","hash":"96904ba47599054de0340773c2e887adb1b192c8","modified":1554879670141},{"_id":"public/2016/10/08/iOS基础：UIControlState/index.html","hash":"33e366b7a63daf861d3acf150c27db0bf320b1c7","modified":1554879670141},{"_id":"public/2016/09/29/UISwitch在iOS 10中的BUG/index.html","hash":"c65b7c6a4b6da64736da735ed8386c748b5f631c","modified":1554879670141},{"_id":"public/2016/09/21/配置：Sublime-Text3/index.html","hash":"0bf51c3920eb6dff05f2d6ecc8c1c9e9ad7e170c","modified":1554879670141},{"_id":"public/2016/09/21/配置：Vim-Git-SVN/index.html","hash":"da63b46e60da20a273a0d1e4050c900ebe1cafc5","modified":1554879670141},{"_id":"public/2016/09/21/配置：Xcode快捷键配置/index.html","hash":"39d149f9e2ccbc719dc861342fb80019a64b0c64","modified":1554879670141},{"_id":"public/2016/09/17/Objective-C基础知识小结/index.html","hash":"acd31137de7e8a1347c0c518a72f8eea1784c609","modified":1554879670142},{"_id":"public/2016/09/03/配置：迁移hexo/index.html","hash":"92c2772f0749ed953aed86c5dc60f53099eeae3a","modified":1554879670142},{"_id":"public/2016/08/16/初学Objective-C/index.html","hash":"f77b3e5705d7fbdbd939ec0b84480a8009221bca","modified":1554879670142},{"_id":"public/2016/08/14/iOS基础：类、对象和方法/index.html","hash":"2dc16326077b8390337e8e9c878c8fab90561b4b","modified":1554879670142},{"_id":"public/2016/08/11/iOS基础：GCD/index.html","hash":"051de444e68ff2d70af444b1360f1f4249e025e7","modified":1554879670142},{"_id":"public/index.html","hash":"85619a9b4778eba5515255777d01ea442542d782","modified":1554879670142},{"_id":"public/page/2/index.html","hash":"a186350568777f07776ab36f9ab7b6b928c0e7b8","modified":1554879670142},{"_id":"public/archives/index.html","hash":"84f5e705c4e3155fbee14c725712cf42620ed119","modified":1554879670142},{"_id":"public/archives/2016/index.html","hash":"52d9eb2784f47b3ffe781ba016fe707f0496f665","modified":1554879670142},{"_id":"public/archives/2019/04/index.html","hash":"e305186a709c00b9ba626088d9e30b3fe559a33f","modified":1554879670149},{"_id":"public/2019/04/10/开发笔记：flutter中的好多坑/index.html","hash":"b1893a3fb80e82796871fa0f8f3bf2b64f135c67","modified":1554879670149},{"_id":"public/CNAME","hash":"54735b4b06c1a145cd4ba0ecb1ce8147d94f85cc","modified":1554879670154},{"_id":"public/proxy.pac","hash":"22eb9c7dabf87da364301df511d7b28c69b5253a","modified":1554879670155},{"_id":"public/favicon.ico","hash":"f5c47ad31dc1e6003379c88b562786bc7e2d114f","modified":1554879670155},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1554879670155},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1554879670155},{"_id":"public/images/avatar.gif","hash":"f5c47ad31dc1e6003379c88b562786bc7e2d114f","modified":1554879670155},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1554879670155},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1554879670155},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1554879670155},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1554879670155},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1554879670155},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1554879670155},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1554879670156},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1554879670156},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1554879670156},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1554879670156},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1554879670156},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1554879670156},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1554879670156},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1554879670156},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1554879670156},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1554879670156},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1554879670156},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1554879670156},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1554879670156},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1554879670156},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1554879670156},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1554879670583},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1554879670585},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1554879670586},{"_id":"public/2017/03/13/开源库阅读笔记：YYKit-YYModel/对象模型图.png","hash":"d01543706db03c16aa6ebd09c3f631429cfc4d77","modified":1554879670586},{"_id":"public/2016/09/17/Objective-C基础知识小结/调试01.png","hash":"f2ef6cf8a42ac2d08c22ca8d3f80eba65933b107","modified":1554879670586},{"_id":"public/2016/09/17/Objective-C基础知识小结/内存空间.png","hash":"226115752acce15576132ce87ebbe837c82ba9d3","modified":1554879670586},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1554879670591},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1554879670591},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1554879670591},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1554879670591},{"_id":"public/js/src/post-details.js","hash":"cd067c34beb799df5ee8736352786f8fffe15ae5","modified":1554879670591},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1554879670592},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1554879670592},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1554879670592},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1554879670592},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1554879670592},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1554879670592},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1554879670592},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1554879670592},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1554879670592},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1554879670592},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1554879670592},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1554879670592},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1554879670592},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1554879670592},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1554879670592},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1554879670592},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1554879670592},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1554879670592},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1554879670592},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1554879670593},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1554879670593},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1554879670593},{"_id":"public/css/main.css","hash":"26b830026ec1ca6f2a84c8b61ecb389f3ee1c949","modified":1554879670593},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1554879670593},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1554879670593},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1554879670593},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1554879670593},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1554879670593},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1554879670593},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1554879670593},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1554879670593},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1554879670593},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1554879670593},{"_id":"public/2016/09/17/Objective-C基础知识小结/GCD03.png","hash":"59085025d36af03f694f6d71f5924b8ed67d8146","modified":1554879670593},{"_id":"public/2016/09/17/Objective-C基础知识小结/调试02.png","hash":"60697049b326a1bb58b9105fdbe9689b0cfdde68","modified":1554879670593},{"_id":"public/2016/09/17/Objective-C基础知识小结/GCD02.png","hash":"c880d194ae36e56673eedb6b1b15022df7cbb66d","modified":1554879670605},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1554879670608},{"_id":"public/2016/09/17/Objective-C基础知识小结/GCD01.png","hash":"923d04db1606dcad66289c1675af1a06b89dcac8","modified":1554879670618}],"Category":[{"name":"iOS基础知识","_id":"cjuav7i0n0003nflwz0cj226o"},{"name":"笔记","_id":"cjuav7i0w000dnflw616i1g9v"},{"name":"开发配置","_id":"cjuav7i1e0015nflwmg36uoh9"}],"Data":[],"Page":[{"title":"categories","date":"2016-08-13T04:06:11.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-08-13 12:06:11\ntype: \"categories\"\n---\n","updated":"2018-08-22T02:11:21.352Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjuav7i0k0001nflwhxc855rm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-08-13T04:06:24.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-08-13 12:06:24\ntype: \"tags\"\n---\n","updated":"2018-08-22T02:11:21.352Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjuav7i4l003onflwciy7367a","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"NSNotificationCenter小结","date":"2018-01-02T06:51:20.000Z","_content":"\n## 线程问题\n日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。\nNSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)];\n    test.backgroundColor = [UIColor blueColor];\n    [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:test];\n    \n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@\"asycObserverNotification\" object:nil];\n    });\n    \n    UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)];\n    test1.backgroundColor = [UIColor blueColor];\n    [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:test1];\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@\"asycPostNotification\" object:nil];\n}\n\n// 主线程发\n- (void)syncPost\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"asycObserverNotification\" object:nil];\n}\n\n// 子线程收\n- (void)lisetner\n{\n    NSLog(@\"Async Observer! - %@\", [NSThread currentThread]);\n}\n\n// 子线程发\n- (void)asyncPost\n{\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"asycPostNotification\" object:nil];\n    });\n}\n\n// 主线程收\n- (void)lisetner1\n{\n    NSLog(@\"Async Post! - %@\", [NSThread currentThread]);\n    self.view.backgroundColor = [UIColor grayColor];\n    [self.view layoutIfNeeded];\n}\n```\n\n执行结果如下：\n```\n2018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - <NSThread: 0x1c407d4c0>{number = 1, name = main}\n\n2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - <NSThread: 0x1c027dc40>{number = 5, name = (null)}\n```","source":"_posts/NSNotificationCenter小结.md","raw":"---\ntitle: NSNotificationCenter小结\ndate: 2018-01-02 14:51:20\ncategories: iOS基础知识\ntags:\n    - Objective-C\n    - NSNotificationCenter\n---\n\n## 线程问题\n日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。\nNSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)];\n    test.backgroundColor = [UIColor blueColor];\n    [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:test];\n    \n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@\"asycObserverNotification\" object:nil];\n    });\n    \n    UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)];\n    test1.backgroundColor = [UIColor blueColor];\n    [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:test1];\n    \n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@\"asycPostNotification\" object:nil];\n}\n\n// 主线程发\n- (void)syncPost\n{\n    [[NSNotificationCenter defaultCenter] postNotificationName:@\"asycObserverNotification\" object:nil];\n}\n\n// 子线程收\n- (void)lisetner\n{\n    NSLog(@\"Async Observer! - %@\", [NSThread currentThread]);\n}\n\n// 子线程发\n- (void)asyncPost\n{\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        [[NSNotificationCenter defaultCenter] postNotificationName:@\"asycPostNotification\" object:nil];\n    });\n}\n\n// 主线程收\n- (void)lisetner1\n{\n    NSLog(@\"Async Post! - %@\", [NSThread currentThread]);\n    self.view.backgroundColor = [UIColor grayColor];\n    [self.view layoutIfNeeded];\n}\n```\n\n执行结果如下：\n```\n2018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - <NSThread: 0x1c407d4c0>{number = 1, name = main}\n\n2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - <NSThread: 0x1c027dc40>{number = 5, name = (null)}\n```","slug":"NSNotificationCenter小结","published":1,"updated":"2019-03-11T09:33:12.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0h0000nflwxnqrdwqf","content":"<h2 id=\"线程问题\"><a href=\"#线程问题\" class=\"headerlink\" title=\"线程问题\"></a>线程问题</h2><p>日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。<br>NSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)];</span><br><span class=\"line\">    test.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    [self.view addSubview:test];</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@&quot;asycObserverNotification&quot; object:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)];</span><br><span class=\"line\">    test1.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    [self.view addSubview:test1];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@&quot;asycPostNotification&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 主线程发</span><br><span class=\"line\">- (void)syncPost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycObserverNotification&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子线程收</span><br><span class=\"line\">- (void)lisetner</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Async Observer! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子线程发</span><br><span class=\"line\">- (void)asyncPost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycPostNotification&quot; object:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 主线程收</span><br><span class=\"line\">- (void)lisetner1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Async Post! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    self.view.backgroundColor = [UIColor grayColor];</span><br><span class=\"line\">    [self.view layoutIfNeeded];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - &lt;NSThread: 0x1c407d4c0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - &lt;NSThread: 0x1c027dc40&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"线程问题\"><a href=\"#线程问题\" class=\"headerlink\" title=\"线程问题\"></a>线程问题</h2><p>日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。<br>NSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)];</span><br><span class=\"line\">    test.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    [self.view addSubview:test];</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@&quot;asycObserverNotification&quot; object:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)];</span><br><span class=\"line\">    test1.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    [self.view addSubview:test1];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@&quot;asycPostNotification&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 主线程发</span><br><span class=\"line\">- (void)syncPost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycObserverNotification&quot; object:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子线程收</span><br><span class=\"line\">- (void)lisetner</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Async Observer! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 子线程发</span><br><span class=\"line\">- (void)asyncPost</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycPostNotification&quot; object:nil];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 主线程收</span><br><span class=\"line\">- (void)lisetner1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Async Post! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    self.view.backgroundColor = [UIColor grayColor];</span><br><span class=\"line\">    [self.view layoutIfNeeded];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>执行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - &lt;NSThread: 0x1c407d4c0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - &lt;NSThread: 0x1c027dc40&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Objective-C基础知识小结","date":"2016-09-17T12:29:17.000Z","_content":"\n# 内存\n\n## 堆栈\n**栈区（stack）**\n由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。\n\n**堆区(heap)**\nheap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。\n<!-- more -->\n\n**全局区（static）**\n全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。\n\n**文字常量区**\n常量字符串就是放在这里的。 程序结束后由系统释放。\n\n**程序代码区**\n存放函数体的二进制代码。\n\n![内存空间](/内存空间.png)\n\n## 引用计数\n\n### 4个原则\n- 自己生成的对象，自己持有。\n- 非自己生成的对象，自己也能持有。\n- 不再需要自己持有的对象时释放。\n- 非自己持有的对象无法释放。\n\n### 对象操作\n| 对象操作         | Objective-C方法            |\n| --------------- |:-------------------------:|\n| 生成并持有对象    | alloc/new/copy/mutableCopy|\n| 持有对象         | retain                    |\n| 释放对象         | release                   |\n| 废弃对象         | dealloc                   |\n\n### ARC\nARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。\n\n## 自动释放池\n对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。\n\n- 对象执行autorelease方法时会将对象添加到自动释放池中。\n- 当自动释放池销毁时自动释放池中所有对象作release操作。\n- 对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。\n\n## 属性参数\n- assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。\n- retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。\n- copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。\n- unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。\n- weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。\n- strong: （ARC中默认属性类型）相当于retain。\n\n## 实例\n### 测试1\n```\n#import <Foundation/Foundation.h>\n\n@interface TestARC : NSObject\n@property (nonatomic, strong) NSString *string;\n@property (nonatomic, assign) NSString *stringAssign;\n@property (nonatomic, retain) NSString *stringRetain;\n@property (nonatomic, copy) NSString *stringCopy;\n@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;\n@property (nonatomic, weak) NSString *stringWeak;\n@property (nonatomic, strong) NSString *stringStrong;\n@end\n```\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringAssign = testObj.string;\n        testObj.string = nil;\n    }\n    \n    NSLog(@\"string = %@\", testObj.string);\n    NSLog(@\"stringAssign = %@\", testObj.stringAssign);\n    \n    return 0;\n}\n```\nstringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。\n\n### 测试2\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringWeak = testObj.string;\n//        testObj.stringStrong = testObj.string;\n        testObj.string = nil;\n    }\n    \n    NSLog(@\"string = %@\", testObj.string);\n    NSLog(@\"stringWeak = %@\", testObj.stringWeak);\n    \n    return 0;\n}\n```\n```\n2016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)\n2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null)\n```\n```\n2016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)\n2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1\n```\n强指针指向对象时，内存没有被释放。\n\n### 测试3\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringRetain = testObj.string;\n        testObj.stringCopy = testObj.string;\n        testObj.stringStrong = testObj.string;\n        testObj.string = nil;\n    }\n    \n    return 0;\n}\n```\n```\n(lldb) p testObj.string\n(NSString *) $0 = nil\n(lldb) p testObj.stringRetain\n(__NSCFString *) $1 = 0x00000001005036c0 @\"string1\"\n(lldb) p testObj.stringCopy\n(NSTaggedPointerString *) $2 = 0x31676e6972747375 @\"string1\"\n(lldb) p testObj.stringStrong\n(__NSCFString *) $3 = 0x00000001005036c0 @\"string1\"\n```\n\n# Block\n带有自动变量（局部变量）的匿名函数。形如int (^count)(int) =  ^int (int count){return count+1;}; \n声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。\n赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。\n\n## 类型\n- _NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。\n- _NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。\n- _NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。\n\n## 注意点\n- block会截获外部自动变量的瞬间值。\n- block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。\n- 使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如`__weak typeof(self) weakSelf = self;`新建一个指针的方式解决，在block内部使用__weak类型的对象。\n- block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。\n\n## 实例\n```\n#import <Foundation/Foundation.h>\n\n@interface TestBlock : NSObject\ntypedef NSString *(^testBlockStruct)(NSString *);\n@property (nonatomic, strong) testBlockStruct completionBlock;\n\n- (void)handleBlock:(NSString *)string;\n@end\n```\n```\n#import \"TestBlock.h\"\n\n@implementation TestBlock\n- (void)handleBlock:(NSString *)string {\n    if (self.completionBlock) {\n        NSLog(@\"%@\", self.completionBlock(string));\n    }\n}\n@end\n```\n```\n#import \"TestBlock.h\"\n\nint main(int argc, const char * argv[]) {\n    TestBlock *testBlock = [[TestBlock alloc] init];\n    \n    NSString *tempString = @\"Baidu\";\n    testBlock.completionBlock = ^NSString *(NSString *string){\n        // 使用外部的局部变量tempString\n        NSLog(@\"Block is here with %@ at %@.\", string, tempString);\n        return @\"Block is completed.\";\n    };\n    // 改变局部变量tempString，打印出的block截获了其瞬间值\"Baidu\"\n    tempString = @\"Beijing\";\n    \n    [testBlock handleBlock:@\"LeeOuf\"];\n    return 0;\n}\n```\n```\n2016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeeOuf at Baidu.\n2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed.\n```\n\n# GCD\nGCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。\n\n## Dispatch Queue\n- DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。\n- DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。\n\n获取Dispatch Queue方法: \n- dispatch_get_main_queue()\n- dispatch_get_global_queue()\n- dispatch_queue_create()\n\n## 方法列表\n![queue.h](/GCD01.png)\n![group.h](/GCD02.png)\n![once.h](/GCD02.png)\n\n# 补充\n1. MRC不能使用weak，使用什么替代？\n2. NSString为什么要使用copy?\n3. block底层forwarding实现\n4. 那些部分不能使用async操作\n5. ARC和MRC下的循环引用\n6. 如何检测VC的循环引用\n7. Category的好处，Category中是否可以加property？\n8. 类别和扩展的区别？为啥要使用扩展\n9. Category中一定添加property，如何实现？\n10. Category中添加和原有类的方法，是否覆盖？  \n-------------------------------- \n1. assign\n2. 因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。\n3. `__Block_byref_val_0`结构体实例有一个成员变量`__forwarding`持有只想该实例自身的指针。\nstatic void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {\n    struct Block_byref **destp = (struct Block_byref **)dest;\n    struct Block_byref *src = (struct Block_byref *)arg;\n    // src points to stack\n    struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);\n    copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)\n    src->forwarding = copy;  // patch stack to point to heap copy\n    copy->size = src->size;\n    // assign byref data block pointer into new Block\n    _Block_assign(src->forwarding, (void **)destp);\n}\n根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。\n4. UI部分。\n5. ARC中可以新建一个__weak修饰符修饰的指针（如__weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用__block修饰（如__block typeof(self) weakSelf = self;）。\n6. \n(1) Product->Profile，查看Leaks，如：\n![Leaks](/调试01.png)\n![Leaks结果](/调试02.png)\n(2) lldb直接print，查看对象是否为nil。\n7&9. 优点：不使用继承而为现有类添加新方法。\nCategory用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。\n8&10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。\n（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。\n","source":"_posts/Objective-C基础知识小结.md","raw":"---\ntitle: Objective-C基础知识小结\ndate: 2016-09-17 20:29:17\ncategories: iOS基础知识\ntags:\n    - Objective-C\n---\n\n# 内存\n\n## 堆栈\n**栈区（stack）**\n由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。\n\n**堆区(heap)**\nheap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。\n<!-- more -->\n\n**全局区（static）**\n全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。\n\n**文字常量区**\n常量字符串就是放在这里的。 程序结束后由系统释放。\n\n**程序代码区**\n存放函数体的二进制代码。\n\n![内存空间](/内存空间.png)\n\n## 引用计数\n\n### 4个原则\n- 自己生成的对象，自己持有。\n- 非自己生成的对象，自己也能持有。\n- 不再需要自己持有的对象时释放。\n- 非自己持有的对象无法释放。\n\n### 对象操作\n| 对象操作         | Objective-C方法            |\n| --------------- |:-------------------------:|\n| 生成并持有对象    | alloc/new/copy/mutableCopy|\n| 持有对象         | retain                    |\n| 释放对象         | release                   |\n| 废弃对象         | dealloc                   |\n\n### ARC\nARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。\n\n## 自动释放池\n对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。\n\n- 对象执行autorelease方法时会将对象添加到自动释放池中。\n- 当自动释放池销毁时自动释放池中所有对象作release操作。\n- 对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。\n\n## 属性参数\n- assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。\n- retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。\n- copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。\n- unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。\n- weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。\n- strong: （ARC中默认属性类型）相当于retain。\n\n## 实例\n### 测试1\n```\n#import <Foundation/Foundation.h>\n\n@interface TestARC : NSObject\n@property (nonatomic, strong) NSString *string;\n@property (nonatomic, assign) NSString *stringAssign;\n@property (nonatomic, retain) NSString *stringRetain;\n@property (nonatomic, copy) NSString *stringCopy;\n@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;\n@property (nonatomic, weak) NSString *stringWeak;\n@property (nonatomic, strong) NSString *stringStrong;\n@end\n```\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringAssign = testObj.string;\n        testObj.string = nil;\n    }\n    \n    NSLog(@\"string = %@\", testObj.string);\n    NSLog(@\"stringAssign = %@\", testObj.stringAssign);\n    \n    return 0;\n}\n```\nstringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。\n\n### 测试2\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringWeak = testObj.string;\n//        testObj.stringStrong = testObj.string;\n        testObj.string = nil;\n    }\n    \n    NSLog(@\"string = %@\", testObj.string);\n    NSLog(@\"stringWeak = %@\", testObj.stringWeak);\n    \n    return 0;\n}\n```\n```\n2016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)\n2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null)\n```\n```\n2016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)\n2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1\n```\n强指针指向对象时，内存没有被释放。\n\n### 测试3\n```\n#import \"TestARC.h\"\n\nint main(int argc, const char * argv[]) {\n    TestARC *testObj;\n    \n    @autoreleasepool {\n        testObj = [[TestARC alloc] init];\n        testObj.string = [NSMutableString stringWithFormat:@\"string1\"];\n        testObj.stringRetain = testObj.string;\n        testObj.stringCopy = testObj.string;\n        testObj.stringStrong = testObj.string;\n        testObj.string = nil;\n    }\n    \n    return 0;\n}\n```\n```\n(lldb) p testObj.string\n(NSString *) $0 = nil\n(lldb) p testObj.stringRetain\n(__NSCFString *) $1 = 0x00000001005036c0 @\"string1\"\n(lldb) p testObj.stringCopy\n(NSTaggedPointerString *) $2 = 0x31676e6972747375 @\"string1\"\n(lldb) p testObj.stringStrong\n(__NSCFString *) $3 = 0x00000001005036c0 @\"string1\"\n```\n\n# Block\n带有自动变量（局部变量）的匿名函数。形如int (^count)(int) =  ^int (int count){return count+1;}; \n声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。\n赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。\n\n## 类型\n- _NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。\n- _NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。\n- _NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。\n\n## 注意点\n- block会截获外部自动变量的瞬间值。\n- block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。\n- 使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如`__weak typeof(self) weakSelf = self;`新建一个指针的方式解决，在block内部使用__weak类型的对象。\n- block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。\n\n## 实例\n```\n#import <Foundation/Foundation.h>\n\n@interface TestBlock : NSObject\ntypedef NSString *(^testBlockStruct)(NSString *);\n@property (nonatomic, strong) testBlockStruct completionBlock;\n\n- (void)handleBlock:(NSString *)string;\n@end\n```\n```\n#import \"TestBlock.h\"\n\n@implementation TestBlock\n- (void)handleBlock:(NSString *)string {\n    if (self.completionBlock) {\n        NSLog(@\"%@\", self.completionBlock(string));\n    }\n}\n@end\n```\n```\n#import \"TestBlock.h\"\n\nint main(int argc, const char * argv[]) {\n    TestBlock *testBlock = [[TestBlock alloc] init];\n    \n    NSString *tempString = @\"Baidu\";\n    testBlock.completionBlock = ^NSString *(NSString *string){\n        // 使用外部的局部变量tempString\n        NSLog(@\"Block is here with %@ at %@.\", string, tempString);\n        return @\"Block is completed.\";\n    };\n    // 改变局部变量tempString，打印出的block截获了其瞬间值\"Baidu\"\n    tempString = @\"Beijing\";\n    \n    [testBlock handleBlock:@\"LeeOuf\"];\n    return 0;\n}\n```\n```\n2016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeeOuf at Baidu.\n2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed.\n```\n\n# GCD\nGCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。\n\n## Dispatch Queue\n- DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。\n- DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。\n\n获取Dispatch Queue方法: \n- dispatch_get_main_queue()\n- dispatch_get_global_queue()\n- dispatch_queue_create()\n\n## 方法列表\n![queue.h](/GCD01.png)\n![group.h](/GCD02.png)\n![once.h](/GCD02.png)\n\n# 补充\n1. MRC不能使用weak，使用什么替代？\n2. NSString为什么要使用copy?\n3. block底层forwarding实现\n4. 那些部分不能使用async操作\n5. ARC和MRC下的循环引用\n6. 如何检测VC的循环引用\n7. Category的好处，Category中是否可以加property？\n8. 类别和扩展的区别？为啥要使用扩展\n9. Category中一定添加property，如何实现？\n10. Category中添加和原有类的方法，是否覆盖？  \n-------------------------------- \n1. assign\n2. 因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。\n3. `__Block_byref_val_0`结构体实例有一个成员变量`__forwarding`持有只想该实例自身的指针。\nstatic void _Block_byref_assign_copy(void *dest, const void *arg, const int flags) {\n    struct Block_byref **destp = (struct Block_byref **)dest;\n    struct Block_byref *src = (struct Block_byref *)arg;\n    // src points to stack\n    struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);\n    copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)\n    src->forwarding = copy;  // patch stack to point to heap copy\n    copy->size = src->size;\n    // assign byref data block pointer into new Block\n    _Block_assign(src->forwarding, (void **)destp);\n}\n根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。\n4. UI部分。\n5. ARC中可以新建一个__weak修饰符修饰的指针（如__weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用__block修饰（如__block typeof(self) weakSelf = self;）。\n6. \n(1) Product->Profile，查看Leaks，如：\n![Leaks](/调试01.png)\n![Leaks结果](/调试02.png)\n(2) lldb直接print，查看对象是否为nil。\n7&9. 优点：不使用继承而为现有类添加新方法。\nCategory用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。\n8&10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。\n（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。\n","slug":"Objective-C基础知识小结","published":1,"updated":"2019-03-11T09:33:16.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0l0002nflwk37pzip9","content":"<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><h2 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h2><p><strong>栈区（stack）</strong><br>由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。</p>\n<p><strong>堆区(heap)</strong><br>heap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。<br><a id=\"more\"></a></p>\n<p><strong>全局区（static）</strong><br>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。</p>\n<p><strong>文字常量区</strong><br>常量字符串就是放在这里的。 程序结束后由系统释放。</p>\n<p><strong>程序代码区</strong><br>存放函数体的二进制代码。</p>\n<p><img src=\"/内存空间.png\" alt=\"内存空间\"></p>\n<h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><h3 id=\"4个原则\"><a href=\"#4个原则\" class=\"headerlink\" title=\"4个原则\"></a>4个原则</h3><ul>\n<li>自己生成的对象，自己持有。</li>\n<li>非自己生成的对象，自己也能持有。</li>\n<li>不再需要自己持有的对象时释放。</li>\n<li>非自己持有的对象无法释放。</li>\n</ul>\n<h3 id=\"对象操作\"><a href=\"#对象操作\" class=\"headerlink\" title=\"对象操作\"></a>对象操作</h3><table>\n<thead>\n<tr>\n<th>对象操作</th>\n<th style=\"text-align:center\">Objective-C方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生成并持有对象</td>\n<td style=\"text-align:center\">alloc/new/copy/mutableCopy</td>\n</tr>\n<tr>\n<td>持有对象</td>\n<td style=\"text-align:center\">retain</td>\n</tr>\n<tr>\n<td>释放对象</td>\n<td style=\"text-align:center\">release</td>\n</tr>\n<tr>\n<td>废弃对象</td>\n<td style=\"text-align:center\">dealloc</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h3><p>ARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。</p>\n<h2 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h2><p>对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>\n<ul>\n<li>对象执行autorelease方法时会将对象添加到自动释放池中。</li>\n<li>当自动释放池销毁时自动释放池中所有对象作release操作。</li>\n<li>对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。</li>\n</ul>\n<h2 id=\"属性参数\"><a href=\"#属性参数\" class=\"headerlink\" title=\"属性参数\"></a>属性参数</h2><ul>\n<li>assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。</li>\n<li>retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。</li>\n<li>copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。</li>\n<li>unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。</li>\n<li>weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。</li>\n<li>strong: （ARC中默认属性类型）相当于retain。</li>\n</ul>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"测试1\"><a href=\"#测试1\" class=\"headerlink\" title=\"测试1\"></a>测试1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface TestARC : NSObject</span><br><span class=\"line\">@property (nonatomic, strong) NSString *string;</span><br><span class=\"line\">@property (nonatomic, assign) NSString *stringAssign;</span><br><span class=\"line\">@property (nonatomic, retain) NSString *stringRetain;</span><br><span class=\"line\">@property (nonatomic, copy) NSString *stringCopy;</span><br><span class=\"line\">@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;</span><br><span class=\"line\">@property (nonatomic, weak) NSString *stringWeak;</span><br><span class=\"line\">@property (nonatomic, strong) NSString *stringStrong;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringAssign = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string = %@&quot;, testObj.string);</span><br><span class=\"line\">    NSLog(@&quot;stringAssign = %@&quot;, testObj.stringAssign);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>stringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。</p>\n<h3 id=\"测试2\"><a href=\"#测试2\" class=\"headerlink\" title=\"测试2\"></a>测试2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringWeak = testObj.string;</span><br><span class=\"line\">//        testObj.stringStrong = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string = %@&quot;, testObj.string);</span><br><span class=\"line\">    NSLog(@&quot;stringWeak = %@&quot;, testObj.stringWeak);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)</span><br><span class=\"line\">2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)</span><br><span class=\"line\">2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1</span><br></pre></td></tr></table></figure>\n<p>强指针指向对象时，内存没有被释放。</p>\n<h3 id=\"测试3\"><a href=\"#测试3\" class=\"headerlink\" title=\"测试3\"></a>测试3</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringRetain = testObj.string;</span><br><span class=\"line\">        testObj.stringCopy = testObj.string;</span><br><span class=\"line\">        testObj.stringStrong = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p testObj.string</span><br><span class=\"line\">(NSString *) $0 = nil</span><br><span class=\"line\">(lldb) p testObj.stringRetain</span><br><span class=\"line\">(__NSCFString *) $1 = 0x00000001005036c0 @&quot;string1&quot;</span><br><span class=\"line\">(lldb) p testObj.stringCopy</span><br><span class=\"line\">(NSTaggedPointerString *) $2 = 0x31676e6972747375 @&quot;string1&quot;</span><br><span class=\"line\">(lldb) p testObj.stringStrong</span><br><span class=\"line\">(__NSCFString *) $3 = 0x00000001005036c0 @&quot;string1&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h1><p>带有自动变量（局部变量）的匿名函数。形如int (^count)(int) =  ^int (int count){return count+1;};<br>声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。<br>赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><ul>\n<li>_NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。</li>\n<li>_NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。</li>\n<li>_NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。</li>\n</ul>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ul>\n<li>block会截获外部自动变量的瞬间值。</li>\n<li>block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。</li>\n<li>使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如<code>__weak typeof(self) weakSelf = self;</code>新建一个指针的方式解决，在block内部使用__weak类型的对象。</li>\n<li>block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。</li>\n</ul>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface TestBlock : NSObject</span><br><span class=\"line\">typedef NSString *(^testBlockStruct)(NSString *);</span><br><span class=\"line\">@property (nonatomic, strong) testBlockStruct completionBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleBlock:(NSString *)string;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestBlock.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation TestBlock</span><br><span class=\"line\">- (void)handleBlock:(NSString *)string &#123;</span><br><span class=\"line\">    if (self.completionBlock) &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, self.completionBlock(string));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestBlock.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestBlock *testBlock = [[TestBlock alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *tempString = @&quot;Baidu&quot;;</span><br><span class=\"line\">    testBlock.completionBlock = ^NSString *(NSString *string)&#123;</span><br><span class=\"line\">        // 使用外部的局部变量tempString</span><br><span class=\"line\">        NSLog(@&quot;Block is here with %@ at %@.&quot;, string, tempString);</span><br><span class=\"line\">        return @&quot;Block is completed.&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 改变局部变量tempString，打印出的block截获了其瞬间值&quot;Baidu&quot;</span><br><span class=\"line\">    tempString = @&quot;Beijing&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [testBlock handleBlock:@&quot;LeeOuf&quot;];</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeeOuf at Baidu.</span><br><span class=\"line\">2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed.</span><br></pre></td></tr></table></figure>\n<h1 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h1><p>GCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。</p>\n<h2 id=\"Dispatch-Queue\"><a href=\"#Dispatch-Queue\" class=\"headerlink\" title=\"Dispatch Queue\"></a>Dispatch Queue</h2><ul>\n<li>DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。</li>\n<li>DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。</li>\n</ul>\n<p>获取Dispatch Queue方法: </p>\n<ul>\n<li>dispatch_get_main_queue()</li>\n<li>dispatch_get_global_queue()</li>\n<li>dispatch_queue_create()</li>\n</ul>\n<h2 id=\"方法列表\"><a href=\"#方法列表\" class=\"headerlink\" title=\"方法列表\"></a>方法列表</h2><p><img src=\"/GCD01.png\" alt=\"queue.h\"><br><img src=\"/GCD02.png\" alt=\"group.h\"><br><img src=\"/GCD02.png\" alt=\"once.h\"></p>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ol>\n<li>MRC不能使用weak，使用什么替代？</li>\n<li>NSString为什么要使用copy?</li>\n<li>block底层forwarding实现</li>\n<li>那些部分不能使用async操作</li>\n<li>ARC和MRC下的循环引用</li>\n<li>如何检测VC的循环引用</li>\n<li>Category的好处，Category中是否可以加property？</li>\n<li>类别和扩展的区别？为啥要使用扩展</li>\n<li>Category中一定添加property，如何实现？</li>\n<li>Category中添加和原有类的方法，是否覆盖？  </li>\n</ol>\n<hr>\n<ol>\n<li>assign</li>\n<li>因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。</li>\n<li><code>__Block_byref_val_0</code>结构体实例有一个成员变量<code>__forwarding</code>持有只想该实例自身的指针。<br>static void _Block_byref_assign_copy(void <em>dest, const void </em>arg, const int flags) {<br> struct Block_byref <strong>destp = (struct Block_byref </strong>)dest;<br> struct Block_byref <em>src = (struct Block_byref </em>)arg;<br> // src points to stack<br> struct Block_byref <em>copy = (struct Block_byref </em>)_Block_allocator(src-&gt;size, false, isWeak);<br> copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)<br> src-&gt;forwarding = copy;  // patch stack to point to heap copy<br> copy-&gt;size = src-&gt;size;<br> // assign byref data block pointer into new Block<br> _Block_assign(src-&gt;forwarding, (void **)destp);<br>}<br>根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。</li>\n<li>UI部分。</li>\n<li>ARC中可以新建一个<strong>weak修饰符修饰的指针（如</strong>weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用<strong>block修饰（如</strong>block typeof(self) weakSelf = self;）。</li>\n<li>(1) Product-&gt;Profile，查看Leaks，如：<br><img src=\"/调试01.png\" alt=\"Leaks\"><br><img src=\"/调试02.png\" alt=\"Leaks结果\"><br>(2) lldb直接print，查看对象是否为nil。<br>7&amp;9. 优点：不使用继承而为现有类添加新方法。<br>Category用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。<br>8&amp;10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。<br>（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><h2 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h2><p><strong>栈区（stack）</strong><br>由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。</p>\n<p><strong>堆区(heap)</strong><br>heap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。<br>","more":"</p>\n<p><strong>全局区（static）</strong><br>全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。</p>\n<p><strong>文字常量区</strong><br>常量字符串就是放在这里的。 程序结束后由系统释放。</p>\n<p><strong>程序代码区</strong><br>存放函数体的二进制代码。</p>\n<p><img src=\"/内存空间.png\" alt=\"内存空间\"></p>\n<h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><h3 id=\"4个原则\"><a href=\"#4个原则\" class=\"headerlink\" title=\"4个原则\"></a>4个原则</h3><ul>\n<li>自己生成的对象，自己持有。</li>\n<li>非自己生成的对象，自己也能持有。</li>\n<li>不再需要自己持有的对象时释放。</li>\n<li>非自己持有的对象无法释放。</li>\n</ul>\n<h3 id=\"对象操作\"><a href=\"#对象操作\" class=\"headerlink\" title=\"对象操作\"></a>对象操作</h3><table>\n<thead>\n<tr>\n<th>对象操作</th>\n<th style=\"text-align:center\">Objective-C方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>生成并持有对象</td>\n<td style=\"text-align:center\">alloc/new/copy/mutableCopy</td>\n</tr>\n<tr>\n<td>持有对象</td>\n<td style=\"text-align:center\">retain</td>\n</tr>\n<tr>\n<td>释放对象</td>\n<td style=\"text-align:center\">release</td>\n</tr>\n<tr>\n<td>废弃对象</td>\n<td style=\"text-align:center\">dealloc</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ARC\"><a href=\"#ARC\" class=\"headerlink\" title=\"ARC\"></a>ARC</h3><p>ARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。</p>\n<h2 id=\"自动释放池\"><a href=\"#自动释放池\" class=\"headerlink\" title=\"自动释放池\"></a>自动释放池</h2><p>对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>\n<ul>\n<li>对象执行autorelease方法时会将对象添加到自动释放池中。</li>\n<li>当自动释放池销毁时自动释放池中所有对象作release操作。</li>\n<li>对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。</li>\n</ul>\n<h2 id=\"属性参数\"><a href=\"#属性参数\" class=\"headerlink\" title=\"属性参数\"></a>属性参数</h2><ul>\n<li>assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。</li>\n<li>retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。</li>\n<li>copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。</li>\n<li>unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。</li>\n<li>weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。</li>\n<li>strong: （ARC中默认属性类型）相当于retain。</li>\n</ul>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"测试1\"><a href=\"#测试1\" class=\"headerlink\" title=\"测试1\"></a>测试1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface TestARC : NSObject</span><br><span class=\"line\">@property (nonatomic, strong) NSString *string;</span><br><span class=\"line\">@property (nonatomic, assign) NSString *stringAssign;</span><br><span class=\"line\">@property (nonatomic, retain) NSString *stringRetain;</span><br><span class=\"line\">@property (nonatomic, copy) NSString *stringCopy;</span><br><span class=\"line\">@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;</span><br><span class=\"line\">@property (nonatomic, weak) NSString *stringWeak;</span><br><span class=\"line\">@property (nonatomic, strong) NSString *stringStrong;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringAssign = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string = %@&quot;, testObj.string);</span><br><span class=\"line\">    NSLog(@&quot;stringAssign = %@&quot;, testObj.stringAssign);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>stringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。</p>\n<h3 id=\"测试2\"><a href=\"#测试2\" class=\"headerlink\" title=\"测试2\"></a>测试2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringWeak = testObj.string;</span><br><span class=\"line\">//        testObj.stringStrong = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string = %@&quot;, testObj.string);</span><br><span class=\"line\">    NSLog(@&quot;stringWeak = %@&quot;, testObj.stringWeak);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)</span><br><span class=\"line\">2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)</span><br><span class=\"line\">2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1</span><br></pre></td></tr></table></figure>\n<p>强指针指向对象时，内存没有被释放。</p>\n<h3 id=\"测试3\"><a href=\"#测试3\" class=\"headerlink\" title=\"测试3\"></a>测试3</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestARC.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestARC *testObj;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        testObj = [[TestARC alloc] init];</span><br><span class=\"line\">        testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;];</span><br><span class=\"line\">        testObj.stringRetain = testObj.string;</span><br><span class=\"line\">        testObj.stringCopy = testObj.string;</span><br><span class=\"line\">        testObj.stringStrong = testObj.string;</span><br><span class=\"line\">        testObj.string = nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb) p testObj.string</span><br><span class=\"line\">(NSString *) $0 = nil</span><br><span class=\"line\">(lldb) p testObj.stringRetain</span><br><span class=\"line\">(__NSCFString *) $1 = 0x00000001005036c0 @&quot;string1&quot;</span><br><span class=\"line\">(lldb) p testObj.stringCopy</span><br><span class=\"line\">(NSTaggedPointerString *) $2 = 0x31676e6972747375 @&quot;string1&quot;</span><br><span class=\"line\">(lldb) p testObj.stringStrong</span><br><span class=\"line\">(__NSCFString *) $3 = 0x00000001005036c0 @&quot;string1&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h1><p>带有自动变量（局部变量）的匿名函数。形如int (^count)(int) =  ^int (int count){return count+1;};<br>声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。<br>赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。</p>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><ul>\n<li>_NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。</li>\n<li>_NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。</li>\n<li>_NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。</li>\n</ul>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ul>\n<li>block会截获外部自动变量的瞬间值。</li>\n<li>block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。</li>\n<li>使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如<code>__weak typeof(self) weakSelf = self;</code>新建一个指针的方式解决，在block内部使用__weak类型的对象。</li>\n<li>block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。</li>\n</ul>\n<h2 id=\"实例-1\"><a href=\"#实例-1\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface TestBlock : NSObject</span><br><span class=\"line\">typedef NSString *(^testBlockStruct)(NSString *);</span><br><span class=\"line\">@property (nonatomic, strong) testBlockStruct completionBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleBlock:(NSString *)string;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestBlock.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation TestBlock</span><br><span class=\"line\">- (void)handleBlock:(NSString *)string &#123;</span><br><span class=\"line\">    if (self.completionBlock) &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, self.completionBlock(string));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;TestBlock.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    TestBlock *testBlock = [[TestBlock alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *tempString = @&quot;Baidu&quot;;</span><br><span class=\"line\">    testBlock.completionBlock = ^NSString *(NSString *string)&#123;</span><br><span class=\"line\">        // 使用外部的局部变量tempString</span><br><span class=\"line\">        NSLog(@&quot;Block is here with %@ at %@.&quot;, string, tempString);</span><br><span class=\"line\">        return @&quot;Block is completed.&quot;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    // 改变局部变量tempString，打印出的block截获了其瞬间值&quot;Baidu&quot;</span><br><span class=\"line\">    tempString = @&quot;Beijing&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [testBlock handleBlock:@&quot;LeeOuf&quot;];</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeeOuf at Baidu.</span><br><span class=\"line\">2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed.</span><br></pre></td></tr></table></figure>\n<h1 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h1><p>GCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。</p>\n<h2 id=\"Dispatch-Queue\"><a href=\"#Dispatch-Queue\" class=\"headerlink\" title=\"Dispatch Queue\"></a>Dispatch Queue</h2><ul>\n<li>DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。</li>\n<li>DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。</li>\n</ul>\n<p>获取Dispatch Queue方法: </p>\n<ul>\n<li>dispatch_get_main_queue()</li>\n<li>dispatch_get_global_queue()</li>\n<li>dispatch_queue_create()</li>\n</ul>\n<h2 id=\"方法列表\"><a href=\"#方法列表\" class=\"headerlink\" title=\"方法列表\"></a>方法列表</h2><p><img src=\"/GCD01.png\" alt=\"queue.h\"><br><img src=\"/GCD02.png\" alt=\"group.h\"><br><img src=\"/GCD02.png\" alt=\"once.h\"></p>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><ol>\n<li>MRC不能使用weak，使用什么替代？</li>\n<li>NSString为什么要使用copy?</li>\n<li>block底层forwarding实现</li>\n<li>那些部分不能使用async操作</li>\n<li>ARC和MRC下的循环引用</li>\n<li>如何检测VC的循环引用</li>\n<li>Category的好处，Category中是否可以加property？</li>\n<li>类别和扩展的区别？为啥要使用扩展</li>\n<li>Category中一定添加property，如何实现？</li>\n<li>Category中添加和原有类的方法，是否覆盖？  </li>\n</ol>\n<hr>\n<ol>\n<li>assign</li>\n<li>因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。</li>\n<li><code>__Block_byref_val_0</code>结构体实例有一个成员变量<code>__forwarding</code>持有只想该实例自身的指针。<br>static void _Block_byref_assign_copy(void <em>dest, const void </em>arg, const int flags) {<br> struct Block_byref <strong>destp = (struct Block_byref </strong>)dest;<br> struct Block_byref <em>src = (struct Block_byref </em>)arg;<br> // src points to stack<br> struct Block_byref <em>copy = (struct Block_byref </em>)_Block_allocator(src-&gt;size, false, isWeak);<br> copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)<br> src-&gt;forwarding = copy;  // patch stack to point to heap copy<br> copy-&gt;size = src-&gt;size;<br> // assign byref data block pointer into new Block<br> _Block_assign(src-&gt;forwarding, (void **)destp);<br>}<br>根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。</li>\n<li>UI部分。</li>\n<li>ARC中可以新建一个<strong>weak修饰符修饰的指针（如</strong>weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用<strong>block修饰（如</strong>block typeof(self) weakSelf = self;）。</li>\n<li>(1) Product-&gt;Profile，查看Leaks，如：<br><img src=\"/调试01.png\" alt=\"Leaks\"><br><img src=\"/调试02.png\" alt=\"Leaks结果\"><br>(2) lldb直接print，查看对象是否为nil。<br>7&amp;9. 优点：不使用继承而为现有类添加新方法。<br>Category用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。<br>8&amp;10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。<br>（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。</li>\n</ol>"},{"title":"UISwitch在iOS 10中的BUG","date":"2016-09-29T05:31:22.000Z","_content":"\n# UISwitch\nUISwitch是UIControl的子类，定义如下：\n```\n#import <Foundation/Foundation.h>\n#import <CoreGraphics/CoreGraphics.h>\n#import <UIKit/UIControl.h>\n#import <UIKit/UIKitDefines.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\nNS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl <NSCoding>\n\n@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;\n@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);\n@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n\n@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n\n@property(nonatomic,getter=isOn) BOOL on;\n\n- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;      // This class enforces a size appropriate for the control, and so the frame size is ignored.\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;\n\n- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action\n\n@end\n\nNS_ASSUME_NONNULL_END\n```\n\n方法定义中有一个`- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action`，如注释所说不发送action。\n<!-- more -->\n\n# iOS 9下表现\n接下来在iOS 9中进行验证：\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@property (nonatomic, strong) UISwitch *lkSwitch;\n@property (nonatomic, strong) UISwitch *lkSwitch1;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)];\n    [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:_lkSwitch];\n    \n    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)];\n    [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside];\n    button.backgroundColor = [UIColor redColor];\n    [self.view addSubview:button];\n    \n    _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)];\n    [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:_lkSwitch1];\n    \n    UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)];\n    [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside];\n    button1.backgroundColor = [UIColor redColor];\n    [self.view addSubview:button1];\n}\n\n- (void)onSwitch:(UISwitch *)sender {\n    [sender setOn:!sender.isOn];\n}\n\n- (void)onButton:(UIButton *)sender {\n    [_lkSwitch setOn:!_lkSwitch.isOn];\n}\n\n- (void)onSwitch1:(UISwitch *)sender {\n    [sender setOn:!sender.isOn animated:YES];\n}\n\n- (void)onButton1:(UIButton *)sender {\n    [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];\n}\n\n@end\n```\n验证结果：无论是`setOn`方法还是`setOn:_animated:_`方法，都不会触发`onSwitch`。\n\n# iOS 10下表现\n然而，在iOS 10中，测试结果显示，在`onSwitch`方法中调用`setOn`或`setOn:_animated:_`，均会再次触发`onSwitch`。\n\n# 结论\n也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为`UIControlEventValueChanged`，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考...）。\n\n# 解决方案\n在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。\n\n曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写`setOn`和`setOn:_animated:_`方法，但是这样带来的风险是，dispatch queue以后的语句会先于`setOn`执行，若此时获取`isOn`，将无法得到预期的结果。\n\n因此最终决定在业务逻辑层局部进行修改。","source":"_posts/UISwitch在iOS 10中的BUG.md","raw":"---\ntitle: UISwitch在iOS 10中的BUG\ndate: 2016-09-29 13:31:22\ncategories: 笔记\ntags: \n    - iOS\n    - iOS 10\n    - BUG\n---\n\n# UISwitch\nUISwitch是UIControl的子类，定义如下：\n```\n#import <Foundation/Foundation.h>\n#import <CoreGraphics/CoreGraphics.h>\n#import <UIKit/UIControl.h>\n#import <UIKit/UIKitDefines.h>\n\nNS_ASSUME_NONNULL_BEGIN\n\nNS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl <NSCoding>\n\n@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;\n@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);\n@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n\n@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;\n\n@property(nonatomic,getter=isOn) BOOL on;\n\n- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;      // This class enforces a size appropriate for the control, and so the frame size is ignored.\n- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;\n\n- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action\n\n@end\n\nNS_ASSUME_NONNULL_END\n```\n\n方法定义中有一个`- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action`，如注释所说不发送action。\n<!-- more -->\n\n# iOS 9下表现\n接下来在iOS 9中进行验证：\n```\n#import \"ViewController.h\"\n\n@interface ViewController ()\n\n@property (nonatomic, strong) UISwitch *lkSwitch;\n@property (nonatomic, strong) UISwitch *lkSwitch1;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)];\n    [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:_lkSwitch];\n    \n    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)];\n    [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside];\n    button.backgroundColor = [UIColor redColor];\n    [self.view addSubview:button];\n    \n    _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)];\n    [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged];\n    [self.view addSubview:_lkSwitch1];\n    \n    UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)];\n    [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside];\n    button1.backgroundColor = [UIColor redColor];\n    [self.view addSubview:button1];\n}\n\n- (void)onSwitch:(UISwitch *)sender {\n    [sender setOn:!sender.isOn];\n}\n\n- (void)onButton:(UIButton *)sender {\n    [_lkSwitch setOn:!_lkSwitch.isOn];\n}\n\n- (void)onSwitch1:(UISwitch *)sender {\n    [sender setOn:!sender.isOn animated:YES];\n}\n\n- (void)onButton1:(UIButton *)sender {\n    [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];\n}\n\n@end\n```\n验证结果：无论是`setOn`方法还是`setOn:_animated:_`方法，都不会触发`onSwitch`。\n\n# iOS 10下表现\n然而，在iOS 10中，测试结果显示，在`onSwitch`方法中调用`setOn`或`setOn:_animated:_`，均会再次触发`onSwitch`。\n\n# 结论\n也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为`UIControlEventValueChanged`，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考...）。\n\n# 解决方案\n在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。\n\n曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写`setOn`和`setOn:_animated:_`方法，但是这样带来的风险是，dispatch queue以后的语句会先于`setOn`执行，若此时获取`isOn`，将无法得到预期的结果。\n\n因此最终决定在业务逻辑层局部进行修改。","slug":"UISwitch在iOS 10中的BUG","published":1,"updated":"2019-03-11T09:33:20.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0p0005nflwgtsahtwi","content":"<h1 id=\"UISwitch\"><a href=\"#UISwitch\" class=\"headerlink\" title=\"UISwitch\"></a>UISwitch</h1><p>UISwitch是UIControl的子类，定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;CoreGraphics/CoreGraphics.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIControl.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NS_ASSUME_NONNULL_BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl &lt;NSCoding&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\">@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);</span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nonatomic,getter=isOn) BOOL on;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;      // This class enforces a size appropriate for the control, and so the frame size is ignored.</span><br><span class=\"line\">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></p>\n<p>方法定义中有一个<code>- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action</code>，如注释所说不发送action。<br><a id=\"more\"></a></p>\n<h1 id=\"iOS-9下表现\"><a href=\"#iOS-9下表现\" class=\"headerlink\" title=\"iOS 9下表现\"></a>iOS 9下表现</h1><p>接下来在iOS 9中进行验证：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) UISwitch *lkSwitch;</span><br><span class=\"line\">@property (nonatomic, strong) UISwitch *lkSwitch1;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)];</span><br><span class=\"line\">    [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged];</span><br><span class=\"line\">    [self.view addSubview:_lkSwitch];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)];</span><br><span class=\"line\">    [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    button.backgroundColor = [UIColor redColor];</span><br><span class=\"line\">    [self.view addSubview:button];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)];</span><br><span class=\"line\">    [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged];</span><br><span class=\"line\">    [self.view addSubview:_lkSwitch1];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)];</span><br><span class=\"line\">    [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    button1.backgroundColor = [UIColor redColor];</span><br><span class=\"line\">    [self.view addSubview:button1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onSwitch:(UISwitch *)sender &#123;</span><br><span class=\"line\">    [sender setOn:!sender.isOn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onButton:(UIButton *)sender &#123;</span><br><span class=\"line\">    [_lkSwitch setOn:!_lkSwitch.isOn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onSwitch1:(UISwitch *)sender &#123;</span><br><span class=\"line\">    [sender setOn:!sender.isOn animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onButton1:(UIButton *)sender &#123;</span><br><span class=\"line\">    [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>验证结果：无论是<code>setOn</code>方法还是<code>setOn:_animated:_</code>方法，都不会触发<code>onSwitch</code>。</p>\n<h1 id=\"iOS-10下表现\"><a href=\"#iOS-10下表现\" class=\"headerlink\" title=\"iOS 10下表现\"></a>iOS 10下表现</h1><p>然而，在iOS 10中，测试结果显示，在<code>onSwitch</code>方法中调用<code>setOn</code>或<code>setOn:_animated:_</code>，均会再次触发<code>onSwitch</code>。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为<code>UIControlEventValueChanged</code>，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考…）。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。</p>\n<p>曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写<code>setOn</code>和<code>setOn:_animated:_</code>方法，但是这样带来的风险是，dispatch queue以后的语句会先于<code>setOn</code>执行，若此时获取<code>isOn</code>，将无法得到预期的结果。</p>\n<p>因此最终决定在业务逻辑层局部进行修改。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"UISwitch\"><a href=\"#UISwitch\" class=\"headerlink\" title=\"UISwitch\"></a>UISwitch</h1><p>UISwitch是UIControl的子类，定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;CoreGraphics/CoreGraphics.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIControl.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIKitDefines.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">NS_ASSUME_NONNULL_BEGIN</span><br><span class=\"line\"></span><br><span class=\"line\">NS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl &lt;NSCoding&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\">@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);</span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\">@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">@property(nonatomic,getter=isOn) BOOL on;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER;      // This class enforces a size appropriate for the control, and so the frame size is ignored.</span><br><span class=\"line\">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure></p>\n<p>方法定义中有一个<code>- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action</code>，如注释所说不发送action。<br>","more":"</p>\n<h1 id=\"iOS-9下表现\"><a href=\"#iOS-9下表现\" class=\"headerlink\" title=\"iOS 9下表现\"></a>iOS 9下表现</h1><p>接下来在iOS 9中进行验证：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) UISwitch *lkSwitch;</span><br><span class=\"line\">@property (nonatomic, strong) UISwitch *lkSwitch1;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)];</span><br><span class=\"line\">    [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged];</span><br><span class=\"line\">    [self.view addSubview:_lkSwitch];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)];</span><br><span class=\"line\">    [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    button.backgroundColor = [UIColor redColor];</span><br><span class=\"line\">    [self.view addSubview:button];</span><br><span class=\"line\">    </span><br><span class=\"line\">    _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)];</span><br><span class=\"line\">    [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged];</span><br><span class=\"line\">    [self.view addSubview:_lkSwitch1];</span><br><span class=\"line\">    </span><br><span class=\"line\">    UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)];</span><br><span class=\"line\">    [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class=\"line\">    button1.backgroundColor = [UIColor redColor];</span><br><span class=\"line\">    [self.view addSubview:button1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onSwitch:(UISwitch *)sender &#123;</span><br><span class=\"line\">    [sender setOn:!sender.isOn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onButton:(UIButton *)sender &#123;</span><br><span class=\"line\">    [_lkSwitch setOn:!_lkSwitch.isOn];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onSwitch1:(UISwitch *)sender &#123;</span><br><span class=\"line\">    [sender setOn:!sender.isOn animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)onButton1:(UIButton *)sender &#123;</span><br><span class=\"line\">    [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>验证结果：无论是<code>setOn</code>方法还是<code>setOn:_animated:_</code>方法，都不会触发<code>onSwitch</code>。</p>\n<h1 id=\"iOS-10下表现\"><a href=\"#iOS-10下表现\" class=\"headerlink\" title=\"iOS 10下表现\"></a>iOS 10下表现</h1><p>然而，在iOS 10中，测试结果显示，在<code>onSwitch</code>方法中调用<code>setOn</code>或<code>setOn:_animated:_</code>，均会再次触发<code>onSwitch</code>。</p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为<code>UIControlEventValueChanged</code>，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考…）。</p>\n<h1 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h1><p>在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。</p>\n<p>曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写<code>setOn</code>和<code>setOn:_animated:_</code>方法，但是这样带来的风险是，dispatch queue以后的语句会先于<code>setOn</code>执行，若此时获取<code>isOn</code>，将无法得到预期的结果。</p>\n<p>因此最终决定在业务逻辑层局部进行修改。</p>"},{"title":"iOS基础：UIControlState","date":"2016-10-08T11:40:13.000Z","_content":"\n以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。\n\n在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？\n\n看一下UIControlState的定义：\n```\ntypedef NS_OPTIONS(NSUInteger, UIControlState) {\n    UIControlStateNormal       = 0,\n    UIControlStateHighlighted  = 1 << 0,                  // used when UIControl isHighlighted is set\n    UIControlStateDisabled     = 1 << 1,\n    UIControlStateSelected     = 1 << 2,                  // flag usable by app (see below)\n    UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 << 3, // Applicable only when the screen supports focus\n    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use\n    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use\n};\n```\n<!-- more -->\n\n**需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM**\n这几种状态转化成二进制实际上是：\n```\n   0\n   1\n  10\n 100\n1000\n```\n这意味着我们可以对其进行位操作，比如：\n`[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];`\n以上表示，设置按钮被选中且高亮时的图片。","source":"_posts/iOS基础：UIControlState.md","raw":"---\ntitle: iOS基础：UIControlState\ndate: 2016-10-08 19:40:13\ncategories: iOS基础知识\ntags:\n    - iOS\n    - UIControl\n    - UIControlState\n---\n\n以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。\n\n在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？\n\n看一下UIControlState的定义：\n```\ntypedef NS_OPTIONS(NSUInteger, UIControlState) {\n    UIControlStateNormal       = 0,\n    UIControlStateHighlighted  = 1 << 0,                  // used when UIControl isHighlighted is set\n    UIControlStateDisabled     = 1 << 1,\n    UIControlStateSelected     = 1 << 2,                  // flag usable by app (see below)\n    UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 << 3, // Applicable only when the screen supports focus\n    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use\n    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use\n};\n```\n<!-- more -->\n\n**需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM**\n这几种状态转化成二进制实际上是：\n```\n   0\n   1\n  10\n 100\n1000\n```\n这意味着我们可以对其进行位操作，比如：\n`[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];`\n以上表示，设置按钮被选中且高亮时的图片。","slug":"iOS基础：UIControlState","published":1,"updated":"2019-03-11T09:33:00.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0q0006nflwz2gargpz","content":"<p>以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。</p>\n<p>在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？</p>\n<p>看一下UIControlState的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, UIControlState) &#123;</span><br><span class=\"line\">    UIControlStateNormal       = 0,</span><br><span class=\"line\">    UIControlStateHighlighted  = 1 &lt;&lt; 0,                  // used when UIControl isHighlighted is set</span><br><span class=\"line\">    UIControlStateDisabled     = 1 &lt;&lt; 1,</span><br><span class=\"line\">    UIControlStateSelected     = 1 &lt;&lt; 2,                  // flag usable by app (see below)</span><br><span class=\"line\">    UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 &lt;&lt; 3, // Applicable only when the screen supports focus</span><br><span class=\"line\">    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use</span><br><span class=\"line\">    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p><strong>需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM</strong><br>这几种状态转化成二进制实际上是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   0</span><br><span class=\"line\">   1</span><br><span class=\"line\">  10</span><br><span class=\"line\"> 100</span><br><span class=\"line\">1000</span><br></pre></td></tr></table></figure></p>\n<p>这意味着我们可以对其进行位操作，比如：<br><code>[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];</code><br>以上表示，设置按钮被选中且高亮时的图片。</p>\n","site":{"data":{}},"excerpt":"<p>以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。</p>\n<p>在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？</p>\n<p>看一下UIControlState的定义：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, UIControlState) &#123;</span><br><span class=\"line\">    UIControlStateNormal       = 0,</span><br><span class=\"line\">    UIControlStateHighlighted  = 1 &lt;&lt; 0,                  // used when UIControl isHighlighted is set</span><br><span class=\"line\">    UIControlStateDisabled     = 1 &lt;&lt; 1,</span><br><span class=\"line\">    UIControlStateSelected     = 1 &lt;&lt; 2,                  // flag usable by app (see below)</span><br><span class=\"line\">    UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 &lt;&lt; 3, // Applicable only when the screen supports focus</span><br><span class=\"line\">    UIControlStateApplication  = 0x00FF0000,              // additional flags available for application use</span><br><span class=\"line\">    UIControlStateReserved     = 0xFF000000               // flags reserved for internal framework use</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>","more":"<p><strong>需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM</strong><br>这几种状态转化成二进制实际上是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   0</span><br><span class=\"line\">   1</span><br><span class=\"line\">  10</span><br><span class=\"line\"> 100</span><br><span class=\"line\">1000</span><br></pre></td></tr></table></figure></p>\n<p>这意味着我们可以对其进行位操作，比如：<br><code>[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];</code><br>以上表示，设置按钮被选中且高亮时的图片。</p>"},{"title":"iOS基础：UIViewController生命周期","date":"2017-01-04T03:44:02.000Z","_content":"\n# UIViewController生命周期\n1. init\n2. loadView\n3. viewDidLoad\n4. viewWillAppear\n5. viewWillLayoutSubviews\n6. viewDidLayoutSubviews\n7. viewDidAppear\n8. viewWillDisappear\n9. viewDidDisappear\n10. dealloc\n<!-- more -->\n\n# UIView layoutSubviews方法触发条件\n[layoutSubviews触发条件](http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called)\n- init does not cause layoutSubviews to be called (duh)\n- addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target\n- view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different\n- scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview\n- rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)\n- Resizing a view will call layoutSubviews on its superview\n\n# 在UIViewController中使用UIView时，layoutSubviews的触发时机\n## 测试代码\n`ViewController.m`\n```\n#import \"ViewController.h\"\n#import \"LKView.h\"\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];\n    [self.view addSubview:view];\n    \n    NSLog(@\"1...\");\n}\n\n- (void)viewWillLayoutSubviews\n{\n    [super viewWillLayoutSubviews];\n    NSLog(@\"3...\");\n}\n\n- (void)viewDidLayoutSubviews\n{\n    [super viewDidLayoutSubviews];\n    NSLog(@\"4...\");\n}\n\n- (void)viewWillAppear:(BOOL)animated\n{\n    [super viewWillAppear:animated];\n    NSLog(@\"2...\");\n}\n\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    NSLog(@\"5...\");\n}\n\n@end\n```\n\n`LKView.m`\n```\n#import \"LKView.h\"\n\n@implementation LKView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self)\n    {\n        UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)];\n        [self addSubview:btn];\n    }\n    return self;\n}\n\n- (void)layoutSubviews\n{\n    NSLog(@\"lay out...\");\n}\n\n@end\n```\n\n## 测试结果\n```\n2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...\n2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...\n2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...\n2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...\n2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...\n2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5...\n```\n\n在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。","source":"_posts/iOS基础：UIViewController生命周期.md","raw":"---\ntitle: iOS基础：UIViewController生命周期\ndate: 2017-01-04 11:44:02\ncategories: iOS基础知识\ntags: \n    - iOS\n    - UIViewController\n---\n\n# UIViewController生命周期\n1. init\n2. loadView\n3. viewDidLoad\n4. viewWillAppear\n5. viewWillLayoutSubviews\n6. viewDidLayoutSubviews\n7. viewDidAppear\n8. viewWillDisappear\n9. viewDidDisappear\n10. dealloc\n<!-- more -->\n\n# UIView layoutSubviews方法触发条件\n[layoutSubviews触发条件](http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called)\n- init does not cause layoutSubviews to be called (duh)\n- addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target\n- view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different\n- scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview\n- rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)\n- Resizing a view will call layoutSubviews on its superview\n\n# 在UIViewController中使用UIView时，layoutSubviews的触发时机\n## 测试代码\n`ViewController.m`\n```\n#import \"ViewController.h\"\n#import \"LKView.h\"\n\n@interface ViewController ()\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];\n    [self.view addSubview:view];\n    \n    NSLog(@\"1...\");\n}\n\n- (void)viewWillLayoutSubviews\n{\n    [super viewWillLayoutSubviews];\n    NSLog(@\"3...\");\n}\n\n- (void)viewDidLayoutSubviews\n{\n    [super viewDidLayoutSubviews];\n    NSLog(@\"4...\");\n}\n\n- (void)viewWillAppear:(BOOL)animated\n{\n    [super viewWillAppear:animated];\n    NSLog(@\"2...\");\n}\n\n- (void)viewDidAppear:(BOOL)animated\n{\n    [super viewDidAppear:animated];\n    NSLog(@\"5...\");\n}\n\n@end\n```\n\n`LKView.m`\n```\n#import \"LKView.h\"\n\n@implementation LKView\n\n- (instancetype)initWithFrame:(CGRect)frame\n{\n    self = [super initWithFrame:frame];\n    if (self)\n    {\n        UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)];\n        [self addSubview:btn];\n    }\n    return self;\n}\n\n- (void)layoutSubviews\n{\n    NSLog(@\"lay out...\");\n}\n\n@end\n```\n\n## 测试结果\n```\n2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...\n2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...\n2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...\n2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...\n2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...\n2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5...\n```\n\n在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。","slug":"iOS基础：UIViewController生命周期","published":1,"updated":"2019-03-11T09:33:04.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0r0007nflwfmk9nld0","content":"<h1 id=\"UIViewController生命周期\"><a href=\"#UIViewController生命周期\" class=\"headerlink\" title=\"UIViewController生命周期\"></a>UIViewController生命周期</h1><ol>\n<li>init</li>\n<li>loadView</li>\n<li>viewDidLoad</li>\n<li>viewWillAppear</li>\n<li>viewWillLayoutSubviews</li>\n<li>viewDidLayoutSubviews</li>\n<li>viewDidAppear</li>\n<li>viewWillDisappear</li>\n<li>viewDidDisappear</li>\n<li>dealloc<a id=\"more\"></a>\n</li>\n</ol>\n<h1 id=\"UIView-layoutSubviews方法触发条件\"><a href=\"#UIView-layoutSubviews方法触发条件\" class=\"headerlink\" title=\"UIView layoutSubviews方法触发条件\"></a>UIView layoutSubviews方法触发条件</h1><p><a href=\"http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called\" target=\"_blank\" rel=\"noopener\">layoutSubviews触发条件</a></p>\n<ul>\n<li>init does not cause layoutSubviews to be called (duh)</li>\n<li>addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target</li>\n<li>view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different</li>\n<li>scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview</li>\n<li>rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)</li>\n<li>Resizing a view will call layoutSubviews on its superview</li>\n</ul>\n<h1 id=\"在UIViewController中使用UIView时，layoutSubviews的触发时机\"><a href=\"#在UIViewController中使用UIView时，layoutSubviews的触发时机\" class=\"headerlink\" title=\"在UIViewController中使用UIView时，layoutSubviews的触发时机\"></a>在UIViewController中使用UIView时，layoutSubviews的触发时机</h1><h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p><code>ViewController.m</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\">#import &quot;LKView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];</span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;1...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillLayoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewWillLayoutSubviews];</span><br><span class=\"line\">    NSLog(@&quot;3...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLayoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLayoutSubviews];</span><br><span class=\"line\">    NSLog(@&quot;4...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    NSLog(@&quot;2...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidAppear:animated];</span><br><span class=\"line\">    NSLog(@&quot;5...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p><code>LKView.m</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;LKView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation LKView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super initWithFrame:frame];</span><br><span class=\"line\">    if (self)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)];</span><br><span class=\"line\">        [self addSubview:btn];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)layoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;lay out...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...</span><br><span class=\"line\">2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...</span><br><span class=\"line\">2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...</span><br><span class=\"line\">2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...</span><br><span class=\"line\">2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...</span><br><span class=\"line\">2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5...</span><br></pre></td></tr></table></figure>\n<p>在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"UIViewController生命周期\"><a href=\"#UIViewController生命周期\" class=\"headerlink\" title=\"UIViewController生命周期\"></a>UIViewController生命周期</h1><ol>\n<li>init</li>\n<li>loadView</li>\n<li>viewDidLoad</li>\n<li>viewWillAppear</li>\n<li>viewWillLayoutSubviews</li>\n<li>viewDidLayoutSubviews</li>\n<li>viewDidAppear</li>\n<li>viewWillDisappear</li>\n<li>viewDidDisappear</li>\n<li>dealloc","more":"</li>\n</ol>\n<h1 id=\"UIView-layoutSubviews方法触发条件\"><a href=\"#UIView-layoutSubviews方法触发条件\" class=\"headerlink\" title=\"UIView layoutSubviews方法触发条件\"></a>UIView layoutSubviews方法触发条件</h1><p><a href=\"http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called\" target=\"_blank\" rel=\"noopener\">layoutSubviews触发条件</a></p>\n<ul>\n<li>init does not cause layoutSubviews to be called (duh)</li>\n<li>addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target</li>\n<li>view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different</li>\n<li>scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview</li>\n<li>rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)</li>\n<li>Resizing a view will call layoutSubviews on its superview</li>\n</ul>\n<h1 id=\"在UIViewController中使用UIView时，layoutSubviews的触发时机\"><a href=\"#在UIViewController中使用UIView时，layoutSubviews的触发时机\" class=\"headerlink\" title=\"在UIViewController中使用UIView时，layoutSubviews的触发时机\"></a>在UIViewController中使用UIView时，layoutSubviews的触发时机</h1><h2 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h2><p><code>ViewController.m</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;ViewController.h&quot;</span><br><span class=\"line\">#import &quot;LKView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ViewController ()</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];</span><br><span class=\"line\">    [self.view addSubview:view];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;1...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillLayoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewWillLayoutSubviews];</span><br><span class=\"line\">    NSLog(@&quot;3...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLayoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLayoutSubviews];</span><br><span class=\"line\">    NSLog(@&quot;4...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    NSLog(@&quot;2...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidAppear:animated];</span><br><span class=\"line\">    NSLog(@&quot;5...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p><code>LKView.m</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;LKView.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation LKView</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super initWithFrame:frame];</span><br><span class=\"line\">    if (self)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)];</span><br><span class=\"line\">        [self addSubview:btn];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)layoutSubviews</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;lay out...&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...</span><br><span class=\"line\">2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...</span><br><span class=\"line\">2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...</span><br><span class=\"line\">2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...</span><br><span class=\"line\">2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...</span><br><span class=\"line\">2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5...</span><br></pre></td></tr></table></figure>\n<p>在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。</p>"},{"title":"iOS基础：GCD","date":"2016-08-11T12:34:23.000Z","_content":"\nGCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。\n\n# 前提\n1. 代码是顺序执行的。\n2. queue是FIFO（先进先出）的数据结构。\n3. 线程之间是并行的。\n4. `串行队列`：任务`不能同时进行`，这意味着第n+1个任务必须等待0...n个任务全部完成后才会开始。\n5. `并发队列`：任务`可以同时进行`，这意味着只要0...n个任务开始执行，那么第n+1个任务也可以开始。\n6. `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`：将任务（也就是block）放到队列中，同步执行，也就是说在`当前线程`中执行任务，`阻塞当前线程`。\n7. `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`：将任务放到队列中，异步执行，也就是说在`其他线程`中执行任务，`不阻塞当前线程`。（在下文的推演中，发现其并不总是在`其他线程`中执行）\n（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue）\n<!-- more -->\n\n# 验证\n## 1. 代码是顺序执行的。\n```\n    NSLog(@\"step0\");\n    NSLog(@\"step1\");\n```\n\n```\n    2016-08-12 22:29:49.002 MyPractice[25215:3752290] step0\n    2016-08-12 22:29:49.002 MyPractice[25215:3752290] step1\n```\n可以看到确实是顺序执行的（严肃脸）。\n\n## 2. queue是FIFO（先进先出）的数据结构。\n\n## 3. 线程之间是并行的。\n\n## 4. `串行队列`：任务`不能同时进行`，这意味着第n+1个任务必须等待0...n个任务全部完成后才会开始。\n首先来看什么是`DISPATCH_QUEUE_SERIAL`。\n```\n    /*!\n     * @const DISPATCH_QUEUE_SERIAL\n     * @discussion A dispatch queue that invokes blocks serially in FIFO order.\n     */\n    #define DISPATCH_QUEUE_SERIAL NULL\n```\n该队列以先进先出的顺序串行调用blocks。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    for (int i = 0; i < 3; i++) {\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.%d finished! - %@\", i, [NSThread currentThread]);\n        });\n    }\n    \n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - <NSThread: 0x7fac03602dd0>{number = 1, name = main}\n2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - <NSThread: 0x7fac03602dd0>{number = 1, name = main}\n2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n```\n可以看到1大类中的三个任务顺序执行。\n\n## 5. `并发队列`：任务`可以同时进行`，这意味着只要0...n个任务开始执行，那么第n+1个任务也可以开始。\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    for (int i = 0; i < 3; i++) {\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.%d finished! - %@\", i, [NSThread currentThread]);\n        });\n    }\n    \n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - <NSThread: 0x7f9c08c059f0>{number = 1, name = main}\n2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - <NSThread: 0x7f9c08c059f0>{number = 1, name = main}\n2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - <NSThread: 0x7f9c08f04540>{number = 3, name = (null)}\n2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - <NSThread: 0x7f9c08d0acc0>{number = 2, name = (null)}\n2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - <NSThread: 0x7f9c08e0b560>{number = 4, name = (null)}\n```\n可以看到1大类中的三个任务同时执行。\n\n## 6. `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`：将任务（也就是block）放到队列中，同步执行，也就是说在`当前线程`中执行任务，`阻塞当前线程`。\n### dispatch_sync任务到其它串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{    // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n```\nblock1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。\n\n### dispatch_sync任务到当前串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - <NSThread: 0x7f80d8701fc0>{number = 1, name = main}\n```\n整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。\n至此，block0与block1循环等待，死锁。\n\n### dispatch_sync任务到其它并发队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n```\nstep0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。\n\n**总结**\n```\n/*!\n * @function dispatch_sync\n *\n * @abstract\n * Submits a block for synchronous execution on a dispatch queue.\n *\n * @discussion\n * Submits a block to a dispatch queue like dispatch_async(), however\n * dispatch_sync() will not return until the block has finished.\n *\n * Calls to dispatch_sync() targeting the current queue will result\n * in dead-lock. Use of dispatch_sync() is also subject to the same\n * multi-party dead-lock problems that may result from the use of a mutex.\n * Use of dispatch_async() is preferred.\n *\n * Unlike dispatch_async(), no retain is performed on the target queue. Because\n * calls to this function are synchronous, the dispatch_sync() \"borrows\" the\n * reference of the caller.\n *\n * As an optimization, dispatch_sync() invokes the block on the current\n * thread when possible.\n *\n * @param queue\n * The target dispatch queue to which the block is submitted.\n * The result of passing NULL in this parameter is undefined.\n *\n * @param block\n * The block to be invoked on the target dispatch queue.\n * The result of passing NULL in this parameter is undefined.\n */\n#ifdef __BLOCKS__\n__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\n#endif\n```\n- dispatch_sync()在block结束前不会返回。\n- dispatch_sync()任务到当前队列中会引起死锁。\n- 系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。\n- dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。\n- 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。\n- 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。\n\n## 7. `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`：将任务放到队列中，异步执行，也就是说在`其他线程`中执行任务，`不阻塞当前线程`。\n### dispatch_async任务到其它串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - <NSThread: 0x7fe7196022e0>{number = 1, name = main}\n2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - <NSThread: 0x7fe7196a2f50>{number = 2, name = (null)}\n2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - <NSThread: 0x7fe7196022e0>{number = 1, name = main}\n```\n执行顺序为step0 -> step1 -> step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。\n程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。\n\n### dispatch_async任务到当前串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n```\n执行顺序为step0 -> step2 -> step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。\n执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。\n\n### dispatch_async任务到其他并发队列中。\n已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。\n\n**总结**\n```\n/*!\n * @function dispatch_async\n *\n * @abstract\n * Submits a block for asynchronous execution on a dispatch queue.\n *\n * @discussion\n * The dispatch_async() function is the fundamental mechanism for submitting\n * blocks to a dispatch queue.\n *\n * Calls to dispatch_async() always return immediately after the block has\n * been submitted, and never wait for the block to be invoked.\n *\n * The target queue determines whether the block will be invoked serially or\n * concurrently with respect to other blocks submitted to that same queue.\n * Serial queues are processed concurrently with respect to each other.\n *\n * @param queue\n * The target dispatch queue to which the block is submitted.\n * The system will hold a reference on the target queue until the block\n * has finished.\n * The result of passing NULL in this parameter is undefined.\n *\n * @param block\n * The block to submit to the target dispatch queue. This function performs\n * Block_copy() and Block_release() on behalf of callers.\n * The result of passing NULL in this parameter is undefined.\n */\n#ifdef __BLOCKS__\n__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n#endif\n```\n- dispatch_async()的机制是把blocks任务提交到队列中。\n- dispatch_async()会立即返回而不会等待block完成。\n- 目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。\n**这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验**\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1.1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1.1 finished! - %@\", [NSThread currentThread]);\n        \n        dispatch_async(queue, ^{     // block1.2\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.2 finished! - %@\", [NSThread currentThread]);\n        });\n    });\n    \n    dispatch_async(queue, ^{     // block1.3\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1.3 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:3];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - <NSThread: 0x7fbe786079a0>{number = 1, name = main}\n2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - <NSThread: 0x7fbe786079a0>{number = 1, name = main}\n2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n```\nblock1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；\nblock1.2仍然在当前线程（0x7fbe78419320）中执行；\n另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程；\n\n结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系：\n- 主队列对应着主线程；\n- 并发队列对应多条线程（非主线程）；\n- 串行队列对应着一条线程（非主线程）；\n- dispatch_sync&dispatch_async：调度对应线程池中的线程；\n\n接下来继续解读官方API\n- 系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放）\n- 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。\n- dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease）\n- 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。\n\n最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    __weak ViewController* weakSelf = self;\n    dispatch_async(queue, ^{     // block1\n        NSLog(@\"before step1! - %@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1];\n        weakSelf.view.backgroundColor = [UIColor blueColor];\n        NSLog(@\"after step1! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - <NSThread: 0x7fd5e1403450>{number = 1, name = main}\n2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - <NSThread: 0x7fd5e1523bb0>{number = 2, name = (null)}\n2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - <NSThread: 0x7fd5e1523bb0>{number = 2, name = (null)}\n2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - <NSThread: 0x7fd5e1403450>{number = 1, name = main}\n```\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    __weak ViewController* weakSelf = self;\n    dispatch_sync(queue, ^{     // block1\n        NSLog(@\"before step1! - %@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1];\n        weakSelf.view.backgroundColor = [UIColor blueColor];\n        NSLog(@\"after step1! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n```\n\n可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。\n此处迷茫++，还得继续研究啊...\n","source":"_posts/iOS基础：GCD.md","raw":"---\ntitle: iOS基础：GCD\ndate: 2016-08-11 20:34:23\ncategories: iOS基础知识\ntags: \n    - iOS\n    - 多线程\n    - GCD\n---\n\nGCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。\n\n# 前提\n1. 代码是顺序执行的。\n2. queue是FIFO（先进先出）的数据结构。\n3. 线程之间是并行的。\n4. `串行队列`：任务`不能同时进行`，这意味着第n+1个任务必须等待0...n个任务全部完成后才会开始。\n5. `并发队列`：任务`可以同时进行`，这意味着只要0...n个任务开始执行，那么第n+1个任务也可以开始。\n6. `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`：将任务（也就是block）放到队列中，同步执行，也就是说在`当前线程`中执行任务，`阻塞当前线程`。\n7. `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`：将任务放到队列中，异步执行，也就是说在`其他线程`中执行任务，`不阻塞当前线程`。（在下文的推演中，发现其并不总是在`其他线程`中执行）\n（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue）\n<!-- more -->\n\n# 验证\n## 1. 代码是顺序执行的。\n```\n    NSLog(@\"step0\");\n    NSLog(@\"step1\");\n```\n\n```\n    2016-08-12 22:29:49.002 MyPractice[25215:3752290] step0\n    2016-08-12 22:29:49.002 MyPractice[25215:3752290] step1\n```\n可以看到确实是顺序执行的（严肃脸）。\n\n## 2. queue是FIFO（先进先出）的数据结构。\n\n## 3. 线程之间是并行的。\n\n## 4. `串行队列`：任务`不能同时进行`，这意味着第n+1个任务必须等待0...n个任务全部完成后才会开始。\n首先来看什么是`DISPATCH_QUEUE_SERIAL`。\n```\n    /*!\n     * @const DISPATCH_QUEUE_SERIAL\n     * @discussion A dispatch queue that invokes blocks serially in FIFO order.\n     */\n    #define DISPATCH_QUEUE_SERIAL NULL\n```\n该队列以先进先出的顺序串行调用blocks。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    for (int i = 0; i < 3; i++) {\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.%d finished! - %@\", i, [NSThread currentThread]);\n        });\n    }\n    \n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - <NSThread: 0x7fac03602dd0>{number = 1, name = main}\n2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - <NSThread: 0x7fac03602dd0>{number = 1, name = main}\n2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - <NSThread: 0x7fac034a0690>{number = 2, name = (null)}\n```\n可以看到1大类中的三个任务顺序执行。\n\n## 5. `并发队列`：任务`可以同时进行`，这意味着只要0...n个任务开始执行，那么第n+1个任务也可以开始。\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    for (int i = 0; i < 3; i++) {\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.%d finished! - %@\", i, [NSThread currentThread]);\n        });\n    }\n    \n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - <NSThread: 0x7f9c08c059f0>{number = 1, name = main}\n2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - <NSThread: 0x7f9c08c059f0>{number = 1, name = main}\n2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - <NSThread: 0x7f9c08f04540>{number = 3, name = (null)}\n2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - <NSThread: 0x7f9c08d0acc0>{number = 2, name = (null)}\n2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - <NSThread: 0x7f9c08e0b560>{number = 4, name = (null)}\n```\n可以看到1大类中的三个任务同时执行。\n\n## 6. `void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);`：将任务（也就是block）放到队列中，同步执行，也就是说在`当前线程`中执行任务，`阻塞当前线程`。\n### dispatch_sync任务到其它串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{    // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - <NSThread: 0x7f8050606ad0>{number = 1, name = main}\n```\nblock1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。\n\n### dispatch_sync任务到当前串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - <NSThread: 0x7f80d8701fc0>{number = 1, name = main}\n```\n整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。\n至此，block0与block1循环等待，死锁。\n\n### dispatch_sync任务到其它并发队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_CONCURRENT);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_sync(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - <NSThread: 0x7faec9403070>{number = 1, name = main}\n```\nstep0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。\n\n**总结**\n```\n/*!\n * @function dispatch_sync\n *\n * @abstract\n * Submits a block for synchronous execution on a dispatch queue.\n *\n * @discussion\n * Submits a block to a dispatch queue like dispatch_async(), however\n * dispatch_sync() will not return until the block has finished.\n *\n * Calls to dispatch_sync() targeting the current queue will result\n * in dead-lock. Use of dispatch_sync() is also subject to the same\n * multi-party dead-lock problems that may result from the use of a mutex.\n * Use of dispatch_async() is preferred.\n *\n * Unlike dispatch_async(), no retain is performed on the target queue. Because\n * calls to this function are synchronous, the dispatch_sync() \"borrows\" the\n * reference of the caller.\n *\n * As an optimization, dispatch_sync() invokes the block on the current\n * thread when possible.\n *\n * @param queue\n * The target dispatch queue to which the block is submitted.\n * The result of passing NULL in this parameter is undefined.\n *\n * @param block\n * The block to be invoked on the target dispatch queue.\n * The result of passing NULL in this parameter is undefined.\n */\n#ifdef __BLOCKS__\n__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_sync(dispatch_queue_t queue, dispatch_block_t block);\n#endif\n```\n- dispatch_sync()在block结束前不会返回。\n- dispatch_sync()任务到当前队列中会引起死锁。\n- 系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。\n- dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。\n- 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。\n- 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。\n\n## 7. `void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);`：将任务放到队列中，异步执行，也就是说在`其他线程`中执行任务，`不阻塞当前线程`。\n### dispatch_async任务到其它串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - <NSThread: 0x7fe7196022e0>{number = 1, name = main}\n2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - <NSThread: 0x7fe7196a2f50>{number = 2, name = (null)}\n2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - <NSThread: 0x7fe7196022e0>{number = 1, name = main}\n```\n执行顺序为step0 -> step1 -> step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。\n程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。\n\n### dispatch_async任务到当前串行队列中。\n\n```\n    dispatch_queue_t queue = dispatch_get_main_queue();\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - <NSThread: 0x7fc280d07d30>{number = 1, name = main}\n```\n执行顺序为step0 -> step2 -> step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。\n执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。\n\n### dispatch_async任务到其他并发队列中。\n已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。\n\n**总结**\n```\n/*!\n * @function dispatch_async\n *\n * @abstract\n * Submits a block for asynchronous execution on a dispatch queue.\n *\n * @discussion\n * The dispatch_async() function is the fundamental mechanism for submitting\n * blocks to a dispatch queue.\n *\n * Calls to dispatch_async() always return immediately after the block has\n * been submitted, and never wait for the block to be invoked.\n *\n * The target queue determines whether the block will be invoked serially or\n * concurrently with respect to other blocks submitted to that same queue.\n * Serial queues are processed concurrently with respect to each other.\n *\n * @param queue\n * The target dispatch queue to which the block is submitted.\n * The system will hold a reference on the target queue until the block\n * has finished.\n * The result of passing NULL in this parameter is undefined.\n *\n * @param block\n * The block to submit to the target dispatch queue. This function performs\n * Block_copy() and Block_release() on behalf of callers.\n * The result of passing NULL in this parameter is undefined.\n */\n#ifdef __BLOCKS__\n__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)\nDISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW\nvoid\ndispatch_async(dispatch_queue_t queue, dispatch_block_t block);\n#endif\n```\n- dispatch_async()的机制是把blocks任务提交到队列中。\n- dispatch_async()会立即返回而不会等待block完成。\n- 目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。\n**这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验**\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    dispatch_async(queue, ^{     // block1.1\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1.1 finished! - %@\", [NSThread currentThread]);\n        \n        dispatch_async(queue, ^{     // block1.2\n            [NSThread sleepForTimeInterval:1];\n            NSLog(@\"step1.2 finished! - %@\", [NSThread currentThread]);\n        });\n    });\n    \n    dispatch_async(queue, ^{     // block1.3\n        [NSThread sleepForTimeInterval:1];\n        NSLog(@\"step1.3 finished! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:3];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - <NSThread: 0x7fbe786079a0>{number = 1, name = main}\n2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - <NSThread: 0x7fbe786079a0>{number = 1, name = main}\n2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - <NSThread: 0x7fbe78419320>{number = 2, name = (null)}\n```\nblock1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；\nblock1.2仍然在当前线程（0x7fbe78419320）中执行；\n另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程；\n\n结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系：\n- 主队列对应着主线程；\n- 并发队列对应多条线程（非主线程）；\n- 串行队列对应着一条线程（非主线程）；\n- dispatch_sync&dispatch_async：调度对应线程池中的线程；\n\n接下来继续解读官方API\n- 系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放）\n- 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。\n- dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease）\n- 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。\n\n最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    __weak ViewController* weakSelf = self;\n    dispatch_async(queue, ^{     // block1\n        NSLog(@\"before step1! - %@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1];\n        weakSelf.view.backgroundColor = [UIColor blueColor];\n        NSLog(@\"after step1! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - <NSThread: 0x7fd5e1403450>{number = 1, name = main}\n2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - <NSThread: 0x7fd5e1523bb0>{number = 2, name = (null)}\n2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - <NSThread: 0x7fd5e1523bb0>{number = 2, name = (null)}\n2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - <NSThread: 0x7fd5e1403450>{number = 1, name = main}\n```\n\n```\n    dispatch_queue_t queue = dispatch_queue_create(\"cn.edu.bjtu.myQueue\", DISPATCH_QUEUE_SERIAL);\n    \n    NSLog(@\"step0 finished! - %@\", [NSThread currentThread]);\n    \n    __weak ViewController* weakSelf = self;\n    dispatch_sync(queue, ^{     // block1\n        NSLog(@\"before step1! - %@\", [NSThread currentThread]);\n        [NSThread sleepForTimeInterval:1];\n        weakSelf.view.backgroundColor = [UIColor blueColor];\n        NSLog(@\"after step1! - %@\", [NSThread currentThread]);\n    });\n    \n    [NSThread sleepForTimeInterval:2];\n    NSLog(@\"step2 finished! - %@\", [NSThread currentThread]);\n```\n\n```\n2016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - <NSThread: 0x7f8962402ee0>{number = 1, name = main}\n```\n\n可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。\n此处迷茫++，还得继续研究啊...\n","slug":"iOS基础：GCD","published":1,"updated":"2019-03-11T09:32:57.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0t000anflw9ib185fz","content":"<p>GCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。</p>\n<h1 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h1><ol>\n<li>代码是顺序执行的。</li>\n<li>queue是FIFO（先进先出）的数据结构。</li>\n<li>线程之间是并行的。</li>\n<li><code>串行队列</code>：任务<code>不能同时进行</code>，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。</li>\n<li><code>并发队列</code>：任务<code>可以同时进行</code>，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。</li>\n<li><code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务（也就是block）放到队列中，同步执行，也就是说在<code>当前线程</code>中执行任务，<code>阻塞当前线程</code>。</li>\n<li><code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务放到队列中，异步执行，也就是说在<code>其他线程</code>中执行任务，<code>不阻塞当前线程</code>。（在下文的推演中，发现其并不总是在<code>其他线程</code>中执行）<br>（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue）<a id=\"more\"></a>\n</li>\n</ol>\n<h1 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h1><h2 id=\"1-代码是顺序执行的。\"><a href=\"#1-代码是顺序执行的。\" class=\"headerlink\" title=\"1. 代码是顺序执行的。\"></a>1. 代码是顺序执行的。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSLog(@&quot;step0&quot;);</span><br><span class=\"line\">NSLog(@&quot;step1&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-12 22:29:49.002 MyPractice[25215:3752290] step0</span><br><span class=\"line\">2016-08-12 22:29:49.002 MyPractice[25215:3752290] step1</span><br></pre></td></tr></table></figure>\n<p>可以看到确实是顺序执行的（严肃脸）。</p>\n<h2 id=\"2-queue是FIFO（先进先出）的数据结构。\"><a href=\"#2-queue是FIFO（先进先出）的数据结构。\" class=\"headerlink\" title=\"2. queue是FIFO（先进先出）的数据结构。\"></a>2. queue是FIFO（先进先出）的数据结构。</h2><h2 id=\"3-线程之间是并行的。\"><a href=\"#3-线程之间是并行的。\" class=\"headerlink\" title=\"3. 线程之间是并行的。\"></a>3. 线程之间是并行的。</h2><h2 id=\"4-串行队列：任务不能同时进行，这意味着第n-1个任务必须等待0…n个任务全部完成后才会开始。\"><a href=\"#4-串行队列：任务不能同时进行，这意味着第n-1个任务必须等待0…n个任务全部完成后才会开始。\" class=\"headerlink\" title=\"4. 串行队列：任务不能同时进行，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。\"></a>4. <code>串行队列</code>：任务<code>不能同时进行</code>，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。</h2><p>首先来看什么是<code>DISPATCH_QUEUE_SERIAL</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @const DISPATCH_QUEUE_SERIAL</span><br><span class=\"line\"> * @discussion A dispatch queue that invokes blocks serially in FIFO order.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL NULL</span><br></pre></td></tr></table></figure></p>\n<p>该队列以先进先出的顺序串行调用blocks。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到1大类中的三个任务顺序执行。</p>\n<h2 id=\"5-并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n-1个任务也可以开始。\"><a href=\"#5-并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n-1个任务也可以开始。\" class=\"headerlink\" title=\"5. 并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。\"></a>5. <code>并发队列</code>：任务<code>可以同时进行</code>，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - &lt;NSThread: 0x7f9c08f04540&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - &lt;NSThread: 0x7f9c08d0acc0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - &lt;NSThread: 0x7f9c08e0b560&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到1大类中的三个任务同时执行。</p>\n<h2 id=\"6-void-dispatch-sync-dispatch-queue-t-queue-dispatch-block-t-block-：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\"><a href=\"#6-void-dispatch-sync-dispatch-queue-t-queue-dispatch-block-t-block-：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\" class=\"headerlink\" title=\"6. void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\"></a>6. <code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务（也就是block）放到队列中，同步执行，也就是说在<code>当前线程</code>中执行任务，<code>阻塞当前线程</code>。</h2><h3 id=\"dispatch-sync任务到其它串行队列中。\"><a href=\"#dispatch-sync任务到其它串行队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到其它串行队列中。\"></a>dispatch_sync任务到其它串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;    // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>block1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。</p>\n<h3 id=\"dispatch-sync任务到当前串行队列中。\"><a href=\"#dispatch-sync任务到当前串行队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到当前串行队列中。\"></a>dispatch_sync任务到当前串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - &lt;NSThread: 0x7f80d8701fc0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。<br>至此，block0与block1循环等待，死锁。</p>\n<h3 id=\"dispatch-sync任务到其它并发队列中。\"><a href=\"#dispatch-sync任务到其它并发队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到其它并发队列中。\"></a>dispatch_sync任务到其它并发队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>step0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。</p>\n<p><strong>总结</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @function dispatch_sync</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @abstract</span><br><span class=\"line\"> * Submits a block for synchronous execution on a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @discussion</span><br><span class=\"line\"> * Submits a block to a dispatch queue like dispatch_async(), however</span><br><span class=\"line\"> * dispatch_sync() will not return until the block has finished.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Calls to dispatch_sync() targeting the current queue will result</span><br><span class=\"line\"> * in dead-lock. Use of dispatch_sync() is also subject to the same</span><br><span class=\"line\"> * multi-party dead-lock problems that may result from the use of a mutex.</span><br><span class=\"line\"> * Use of dispatch_async() is preferred.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Unlike dispatch_async(), no retain is performed on the target queue. Because</span><br><span class=\"line\"> * calls to this function are synchronous, the dispatch_sync() &quot;borrows&quot; the</span><br><span class=\"line\"> * reference of the caller.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * As an optimization, dispatch_sync() invokes the block on the current</span><br><span class=\"line\"> * thread when possible.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param queue</span><br><span class=\"line\"> * The target dispatch queue to which the block is submitted.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param block</span><br><span class=\"line\"> * The block to be invoked on the target dispatch queue.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#ifdef __BLOCKS__</span><br><span class=\"line\">__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)</span><br><span class=\"line\">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\">void</span><br><span class=\"line\">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dispatch_sync()在block结束前不会返回。</li>\n<li>dispatch_sync()任务到当前队列中会引起死锁。</li>\n<li>系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。</li>\n<li>dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。</li>\n<li>参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。</li>\n<li>参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。</li>\n</ul>\n<h2 id=\"7-void-dispatch-async-dispatch-queue-t-queue-dispatch-block-t-block-：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\"><a href=\"#7-void-dispatch-async-dispatch-queue-t-queue-dispatch-block-t-block-：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\" class=\"headerlink\" title=\"7. void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\"></a>7. <code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务放到队列中，异步执行，也就是说在<code>其他线程</code>中执行任务，<code>不阻塞当前线程</code>。</h2><h3 id=\"dispatch-async任务到其它串行队列中。\"><a href=\"#dispatch-async任务到其它串行队列中。\" class=\"headerlink\" title=\"dispatch_async任务到其它串行队列中。\"></a>dispatch_async任务到其它串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - &lt;NSThread: 0x7fe7196a2f50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>执行顺序为step0 -&gt; step1 -&gt; step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。<br>程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。</p>\n<h3 id=\"dispatch-async任务到当前串行队列中。\"><a href=\"#dispatch-async任务到当前串行队列中。\" class=\"headerlink\" title=\"dispatch_async任务到当前串行队列中。\"></a>dispatch_async任务到当前串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>执行顺序为step0 -&gt; step2 -&gt; step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。<br>执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。</p>\n<h3 id=\"dispatch-async任务到其他并发队列中。\"><a href=\"#dispatch-async任务到其他并发队列中。\" class=\"headerlink\" title=\"dispatch_async任务到其他并发队列中。\"></a>dispatch_async任务到其他并发队列中。</h3><p>已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。</p>\n<p><strong>总结</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @function dispatch_async</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @abstract</span><br><span class=\"line\"> * Submits a block for asynchronous execution on a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @discussion</span><br><span class=\"line\"> * The dispatch_async() function is the fundamental mechanism for submitting</span><br><span class=\"line\"> * blocks to a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Calls to dispatch_async() always return immediately after the block has</span><br><span class=\"line\"> * been submitted, and never wait for the block to be invoked.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * The target queue determines whether the block will be invoked serially or</span><br><span class=\"line\"> * concurrently with respect to other blocks submitted to that same queue.</span><br><span class=\"line\"> * Serial queues are processed concurrently with respect to each other.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param queue</span><br><span class=\"line\"> * The target dispatch queue to which the block is submitted.</span><br><span class=\"line\"> * The system will hold a reference on the target queue until the block</span><br><span class=\"line\"> * has finished.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param block</span><br><span class=\"line\"> * The block to submit to the target dispatch queue. This function performs</span><br><span class=\"line\"> * Block_copy() and Block_release() on behalf of callers.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#ifdef __BLOCKS__</span><br><span class=\"line\">__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)</span><br><span class=\"line\">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\">void</span><br><span class=\"line\">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dispatch_async()的机制是把blocks任务提交到队列中。</li>\n<li>dispatch_async()会立即返回而不会等待block完成。</li>\n<li>目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。<br><strong>这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1.1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1.1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;     // block1.2</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.2 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1.3</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1.3 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:3];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>block1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；<br>block1.2仍然在当前线程（0x7fbe78419320）中执行；<br>另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程；</p>\n<p>结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系：</p>\n<ul>\n<li>主队列对应着主线程；</li>\n<li>并发队列对应多条线程（非主线程）；</li>\n<li>串行队列对应着一条线程（非主线程）；</li>\n<li>dispatch_sync&amp;dispatch_async：调度对应线程池中的线程；</li>\n</ul>\n<p>接下来继续解读官方API</p>\n<ul>\n<li>系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放）</li>\n<li>参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。</li>\n<li>dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease）</li>\n<li>参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。</li>\n</ul>\n<p>最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">__weak ViewController* weakSelf = self;</span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    weakSelf.view.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">__weak ViewController* weakSelf = self;</span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    weakSelf.view.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。<br>此处迷茫++，还得继续研究啊…</p>\n","site":{"data":{}},"excerpt":"<p>GCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。</p>\n<h1 id=\"前提\"><a href=\"#前提\" class=\"headerlink\" title=\"前提\"></a>前提</h1><ol>\n<li>代码是顺序执行的。</li>\n<li>queue是FIFO（先进先出）的数据结构。</li>\n<li>线程之间是并行的。</li>\n<li><code>串行队列</code>：任务<code>不能同时进行</code>，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。</li>\n<li><code>并发队列</code>：任务<code>可以同时进行</code>，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。</li>\n<li><code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务（也就是block）放到队列中，同步执行，也就是说在<code>当前线程</code>中执行任务，<code>阻塞当前线程</code>。</li>\n<li><code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务放到队列中，异步执行，也就是说在<code>其他线程</code>中执行任务，<code>不阻塞当前线程</code>。（在下文的推演中，发现其并不总是在<code>其他线程</code>中执行）<br>（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue）","more":"</li>\n</ol>\n<h1 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h1><h2 id=\"1-代码是顺序执行的。\"><a href=\"#1-代码是顺序执行的。\" class=\"headerlink\" title=\"1. 代码是顺序执行的。\"></a>1. 代码是顺序执行的。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSLog(@&quot;step0&quot;);</span><br><span class=\"line\">NSLog(@&quot;step1&quot;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-12 22:29:49.002 MyPractice[25215:3752290] step0</span><br><span class=\"line\">2016-08-12 22:29:49.002 MyPractice[25215:3752290] step1</span><br></pre></td></tr></table></figure>\n<p>可以看到确实是顺序执行的（严肃脸）。</p>\n<h2 id=\"2-queue是FIFO（先进先出）的数据结构。\"><a href=\"#2-queue是FIFO（先进先出）的数据结构。\" class=\"headerlink\" title=\"2. queue是FIFO（先进先出）的数据结构。\"></a>2. queue是FIFO（先进先出）的数据结构。</h2><h2 id=\"3-线程之间是并行的。\"><a href=\"#3-线程之间是并行的。\" class=\"headerlink\" title=\"3. 线程之间是并行的。\"></a>3. 线程之间是并行的。</h2><h2 id=\"4-串行队列：任务不能同时进行，这意味着第n-1个任务必须等待0…n个任务全部完成后才会开始。\"><a href=\"#4-串行队列：任务不能同时进行，这意味着第n-1个任务必须等待0…n个任务全部完成后才会开始。\" class=\"headerlink\" title=\"4. 串行队列：任务不能同时进行，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。\"></a>4. <code>串行队列</code>：任务<code>不能同时进行</code>，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。</h2><p>首先来看什么是<code>DISPATCH_QUEUE_SERIAL</code>。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @const DISPATCH_QUEUE_SERIAL</span><br><span class=\"line\"> * @discussion A dispatch queue that invokes blocks serially in FIFO order.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#define DISPATCH_QUEUE_SERIAL NULL</span><br></pre></td></tr></table></figure></p>\n<p>该队列以先进先出的顺序串行调用blocks。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到1大类中的三个任务顺序执行。</p>\n<h2 id=\"5-并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n-1个任务也可以开始。\"><a href=\"#5-并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n-1个任务也可以开始。\" class=\"headerlink\" title=\"5. 并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。\"></a>5. <code>并发队列</code>：任务<code>可以同时进行</code>，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class=\"line\">    dispatch_async(queue, ^&#123;</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - &lt;NSThread: 0x7f9c08f04540&gt;&#123;number = 3, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - &lt;NSThread: 0x7f9c08d0acc0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - &lt;NSThread: 0x7f9c08e0b560&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到1大类中的三个任务同时执行。</p>\n<h2 id=\"6-void-dispatch-sync-dispatch-queue-t-queue-dispatch-block-t-block-：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\"><a href=\"#6-void-dispatch-sync-dispatch-queue-t-queue-dispatch-block-t-block-：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\" class=\"headerlink\" title=\"6. void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。\"></a>6. <code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务（也就是block）放到队列中，同步执行，也就是说在<code>当前线程</code>中执行任务，<code>阻塞当前线程</code>。</h2><h3 id=\"dispatch-sync任务到其它串行队列中。\"><a href=\"#dispatch-sync任务到其它串行队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到其它串行队列中。\"></a>dispatch_sync任务到其它串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;    // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>block1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。</p>\n<h3 id=\"dispatch-sync任务到当前串行队列中。\"><a href=\"#dispatch-sync任务到当前串行队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到当前串行队列中。\"></a>dispatch_sync任务到当前串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - &lt;NSThread: 0x7f80d8701fc0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。<br>至此，block0与block1循环等待，死锁。</p>\n<h3 id=\"dispatch-sync任务到其它并发队列中。\"><a href=\"#dispatch-sync任务到其它并发队列中。\" class=\"headerlink\" title=\"dispatch_sync任务到其它并发队列中。\"></a>dispatch_sync任务到其它并发队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>step0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。</p>\n<p><strong>总结</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @function dispatch_sync</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @abstract</span><br><span class=\"line\"> * Submits a block for synchronous execution on a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @discussion</span><br><span class=\"line\"> * Submits a block to a dispatch queue like dispatch_async(), however</span><br><span class=\"line\"> * dispatch_sync() will not return until the block has finished.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Calls to dispatch_sync() targeting the current queue will result</span><br><span class=\"line\"> * in dead-lock. Use of dispatch_sync() is also subject to the same</span><br><span class=\"line\"> * multi-party dead-lock problems that may result from the use of a mutex.</span><br><span class=\"line\"> * Use of dispatch_async() is preferred.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Unlike dispatch_async(), no retain is performed on the target queue. Because</span><br><span class=\"line\"> * calls to this function are synchronous, the dispatch_sync() &quot;borrows&quot; the</span><br><span class=\"line\"> * reference of the caller.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * As an optimization, dispatch_sync() invokes the block on the current</span><br><span class=\"line\"> * thread when possible.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param queue</span><br><span class=\"line\"> * The target dispatch queue to which the block is submitted.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param block</span><br><span class=\"line\"> * The block to be invoked on the target dispatch queue.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#ifdef __BLOCKS__</span><br><span class=\"line\">__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)</span><br><span class=\"line\">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\">void</span><br><span class=\"line\">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dispatch_sync()在block结束前不会返回。</li>\n<li>dispatch_sync()任务到当前队列中会引起死锁。</li>\n<li>系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。</li>\n<li>dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。</li>\n<li>参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。</li>\n<li>参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。</li>\n</ul>\n<h2 id=\"7-void-dispatch-async-dispatch-queue-t-queue-dispatch-block-t-block-：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\"><a href=\"#7-void-dispatch-async-dispatch-queue-t-queue-dispatch-block-t-block-：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\" class=\"headerlink\" title=\"7. void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。\"></a>7. <code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code>：将任务放到队列中，异步执行，也就是说在<code>其他线程</code>中执行任务，<code>不阻塞当前线程</code>。</h2><h3 id=\"dispatch-async任务到其它串行队列中。\"><a href=\"#dispatch-async任务到其它串行队列中。\" class=\"headerlink\" title=\"dispatch_async任务到其它串行队列中。\"></a>dispatch_async任务到其它串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - &lt;NSThread: 0x7fe7196a2f50&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>执行顺序为step0 -&gt; step1 -&gt; step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。<br>程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。</p>\n<h3 id=\"dispatch-async任务到当前串行队列中。\"><a href=\"#dispatch-async任务到当前串行队列中。\" class=\"headerlink\" title=\"dispatch_async任务到当前串行队列中。\"></a>dispatch_async任务到当前串行队列中。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>执行顺序为step0 -&gt; step2 -&gt; step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。<br>执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。</p>\n<h3 id=\"dispatch-async任务到其他并发队列中。\"><a href=\"#dispatch-async任务到其他并发队列中。\" class=\"headerlink\" title=\"dispatch_async任务到其他并发队列中。\"></a>dispatch_async任务到其他并发队列中。</h3><p>已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。</p>\n<p><strong>总结</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> * @function dispatch_async</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @abstract</span><br><span class=\"line\"> * Submits a block for asynchronous execution on a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @discussion</span><br><span class=\"line\"> * The dispatch_async() function is the fundamental mechanism for submitting</span><br><span class=\"line\"> * blocks to a dispatch queue.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * Calls to dispatch_async() always return immediately after the block has</span><br><span class=\"line\"> * been submitted, and never wait for the block to be invoked.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * The target queue determines whether the block will be invoked serially or</span><br><span class=\"line\"> * concurrently with respect to other blocks submitted to that same queue.</span><br><span class=\"line\"> * Serial queues are processed concurrently with respect to each other.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param queue</span><br><span class=\"line\"> * The target dispatch queue to which the block is submitted.</span><br><span class=\"line\"> * The system will hold a reference on the target queue until the block</span><br><span class=\"line\"> * has finished.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param block</span><br><span class=\"line\"> * The block to submit to the target dispatch queue. This function performs</span><br><span class=\"line\"> * Block_copy() and Block_release() on behalf of callers.</span><br><span class=\"line\"> * The result of passing NULL in this parameter is undefined.</span><br><span class=\"line\"> */</span><br><span class=\"line\">#ifdef __BLOCKS__</span><br><span class=\"line\">__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)</span><br><span class=\"line\">DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROW</span><br><span class=\"line\">void</span><br><span class=\"line\">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>dispatch_async()的机制是把blocks任务提交到队列中。</li>\n<li>dispatch_async()会立即返回而不会等待block完成。</li>\n<li>目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。<br><strong>这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1.1</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1.1 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    dispatch_async(queue, ^&#123;     // block1.2</span><br><span class=\"line\">        [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">        NSLog(@&quot;step1.2 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1.3</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    NSLog(@&quot;step1.3 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:3];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;</span><br></pre></td></tr></table></figure>\n<p>block1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；<br>block1.2仍然在当前线程（0x7fbe78419320）中执行；<br>另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程；</p>\n<p>结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系：</p>\n<ul>\n<li>主队列对应着主线程；</li>\n<li>并发队列对应多条线程（非主线程）；</li>\n<li>串行队列对应着一条线程（非主线程）；</li>\n<li>dispatch_sync&amp;dispatch_async：调度对应线程池中的线程；</li>\n</ul>\n<p>接下来继续解读官方API</p>\n<ul>\n<li>系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放）</li>\n<li>参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。</li>\n<li>dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease）</li>\n<li>参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。</li>\n</ul>\n<p>最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">__weak ViewController* weakSelf = self;</span><br><span class=\"line\">dispatch_async(queue, ^&#123;     // block1</span><br><span class=\"line\">    NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    weakSelf.view.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;</span><br><span class=\"line\">2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\">NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">__weak ViewController* weakSelf = self;</span><br><span class=\"line\">dispatch_sync(queue, ^&#123;     // block1</span><br><span class=\"line\">    NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">    [NSThread sleepForTimeInterval:1];</span><br><span class=\"line\">    weakSelf.view.backgroundColor = [UIColor blueColor];</span><br><span class=\"line\">    NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">[NSThread sleepForTimeInterval:2];</span><br><span class=\"line\">NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br><span class=\"line\">2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。<br>此处迷茫++，还得继续研究啊…</p>"},{"title":"iOS常见warning梳理","date":"2018-07-26T09:57:20.000Z","_content":"# iOS常见warning梳理\n\n## 常见warning类型\n|warning类型 | 影响 | 修复方式 | 严重等级 |\n|---|---|---|\n| 方法有定义无实现 | crash | 补齐或删除方法 | P0 |\n| 调用不存在的方法 | crash | 调用正确方法 | P0 |\n| 调用系统DEPRECATED方法/属性 | crash、bug | 分系统进行调用 | P0 |\n| 方法调用中参数类型错误 | crash、bug | 转化对象类型 | P0 |\n| 赋值类型不一致 | crash、bug | 转化对象类型 | P0 |\n| 未调用super方法 | 内存泄漏、bug | 调用super | P0 |\n| 循环引用 | 内存泄漏 | weak strong dance | P0 |\n| 重名代理 | bug | 改名 | P1 |\n| 重名宏 | bug | 改名 | P1 |\n| 子类与父类有重名同类型属性 | bug | 删除其中一个 | P1 |\n| 子类与父类有重名不同类型属性 | bug | 子类添加忽略警告标记，@dynamic动态合成属性 | P1 |\n| 格式化输出类型不一致 | bug | 强制转换类型 | P1 |\n| @required代理未实现 | bug | 补齐代理方法 | P1 |\n| 工程未按推荐方式配置 | warning提示等级、编译选项等存在风险 | 更新到recommend settings | P1 |\n| MRC文件内存泄漏警告 | 性能浪费 | 修复代码或添加ARC标记 | P1 |\n| 临时变量无初始值 | bug | 赋初始值 | P1 |\n| 枚举赋值类型不一致 | bug | 修改代码 | P1 |\n| 非对象属性加了* | bug | 删除* | P1 |\n| 代码中包含非法字符 | 编译器无法识别 | 删除非法字符 | P1 |\n| Nullable/NonNull标记不全 | 产生大量warning | 删除或补全该文件内的标记 | P2 |\n| 未使用的临时变量 | 性能浪费 | 删除无用变量 | P2 |\n| 未使用的static变量 | 性能浪费 | 删除无用变量 | P2 |\n| 代理类未添加代理标记 | 类型检查警告 | 添加代理 | P2 |\n| performSelector | 不推荐使用的方法调用方式 | 直接调用方法 | P2 |\n| 第三方库最低版本与主工程不一致 | 编译警告 | 添加-w linker标记 | P2 |\n| .c文件的64/32位警告 | 编译警告 | 添加-Wno-shorten-64-to-32文件标记 | P2 |\n| import文件名大小写错误 | 无 | 修复文件名 | P3 |\n| 非法注释 | 注释格式不规范，无法快捷查看定义 | 使用系统快捷注释 | P3 |\n| block定义不规范 | 类型检查警告 | 补齐void | P3 |\n| 工程有文件引用但文件不存在 | 文件索引失败 | bug | P3 |\n| asset有索引无文件 | bug | 删除索引 | P3 |\n| search path存在，文件不存在 | 找不到索引 | 删除search path | P3 |\n\n## 修复warning的方式\n1. 根据编译器提示修复。\n2. 对于暂不修复的warning有三种忽略方式。\n2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。\n2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。\n2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。","source":"_posts/iOS常见warning梳理.md","raw":"---\ntitle: iOS常见warning梳理\ndate: 2018-07-26 17:57:20\ncategories: 笔记\ntags:\n    - iOS\n    - warning\n---\n# iOS常见warning梳理\n\n## 常见warning类型\n|warning类型 | 影响 | 修复方式 | 严重等级 |\n|---|---|---|\n| 方法有定义无实现 | crash | 补齐或删除方法 | P0 |\n| 调用不存在的方法 | crash | 调用正确方法 | P0 |\n| 调用系统DEPRECATED方法/属性 | crash、bug | 分系统进行调用 | P0 |\n| 方法调用中参数类型错误 | crash、bug | 转化对象类型 | P0 |\n| 赋值类型不一致 | crash、bug | 转化对象类型 | P0 |\n| 未调用super方法 | 内存泄漏、bug | 调用super | P0 |\n| 循环引用 | 内存泄漏 | weak strong dance | P0 |\n| 重名代理 | bug | 改名 | P1 |\n| 重名宏 | bug | 改名 | P1 |\n| 子类与父类有重名同类型属性 | bug | 删除其中一个 | P1 |\n| 子类与父类有重名不同类型属性 | bug | 子类添加忽略警告标记，@dynamic动态合成属性 | P1 |\n| 格式化输出类型不一致 | bug | 强制转换类型 | P1 |\n| @required代理未实现 | bug | 补齐代理方法 | P1 |\n| 工程未按推荐方式配置 | warning提示等级、编译选项等存在风险 | 更新到recommend settings | P1 |\n| MRC文件内存泄漏警告 | 性能浪费 | 修复代码或添加ARC标记 | P1 |\n| 临时变量无初始值 | bug | 赋初始值 | P1 |\n| 枚举赋值类型不一致 | bug | 修改代码 | P1 |\n| 非对象属性加了* | bug | 删除* | P1 |\n| 代码中包含非法字符 | 编译器无法识别 | 删除非法字符 | P1 |\n| Nullable/NonNull标记不全 | 产生大量warning | 删除或补全该文件内的标记 | P2 |\n| 未使用的临时变量 | 性能浪费 | 删除无用变量 | P2 |\n| 未使用的static变量 | 性能浪费 | 删除无用变量 | P2 |\n| 代理类未添加代理标记 | 类型检查警告 | 添加代理 | P2 |\n| performSelector | 不推荐使用的方法调用方式 | 直接调用方法 | P2 |\n| 第三方库最低版本与主工程不一致 | 编译警告 | 添加-w linker标记 | P2 |\n| .c文件的64/32位警告 | 编译警告 | 添加-Wno-shorten-64-to-32文件标记 | P2 |\n| import文件名大小写错误 | 无 | 修复文件名 | P3 |\n| 非法注释 | 注释格式不规范，无法快捷查看定义 | 使用系统快捷注释 | P3 |\n| block定义不规范 | 类型检查警告 | 补齐void | P3 |\n| 工程有文件引用但文件不存在 | 文件索引失败 | bug | P3 |\n| asset有索引无文件 | bug | 删除索引 | P3 |\n| search path存在，文件不存在 | 找不到索引 | 删除search path | P3 |\n\n## 修复warning的方式\n1. 根据编译器提示修复。\n2. 对于暂不修复的warning有三种忽略方式。\n2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。\n2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。\n2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。","slug":"iOS常见warning梳理","published":1,"updated":"2019-03-11T09:33:27.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0v000bnflw4pkrbgo8","content":"<h1 id=\"iOS常见warning梳理\"><a href=\"#iOS常见warning梳理\" class=\"headerlink\" title=\"iOS常见warning梳理\"></a>iOS常见warning梳理</h1><h2 id=\"常见warning类型\"><a href=\"#常见warning类型\" class=\"headerlink\" title=\"常见warning类型\"></a>常见warning类型</h2><table>\n<thead>\n<tr>\n<th>warning类型</th>\n<th>影响</th>\n<th>修复方式</th>\n<th>严重等级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方法有定义无实现</td>\n<td>crash</td>\n<td>补齐或删除方法</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>调用不存在的方法</td>\n<td>crash</td>\n<td>调用正确方法</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>调用系统DEPRECATED方法/属性</td>\n<td>crash、bug</td>\n<td>分系统进行调用</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>方法调用中参数类型错误</td>\n<td>crash、bug</td>\n<td>转化对象类型</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>赋值类型不一致</td>\n<td>crash、bug</td>\n<td>转化对象类型</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>未调用super方法</td>\n<td>内存泄漏、bug</td>\n<td>调用super</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>循环引用</td>\n<td>内存泄漏</td>\n<td>weak strong dance</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>重名代理</td>\n<td>bug</td>\n<td>改名</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>重名宏</td>\n<td>bug</td>\n<td>改名</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>子类与父类有重名同类型属性</td>\n<td>bug</td>\n<td>删除其中一个</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>子类与父类有重名不同类型属性</td>\n<td>bug</td>\n<td>子类添加忽略警告标记，@dynamic动态合成属性</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>格式化输出类型不一致</td>\n<td>bug</td>\n<td>强制转换类型</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>@required代理未实现</td>\n<td>bug</td>\n<td>补齐代理方法</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>工程未按推荐方式配置</td>\n<td>warning提示等级、编译选项等存在风险</td>\n<td>更新到recommend settings</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>MRC文件内存泄漏警告</td>\n<td>性能浪费</td>\n<td>修复代码或添加ARC标记</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>临时变量无初始值</td>\n<td>bug</td>\n<td>赋初始值</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>枚举赋值类型不一致</td>\n<td>bug</td>\n<td>修改代码</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>非对象属性加了*</td>\n<td>bug</td>\n<td>删除*</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>代码中包含非法字符</td>\n<td>编译器无法识别</td>\n<td>删除非法字符</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>Nullable/NonNull标记不全</td>\n<td>产生大量warning</td>\n<td>删除或补全该文件内的标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>未使用的临时变量</td>\n<td>性能浪费</td>\n<td>删除无用变量</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>未使用的static变量</td>\n<td>性能浪费</td>\n<td>删除无用变量</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>代理类未添加代理标记</td>\n<td>类型检查警告</td>\n<td>添加代理</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>performSelector</td>\n<td>不推荐使用的方法调用方式</td>\n<td>直接调用方法</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>第三方库最低版本与主工程不一致</td>\n<td>编译警告</td>\n<td>添加-w linker标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>.c文件的64/32位警告</td>\n<td>编译警告</td>\n<td>添加-Wno-shorten-64-to-32文件标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>import文件名大小写错误</td>\n<td>无</td>\n<td>修复文件名</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>非法注释</td>\n<td>注释格式不规范，无法快捷查看定义</td>\n<td>使用系统快捷注释</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>block定义不规范</td>\n<td>类型检查警告</td>\n<td>补齐void</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>工程有文件引用但文件不存在</td>\n<td>文件索引失败</td>\n<td>bug</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>asset有索引无文件</td>\n<td>bug</td>\n<td>删除索引</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>search path存在，文件不存在</td>\n<td>找不到索引</td>\n<td>删除search path</td>\n<td>P3</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修复warning的方式\"><a href=\"#修复warning的方式\" class=\"headerlink\" title=\"修复warning的方式\"></a>修复warning的方式</h2><ol>\n<li>根据编译器提示修复。</li>\n<li>对于暂不修复的warning有三种忽略方式。<br>2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。<br>2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。<br>2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS常见warning梳理\"><a href=\"#iOS常见warning梳理\" class=\"headerlink\" title=\"iOS常见warning梳理\"></a>iOS常见warning梳理</h1><h2 id=\"常见warning类型\"><a href=\"#常见warning类型\" class=\"headerlink\" title=\"常见warning类型\"></a>常见warning类型</h2><table>\n<thead>\n<tr>\n<th>warning类型</th>\n<th>影响</th>\n<th>修复方式</th>\n<th>严重等级</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>方法有定义无实现</td>\n<td>crash</td>\n<td>补齐或删除方法</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>调用不存在的方法</td>\n<td>crash</td>\n<td>调用正确方法</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>调用系统DEPRECATED方法/属性</td>\n<td>crash、bug</td>\n<td>分系统进行调用</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>方法调用中参数类型错误</td>\n<td>crash、bug</td>\n<td>转化对象类型</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>赋值类型不一致</td>\n<td>crash、bug</td>\n<td>转化对象类型</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>未调用super方法</td>\n<td>内存泄漏、bug</td>\n<td>调用super</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>循环引用</td>\n<td>内存泄漏</td>\n<td>weak strong dance</td>\n<td>P0</td>\n</tr>\n<tr>\n<td>重名代理</td>\n<td>bug</td>\n<td>改名</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>重名宏</td>\n<td>bug</td>\n<td>改名</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>子类与父类有重名同类型属性</td>\n<td>bug</td>\n<td>删除其中一个</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>子类与父类有重名不同类型属性</td>\n<td>bug</td>\n<td>子类添加忽略警告标记，@dynamic动态合成属性</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>格式化输出类型不一致</td>\n<td>bug</td>\n<td>强制转换类型</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>@required代理未实现</td>\n<td>bug</td>\n<td>补齐代理方法</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>工程未按推荐方式配置</td>\n<td>warning提示等级、编译选项等存在风险</td>\n<td>更新到recommend settings</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>MRC文件内存泄漏警告</td>\n<td>性能浪费</td>\n<td>修复代码或添加ARC标记</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>临时变量无初始值</td>\n<td>bug</td>\n<td>赋初始值</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>枚举赋值类型不一致</td>\n<td>bug</td>\n<td>修改代码</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>非对象属性加了*</td>\n<td>bug</td>\n<td>删除*</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>代码中包含非法字符</td>\n<td>编译器无法识别</td>\n<td>删除非法字符</td>\n<td>P1</td>\n</tr>\n<tr>\n<td>Nullable/NonNull标记不全</td>\n<td>产生大量warning</td>\n<td>删除或补全该文件内的标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>未使用的临时变量</td>\n<td>性能浪费</td>\n<td>删除无用变量</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>未使用的static变量</td>\n<td>性能浪费</td>\n<td>删除无用变量</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>代理类未添加代理标记</td>\n<td>类型检查警告</td>\n<td>添加代理</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>performSelector</td>\n<td>不推荐使用的方法调用方式</td>\n<td>直接调用方法</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>第三方库最低版本与主工程不一致</td>\n<td>编译警告</td>\n<td>添加-w linker标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>.c文件的64/32位警告</td>\n<td>编译警告</td>\n<td>添加-Wno-shorten-64-to-32文件标记</td>\n<td>P2</td>\n</tr>\n<tr>\n<td>import文件名大小写错误</td>\n<td>无</td>\n<td>修复文件名</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>非法注释</td>\n<td>注释格式不规范，无法快捷查看定义</td>\n<td>使用系统快捷注释</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>block定义不规范</td>\n<td>类型检查警告</td>\n<td>补齐void</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>工程有文件引用但文件不存在</td>\n<td>文件索引失败</td>\n<td>bug</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>asset有索引无文件</td>\n<td>bug</td>\n<td>删除索引</td>\n<td>P3</td>\n</tr>\n<tr>\n<td>search path存在，文件不存在</td>\n<td>找不到索引</td>\n<td>删除search path</td>\n<td>P3</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"修复warning的方式\"><a href=\"#修复warning的方式\" class=\"headerlink\" title=\"修复warning的方式\"></a>修复warning的方式</h2><ol>\n<li>根据编译器提示修复。</li>\n<li>对于暂不修复的warning有三种忽略方式。<br>2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。<br>2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。<br>2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。</li>\n</ol>\n"},{"title":"开发笔记：flutter中的好多坑","date":"2019-04-10T06:59:08.000Z","_content":"\n# Flutter 踩坑记录\n\n## 问题索引\n\n[TabBar及PageView状态保存](#q001)\n[ScrollView滚动进度保存](#q002)\n[ListView下拉刷新后数据已返回，UI未更新](#q003)\n[中文汉字变形](#q004)\n[热重载hot reload未生效](#q005)\n[转场动画在list内黑屏不生效](#q006)\n[Android plugin内不能使用AAR包](#q007)\n[Android plugin内AAR包内的so库加载不出来](#q008)\n[Json注解制动生成的解析文件解析数据失败](#q009)\n[加载更多后头像加载慢或不加载](#q010)\n[dio安卓上网络请求失败](#q011)\n[NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效](#q012)\n[枚举值需要取index，否则打印类名](#q013)\n[flutter动画不执行](#q014)\n[在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失](#q015)\n[dispose后不允许setState](#q016)\n[滑动冲突](#q017)\n[Row中的Text控件出现overflow警告](#q018)\n[webview无法连接网络](#q019)\n\n## q001\n\n**TabBar及PageView状态保存**\n\n*Flutter 1.2.1 statble*\n\n子页面离开屏幕时，state会被销毁引发的bug\nhttps://juejin.im/post/5b73c3b3f265da27d701473a\n\n## q002\n\n**ScrollView滚动进度保存**\n\n*Flutter 1.2.1 statble*\n\n进入其他页面返回后保存scrollView的offset\nhttps://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages\n\n## q003\n\n**ListView下拉刷新后数据已返回，UI未更新**\n\n*Flutter 1.2.1 statble*\n\nListView需要有Key，否则被复用引发的UI不立即更新bug\nhttps://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert\n\n## q004\n\n**中文汉字变形**\n\n*Flutter 1.2.1 statble*\n\n该问题发生在MaterialApp中，多数情况与fontfamily有关。\nhttps://github.com/flutter/flutter/issues/22966\nhttps://github.com/flutter/flutter/issues/26752\nhttps://github.com/flutter/flutter/issues/25726\n\n## q005\n\n**热重载hot reload未生效**\n\n*Flutter 1.2.1 statble*\n\n目前已知几种情况下，hot reload无法生效\n\n- 需要build_runner做代码生成部分的代码\n- 使用了新添加的资源\n\n发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。\n\n## q006\n**转场动画在list内黑屏不生效**\nHero转场动画在list内黑屏不生效\n原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素\n解决方案：tag随机生成，并通过参数传入下个页面\n\n## q007\n**Android plugin内不能使用AAR包**\nAndroid插件开发中，AAR包引用不到\n原因：flutter暂不支持AAR的引用，仅支持gradle方式引用\n解决方案：\n1. 放弃插件方案，直接在application工程下开发flutter与native的交互方案\n2. 百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。\nWIKI：http://wiki.baidu.com/pages/viewpage.action?pageId=465488650\nmaven库地址：http://maven.baidu-int.com/nexus/content/groups/public\n链接：http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/\n使用方法：compile 'com.baidu.bdpass:HWOpenSDK:3.3.3@aar'\n接口人：zhanghuaming@baidu.com\n\n## q008\n**Android plugin内AAR包内的so库加载不出来**\nAndroid 插件通过gradle方式引用AAR包，但是其中的so库load不出来\n原因：flutter对AAR包的引用支持不好\n解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代\n\n## q009\n**Json注解制动生成的解析文件解析数据失败**\n原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串\n解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null\n\n## q010\n**Json注解制动生成的解析文件解析数据失败**\n原因：View复用导致没有刷新\n解决方案：需要给头像控件增加一个单独的Key\n\n##q011\n原因：没有网络请求的权限\n解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限\n\n##q012\n原因：未知\n解决方案：改用NotificationListener\n\n## q014\n**flutter动画不执行**\n原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾\n方案：动画controller写成全局变量，执行动画前先调reset方法。\n\n## q015\n**在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失**\n原因不明。\n\n``` dart\nSliverAppBar(\n  flexibleSpace: FlexibleSpaceBar(\n    background: PageView.builder(\n      ... ...\n    )\n  )\n)\n\n```\n\nPageView若更换成其他非滑动型控件，则无此问题。\n\n## q016\n原因：内存泄漏\n方案：dispose时将callBack等异步操作取消或置null\n\n## q017\n**滑动冲突**\n原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件\n解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如\n```\nTabBarView(\n   children: children,\n   physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),\n),\n```\n\n## q018\n方案：将Text嵌套在Expanded中\n\n## q019\nInfo.plist中加入\n```\n<key>io.flutter.embedded_views_preview</key>\n<true/>\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n","source":"_posts/开发笔记：flutter中的好多坑.md","raw":"---\ntitle: 开发笔记：flutter中的好多坑\ndate: 2019-04-10 14:59:08\ncategories: 笔记\ntags:\n    - flutter\n    - 笔记\n---\n\n# Flutter 踩坑记录\n\n## 问题索引\n\n[TabBar及PageView状态保存](#q001)\n[ScrollView滚动进度保存](#q002)\n[ListView下拉刷新后数据已返回，UI未更新](#q003)\n[中文汉字变形](#q004)\n[热重载hot reload未生效](#q005)\n[转场动画在list内黑屏不生效](#q006)\n[Android plugin内不能使用AAR包](#q007)\n[Android plugin内AAR包内的so库加载不出来](#q008)\n[Json注解制动生成的解析文件解析数据失败](#q009)\n[加载更多后头像加载慢或不加载](#q010)\n[dio安卓上网络请求失败](#q011)\n[NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效](#q012)\n[枚举值需要取index，否则打印类名](#q013)\n[flutter动画不执行](#q014)\n[在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失](#q015)\n[dispose后不允许setState](#q016)\n[滑动冲突](#q017)\n[Row中的Text控件出现overflow警告](#q018)\n[webview无法连接网络](#q019)\n\n## q001\n\n**TabBar及PageView状态保存**\n\n*Flutter 1.2.1 statble*\n\n子页面离开屏幕时，state会被销毁引发的bug\nhttps://juejin.im/post/5b73c3b3f265da27d701473a\n\n## q002\n\n**ScrollView滚动进度保存**\n\n*Flutter 1.2.1 statble*\n\n进入其他页面返回后保存scrollView的offset\nhttps://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages\n\n## q003\n\n**ListView下拉刷新后数据已返回，UI未更新**\n\n*Flutter 1.2.1 statble*\n\nListView需要有Key，否则被复用引发的UI不立即更新bug\nhttps://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert\n\n## q004\n\n**中文汉字变形**\n\n*Flutter 1.2.1 statble*\n\n该问题发生在MaterialApp中，多数情况与fontfamily有关。\nhttps://github.com/flutter/flutter/issues/22966\nhttps://github.com/flutter/flutter/issues/26752\nhttps://github.com/flutter/flutter/issues/25726\n\n## q005\n\n**热重载hot reload未生效**\n\n*Flutter 1.2.1 statble*\n\n目前已知几种情况下，hot reload无法生效\n\n- 需要build_runner做代码生成部分的代码\n- 使用了新添加的资源\n\n发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。\n\n## q006\n**转场动画在list内黑屏不生效**\nHero转场动画在list内黑屏不生效\n原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素\n解决方案：tag随机生成，并通过参数传入下个页面\n\n## q007\n**Android plugin内不能使用AAR包**\nAndroid插件开发中，AAR包引用不到\n原因：flutter暂不支持AAR的引用，仅支持gradle方式引用\n解决方案：\n1. 放弃插件方案，直接在application工程下开发flutter与native的交互方案\n2. 百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。\nWIKI：http://wiki.baidu.com/pages/viewpage.action?pageId=465488650\nmaven库地址：http://maven.baidu-int.com/nexus/content/groups/public\n链接：http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/\n使用方法：compile 'com.baidu.bdpass:HWOpenSDK:3.3.3@aar'\n接口人：zhanghuaming@baidu.com\n\n## q008\n**Android plugin内AAR包内的so库加载不出来**\nAndroid 插件通过gradle方式引用AAR包，但是其中的so库load不出来\n原因：flutter对AAR包的引用支持不好\n解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代\n\n## q009\n**Json注解制动生成的解析文件解析数据失败**\n原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串\n解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null\n\n## q010\n**Json注解制动生成的解析文件解析数据失败**\n原因：View复用导致没有刷新\n解决方案：需要给头像控件增加一个单独的Key\n\n##q011\n原因：没有网络请求的权限\n解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限\n\n##q012\n原因：未知\n解决方案：改用NotificationListener\n\n## q014\n**flutter动画不执行**\n原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾\n方案：动画controller写成全局变量，执行动画前先调reset方法。\n\n## q015\n**在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失**\n原因不明。\n\n``` dart\nSliverAppBar(\n  flexibleSpace: FlexibleSpaceBar(\n    background: PageView.builder(\n      ... ...\n    )\n  )\n)\n\n```\n\nPageView若更换成其他非滑动型控件，则无此问题。\n\n## q016\n原因：内存泄漏\n方案：dispose时将callBack等异步操作取消或置null\n\n## q017\n**滑动冲突**\n原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件\n解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如\n```\nTabBarView(\n   children: children,\n   physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),\n),\n```\n\n## q018\n方案：将Text嵌套在Expanded中\n\n## q019\nInfo.plist中加入\n```\n<key>io.flutter.embedded_views_preview</key>\n<true/>\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSAllowsArbitraryLoads</key>\n    <true/>\n</dict>\n```\n","slug":"开发笔记：flutter中的好多坑","published":1,"updated":"2019-04-10T06:59:52.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0x000fnflwfxa6tx6a","content":"<h1 id=\"Flutter-踩坑记录\"><a href=\"#Flutter-踩坑记录\" class=\"headerlink\" title=\"Flutter 踩坑记录\"></a>Flutter 踩坑记录</h1><h2 id=\"问题索引\"><a href=\"#问题索引\" class=\"headerlink\" title=\"问题索引\"></a>问题索引</h2><p><a href=\"#q001\">TabBar及PageView状态保存</a><br><a href=\"#q002\">ScrollView滚动进度保存</a><br><a href=\"#q003\">ListView下拉刷新后数据已返回，UI未更新</a><br><a href=\"#q004\">中文汉字变形</a><br><a href=\"#q005\">热重载hot reload未生效</a><br><a href=\"#q006\">转场动画在list内黑屏不生效</a><br><a href=\"#q007\">Android plugin内不能使用AAR包</a><br><a href=\"#q008\">Android plugin内AAR包内的so库加载不出来</a><br><a href=\"#q009\">Json注解制动生成的解析文件解析数据失败</a><br><a href=\"#q010\">加载更多后头像加载慢或不加载</a><br><a href=\"#q011\">dio安卓上网络请求失败</a><br><a href=\"#q012\">NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效</a><br><a href=\"#q013\">枚举值需要取index，否则打印类名</a><br><a href=\"#q014\">flutter动画不执行</a><br><a href=\"#q015\">在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失</a><br><a href=\"#q016\">dispose后不允许setState</a><br><a href=\"#q017\">滑动冲突</a><br><a href=\"#q018\">Row中的Text控件出现overflow警告</a><br><a href=\"#q019\">webview无法连接网络</a></p>\n<h2 id=\"q001\"><a href=\"#q001\" class=\"headerlink\" title=\"q001\"></a>q001</h2><p><strong>TabBar及PageView状态保存</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>子页面离开屏幕时，state会被销毁引发的bug<br><a href=\"https://juejin.im/post/5b73c3b3f265da27d701473a\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5b73c3b3f265da27d701473a</a></p>\n<h2 id=\"q002\"><a href=\"#q002\" class=\"headerlink\" title=\"q002\"></a>q002</h2><p><strong>ScrollView滚动进度保存</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>进入其他页面返回后保存scrollView的offset<br><a href=\"https://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages</a></p>\n<h2 id=\"q003\"><a href=\"#q003\" class=\"headerlink\" title=\"q003\"></a>q003</h2><p><strong>ListView下拉刷新后数据已返回，UI未更新</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>ListView需要有Key，否则被复用引发的UI不立即更新bug<br><a href=\"https://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert</a></p>\n<h2 id=\"q004\"><a href=\"#q004\" class=\"headerlink\" title=\"q004\"></a>q004</h2><p><strong>中文汉字变形</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>该问题发生在MaterialApp中，多数情况与fontfamily有关。<br><a href=\"https://github.com/flutter/flutter/issues/22966\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/22966</a><br><a href=\"https://github.com/flutter/flutter/issues/26752\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/26752</a><br><a href=\"https://github.com/flutter/flutter/issues/25726\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/25726</a></p>\n<h2 id=\"q005\"><a href=\"#q005\" class=\"headerlink\" title=\"q005\"></a>q005</h2><p><strong>热重载hot reload未生效</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>目前已知几种情况下，hot reload无法生效</p>\n<ul>\n<li>需要build_runner做代码生成部分的代码</li>\n<li>使用了新添加的资源</li>\n</ul>\n<p>发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。</p>\n<h2 id=\"q006\"><a href=\"#q006\" class=\"headerlink\" title=\"q006\"></a>q006</h2><p><strong>转场动画在list内黑屏不生效</strong><br>Hero转场动画在list内黑屏不生效<br>原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素<br>解决方案：tag随机生成，并通过参数传入下个页面</p>\n<h2 id=\"q007\"><a href=\"#q007\" class=\"headerlink\" title=\"q007\"></a>q007</h2><p><strong>Android plugin内不能使用AAR包</strong><br>Android插件开发中，AAR包引用不到<br>原因：flutter暂不支持AAR的引用，仅支持gradle方式引用<br>解决方案：</p>\n<ol>\n<li>放弃插件方案，直接在application工程下开发flutter与native的交互方案</li>\n<li>百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。<br>WIKI：<a href=\"http://wiki.baidu.com/pages/viewpage.action?pageId=465488650\" target=\"_blank\" rel=\"noopener\">http://wiki.baidu.com/pages/viewpage.action?pageId=465488650</a><br>maven库地址：<a href=\"http://maven.baidu-int.com/nexus/content/groups/public\" target=\"_blank\" rel=\"noopener\">http://maven.baidu-int.com/nexus/content/groups/public</a><br>链接：<a href=\"http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/\" target=\"_blank\" rel=\"noopener\">http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/</a><br>使用方法：compile ‘com.baidu.bdpass:HWOpenSDK:3.3.3@aar’<br>接口人：<a href=\"mailto:zhanghuaming@baidu.com\" target=\"_blank\" rel=\"noopener\">zhanghuaming@baidu.com</a></li>\n</ol>\n<h2 id=\"q008\"><a href=\"#q008\" class=\"headerlink\" title=\"q008\"></a>q008</h2><p><strong>Android plugin内AAR包内的so库加载不出来</strong><br>Android 插件通过gradle方式引用AAR包，但是其中的so库load不出来<br>原因：flutter对AAR包的引用支持不好<br>解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代</p>\n<h2 id=\"q009\"><a href=\"#q009\" class=\"headerlink\" title=\"q009\"></a>q009</h2><p><strong>Json注解制动生成的解析文件解析数据失败</strong><br>原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串<br>解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null</p>\n<h2 id=\"q010\"><a href=\"#q010\" class=\"headerlink\" title=\"q010\"></a>q010</h2><p><strong>Json注解制动生成的解析文件解析数据失败</strong><br>原因：View复用导致没有刷新<br>解决方案：需要给头像控件增加一个单独的Key</p>\n<p>##q011<br>原因：没有网络请求的权限<br>解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限</p>\n<p>##q012<br>原因：未知<br>解决方案：改用NotificationListener</p>\n<h2 id=\"q014\"><a href=\"#q014\" class=\"headerlink\" title=\"q014\"></a>q014</h2><p><strong>flutter动画不执行</strong><br>原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾<br>方案：动画controller写成全局变量，执行动画前先调reset方法。</p>\n<h2 id=\"q015\"><a href=\"#q015\" class=\"headerlink\" title=\"q015\"></a>q015</h2><p><strong>在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失</strong><br>原因不明。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SliverAppBar(</span><br><span class=\"line\">  flexibleSpace: FlexibleSpaceBar(</span><br><span class=\"line\">    background: PageView.builder(</span><br><span class=\"line\">      ... ...</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>PageView若更换成其他非滑动型控件，则无此问题。</p>\n<h2 id=\"q016\"><a href=\"#q016\" class=\"headerlink\" title=\"q016\"></a>q016</h2><p>原因：内存泄漏<br>方案：dispose时将callBack等异步操作取消或置null</p>\n<h2 id=\"q017\"><a href=\"#q017\" class=\"headerlink\" title=\"q017\"></a>q017</h2><p><strong>滑动冲突</strong><br>原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件<br>解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TabBarView(</span><br><span class=\"line\">   children: children,</span><br><span class=\"line\">   physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),</span><br><span class=\"line\">),</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"q018\"><a href=\"#q018\" class=\"headerlink\" title=\"q018\"></a>q018</h2><p>方案：将Text嵌套在Expanded中</p>\n<h2 id=\"q019\"><a href=\"#q019\" class=\"headerlink\" title=\"q019\"></a>q019</h2><p>Info.plist中加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt;</span><br><span class=\"line\">&lt;true/&gt;</span><br><span class=\"line\">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flutter-踩坑记录\"><a href=\"#Flutter-踩坑记录\" class=\"headerlink\" title=\"Flutter 踩坑记录\"></a>Flutter 踩坑记录</h1><h2 id=\"问题索引\"><a href=\"#问题索引\" class=\"headerlink\" title=\"问题索引\"></a>问题索引</h2><p><a href=\"#q001\">TabBar及PageView状态保存</a><br><a href=\"#q002\">ScrollView滚动进度保存</a><br><a href=\"#q003\">ListView下拉刷新后数据已返回，UI未更新</a><br><a href=\"#q004\">中文汉字变形</a><br><a href=\"#q005\">热重载hot reload未生效</a><br><a href=\"#q006\">转场动画在list内黑屏不生效</a><br><a href=\"#q007\">Android plugin内不能使用AAR包</a><br><a href=\"#q008\">Android plugin内AAR包内的so库加载不出来</a><br><a href=\"#q009\">Json注解制动生成的解析文件解析数据失败</a><br><a href=\"#q010\">加载更多后头像加载慢或不加载</a><br><a href=\"#q011\">dio安卓上网络请求失败</a><br><a href=\"#q012\">NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效</a><br><a href=\"#q013\">枚举值需要取index，否则打印类名</a><br><a href=\"#q014\">flutter动画不执行</a><br><a href=\"#q015\">在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失</a><br><a href=\"#q016\">dispose后不允许setState</a><br><a href=\"#q017\">滑动冲突</a><br><a href=\"#q018\">Row中的Text控件出现overflow警告</a><br><a href=\"#q019\">webview无法连接网络</a></p>\n<h2 id=\"q001\"><a href=\"#q001\" class=\"headerlink\" title=\"q001\"></a>q001</h2><p><strong>TabBar及PageView状态保存</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>子页面离开屏幕时，state会被销毁引发的bug<br><a href=\"https://juejin.im/post/5b73c3b3f265da27d701473a\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5b73c3b3f265da27d701473a</a></p>\n<h2 id=\"q002\"><a href=\"#q002\" class=\"headerlink\" title=\"q002\"></a>q002</h2><p><strong>ScrollView滚动进度保存</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>进入其他页面返回后保存scrollView的offset<br><a href=\"https://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages</a></p>\n<h2 id=\"q003\"><a href=\"#q003\" class=\"headerlink\" title=\"q003\"></a>q003</h2><p><strong>ListView下拉刷新后数据已返回，UI未更新</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>ListView需要有Key，否则被复用引发的UI不立即更新bug<br><a href=\"https://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert</a></p>\n<h2 id=\"q004\"><a href=\"#q004\" class=\"headerlink\" title=\"q004\"></a>q004</h2><p><strong>中文汉字变形</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>该问题发生在MaterialApp中，多数情况与fontfamily有关。<br><a href=\"https://github.com/flutter/flutter/issues/22966\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/22966</a><br><a href=\"https://github.com/flutter/flutter/issues/26752\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/26752</a><br><a href=\"https://github.com/flutter/flutter/issues/25726\" target=\"_blank\" rel=\"noopener\">https://github.com/flutter/flutter/issues/25726</a></p>\n<h2 id=\"q005\"><a href=\"#q005\" class=\"headerlink\" title=\"q005\"></a>q005</h2><p><strong>热重载hot reload未生效</strong></p>\n<p><em>Flutter 1.2.1 statble</em></p>\n<p>目前已知几种情况下，hot reload无法生效</p>\n<ul>\n<li>需要build_runner做代码生成部分的代码</li>\n<li>使用了新添加的资源</li>\n</ul>\n<p>发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。</p>\n<h2 id=\"q006\"><a href=\"#q006\" class=\"headerlink\" title=\"q006\"></a>q006</h2><p><strong>转场动画在list内黑屏不生效</strong><br>Hero转场动画在list内黑屏不生效<br>原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素<br>解决方案：tag随机生成，并通过参数传入下个页面</p>\n<h2 id=\"q007\"><a href=\"#q007\" class=\"headerlink\" title=\"q007\"></a>q007</h2><p><strong>Android plugin内不能使用AAR包</strong><br>Android插件开发中，AAR包引用不到<br>原因：flutter暂不支持AAR的引用，仅支持gradle方式引用<br>解决方案：</p>\n<ol>\n<li>放弃插件方案，直接在application工程下开发flutter与native的交互方案</li>\n<li>百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。<br>WIKI：<a href=\"http://wiki.baidu.com/pages/viewpage.action?pageId=465488650\" target=\"_blank\" rel=\"noopener\">http://wiki.baidu.com/pages/viewpage.action?pageId=465488650</a><br>maven库地址：<a href=\"http://maven.baidu-int.com/nexus/content/groups/public\" target=\"_blank\" rel=\"noopener\">http://maven.baidu-int.com/nexus/content/groups/public</a><br>链接：<a href=\"http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/\" target=\"_blank\" rel=\"noopener\">http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/</a><br>使用方法：compile ‘com.baidu.bdpass:HWOpenSDK:3.3.3@aar’<br>接口人：<a href=\"mailto:zhanghuaming@baidu.com\" target=\"_blank\" rel=\"noopener\">zhanghuaming@baidu.com</a></li>\n</ol>\n<h2 id=\"q008\"><a href=\"#q008\" class=\"headerlink\" title=\"q008\"></a>q008</h2><p><strong>Android plugin内AAR包内的so库加载不出来</strong><br>Android 插件通过gradle方式引用AAR包，但是其中的so库load不出来<br>原因：flutter对AAR包的引用支持不好<br>解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代</p>\n<h2 id=\"q009\"><a href=\"#q009\" class=\"headerlink\" title=\"q009\"></a>q009</h2><p><strong>Json注解制动生成的解析文件解析数据失败</strong><br>原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串<br>解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null</p>\n<h2 id=\"q010\"><a href=\"#q010\" class=\"headerlink\" title=\"q010\"></a>q010</h2><p><strong>Json注解制动生成的解析文件解析数据失败</strong><br>原因：View复用导致没有刷新<br>解决方案：需要给头像控件增加一个单独的Key</p>\n<p>##q011<br>原因：没有网络请求的权限<br>解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限</p>\n<p>##q012<br>原因：未知<br>解决方案：改用NotificationListener</p>\n<h2 id=\"q014\"><a href=\"#q014\" class=\"headerlink\" title=\"q014\"></a>q014</h2><p><strong>flutter动画不执行</strong><br>原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾<br>方案：动画controller写成全局变量，执行动画前先调reset方法。</p>\n<h2 id=\"q015\"><a href=\"#q015\" class=\"headerlink\" title=\"q015\"></a>q015</h2><p><strong>在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失</strong><br>原因不明。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SliverAppBar(</span><br><span class=\"line\">  flexibleSpace: FlexibleSpaceBar(</span><br><span class=\"line\">    background: PageView.builder(</span><br><span class=\"line\">      ... ...</span><br><span class=\"line\">    )</span><br><span class=\"line\">  )</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>PageView若更换成其他非滑动型控件，则无此问题。</p>\n<h2 id=\"q016\"><a href=\"#q016\" class=\"headerlink\" title=\"q016\"></a>q016</h2><p>原因：内存泄漏<br>方案：dispose时将callBack等异步操作取消或置null</p>\n<h2 id=\"q017\"><a href=\"#q017\" class=\"headerlink\" title=\"q017\"></a>q017</h2><p><strong>滑动冲突</strong><br>原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件<br>解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TabBarView(</span><br><span class=\"line\">   children: children,</span><br><span class=\"line\">   physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),</span><br><span class=\"line\">),</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"q018\"><a href=\"#q018\" class=\"headerlink\" title=\"q018\"></a>q018</h2><p>方案：将Text嵌套在Expanded中</p>\n<h2 id=\"q019\"><a href=\"#q019\" class=\"headerlink\" title=\"q019\"></a>q019</h2><p>Info.plist中加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt;</span><br><span class=\"line\">&lt;true/&gt;</span><br><span class=\"line\">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class=\"line\">    &lt;true/&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"iOS基础：类、对象和方法.md","date":"2016-08-14T08:15:39.000Z","_content":"\n本文是在阅读`Objective-C程序设计  第6版`一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。\n\n# 什么是对象\n我们知道，OC是在C的基础上设计的`面向对象`的程序设计语言，而C则是`过程性语言`。\n以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。\n而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。\n\n我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。\n<!-- more -->\n\n# 类、方法\n**Fraction类**\n```\n#import <Foundation/Foundation.h>\n\n@interface Fraction : NSObject\n\n- (void)print;\n- (void)setNumerator: (int)n;\n- (void)setDenominator: (int)d;\n\n@end\n```\n\n```\n#import \"Fraction.h\"\n\n@implementation Fraction {\n    int numerator;\n    int denominator;\n}\n\n- (void)print {\n    NSLog(@\"%i / %i\", numerator, denominator);\n}\n\n- (void)setNumerator:(int)n {\n    numerator = n;\n}\n\n- (void)setDenominator:(int)d {\n    denominator = d;\n}\n@end\n```\n\n**main函数**\n```\n#import <Foundation/Foundation.h>\n#import \"Fraction.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        // insert code here...\n        Fraction *fraction;\n        \n        fraction = [[Fraction alloc] init];\n        [fraction setNumerator:1];\n        [fraction setDenominator:3];\n        \n        NSLog(@\"The value of fracton is: \");\n        [fraction print];\n    }\n    return 0;\n}\n```\n\n先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。\n另外@符号在\"\"前，表示这是常量NSString对象。\n\n然后来看main函数。\n第一行中，我们就看到了`@autoreleasepool`，这是什么呢？\n## autoreleasepool\n嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。\n什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。\n\n[对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。](http://blog.sina.com.cn/s/blog_8c87ba3b0100tgfs.html)\n\n以下对于autoreleasepool的分析参考了[@雷纯锋的技术博客](http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/)\n文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。\n\n首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。\n### 场景1\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.1\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    string_weak_ = string;\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    \n    NSLog(@\"string_weak_@viewWillAppear: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    \n    NSLog(@\"string_weak_@viewDidAppear: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__strong NSString *string_strong_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.2\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    string_strong_ = string;\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_strong_@viewDidLoad: %@ with retainCount: %@\", string_strong_, [string_strong_ valueForKey:@\"retainCount\"]);\n}\n\n// ...省略\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.3\n    Fraction *fraction = [[Fraction alloc] init];\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    fraction_weak_ = fraction;\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__strong Fraction *fraction_strong_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.4\n    Fraction *fraction = [[Fraction alloc] init];\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    fraction_strong_ = fraction;\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_strong_@viewDidLoad: %@ with retainCount: %@\", fraction_strong_, [fraction_strong_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景1.1(__weak NSString *) 结果 \n2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I'm here! with retainCount: 3\n2016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景1.2(__strong NSString *) 结果 \n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I'm here! with retainCount: 3\n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I'm here! with retainCount: 3\n2016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I'm here! with retainCount: 2\n2016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I'm here! with retainCount: 1\n\n// 场景1.3(__weak Fraction *) 结果\n2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 1\n2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 1\n2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 3\n2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景1.4(__strong Fraction *) 结果\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 2\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 2\n2016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n2016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n```\n> 我们使用了一个全局的 __weak 变量 string_weak_ 来指向它。因为 __weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 \n\n最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。\n场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。\n\n### 场景2\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 2.1\n    @autoreleasepool {\n        NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        string_weak_ = string;\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 2.2\n    @autoreleasepool {\n        Fraction *fraction = [[Fraction alloc] init];\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        fraction_weak_ = fraction;\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景2.1(__weak NSString *) 结果\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)\n2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景2.2(__weak Fraction *) 结果\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 1\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 1\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 3\n2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)\n2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n```\n\n### 场景3\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 3.1\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    @autoreleasepool {\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        string_weak_ = string;\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 3.2\n    Fraction *fraction = [[Fraction alloc] init];\n    @autoreleasepool {\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        fraction_weak_ = fraction;\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景3.1(__weak NSString *) 结果\n2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I'm here! with retainCount: 3\n2016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景3.2(__weak Fraction *) 结果\n2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 3\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 3\n2016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n```\n\n再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];\n向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：\n```\n+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n- (void)dealloc OBJC_SWIFT_UNAVAILABLE(\"use 'deinit' to define a de-initializer\");\n```\n\n随后调用了init方法，同样，这来自于NSObject的实例方法。\n\nfraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。\n\n而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。\nOC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，`[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));`我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。\n\n提前阅读一些runtime的知识\n[iOS~runtime理解](http://www.jianshu.com/p/927c8384855a)\n[iOS中的runtime应用](http://www.jianshu.com/p/364eab29f4f5)\n","source":"_posts/iOS基础：类、对象和方法.md","raw":"---\ntitle: iOS基础：类、对象和方法.md\ndate: 2016-08-14 16:15:39\ncategories: iOS基础知识\ntags:\n    - iOS\n    - 程序设计基础\n    - 类\n    - 对象\n    - 方法\n    - autoreleasepool\n---\n\n本文是在阅读`Objective-C程序设计  第6版`一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。\n\n# 什么是对象\n我们知道，OC是在C的基础上设计的`面向对象`的程序设计语言，而C则是`过程性语言`。\n以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。\n而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。\n\n我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。\n<!-- more -->\n\n# 类、方法\n**Fraction类**\n```\n#import <Foundation/Foundation.h>\n\n@interface Fraction : NSObject\n\n- (void)print;\n- (void)setNumerator: (int)n;\n- (void)setDenominator: (int)d;\n\n@end\n```\n\n```\n#import \"Fraction.h\"\n\n@implementation Fraction {\n    int numerator;\n    int denominator;\n}\n\n- (void)print {\n    NSLog(@\"%i / %i\", numerator, denominator);\n}\n\n- (void)setNumerator:(int)n {\n    numerator = n;\n}\n\n- (void)setDenominator:(int)d {\n    denominator = d;\n}\n@end\n```\n\n**main函数**\n```\n#import <Foundation/Foundation.h>\n#import \"Fraction.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        // insert code here...\n        Fraction *fraction;\n        \n        fraction = [[Fraction alloc] init];\n        [fraction setNumerator:1];\n        [fraction setDenominator:3];\n        \n        NSLog(@\"The value of fracton is: \");\n        [fraction print];\n    }\n    return 0;\n}\n```\n\n先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。\n另外@符号在\"\"前，表示这是常量NSString对象。\n\n然后来看main函数。\n第一行中，我们就看到了`@autoreleasepool`，这是什么呢？\n## autoreleasepool\n嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。\n什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。\n\n[对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。](http://blog.sina.com.cn/s/blog_8c87ba3b0100tgfs.html)\n\n以下对于autoreleasepool的分析参考了[@雷纯锋的技术博客](http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/)\n文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。\n\n首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。\n### 场景1\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.1\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    string_weak_ = string;\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n\n- (void)viewWillAppear:(BOOL)animated {\n    [super viewWillAppear:animated];\n    \n    NSLog(@\"string_weak_@viewWillAppear: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n\n- (void)viewDidAppear:(BOOL)animated {\n    [super viewDidAppear:animated];\n    \n    NSLog(@\"string_weak_@viewDidAppear: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__strong NSString *string_strong_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.2\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    string_strong_ = string;\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_strong_@viewDidLoad: %@ with retainCount: %@\", string_strong_, [string_strong_ valueForKey:@\"retainCount\"]);\n}\n\n// ...省略\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.3\n    Fraction *fraction = [[Fraction alloc] init];\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    fraction_weak_ = fraction;\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__strong Fraction *fraction_strong_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 1.4\n    Fraction *fraction = [[Fraction alloc] init];\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    fraction_strong_ = fraction;\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_strong_@viewDidLoad: %@ with retainCount: %@\", fraction_strong_, [fraction_strong_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景1.1(__weak NSString *) 结果 \n2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I'm here! with retainCount: 3\n2016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景1.2(__strong NSString *) 结果 \n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I'm here! with retainCount: 3\n2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I'm here! with retainCount: 3\n2016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I'm here! with retainCount: 2\n2016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I'm here! with retainCount: 1\n\n// 场景1.3(__weak Fraction *) 结果\n2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 1\n2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 1\n2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: <Fraction: 0x7fd942f1dfd0> with retainCount: 3\n2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景1.4(__strong Fraction *) 结果\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 2\n2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: <Fraction: 0x7fd9e9d9ec90> with retainCount: 2\n2016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n2016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: <Fraction: 0x7fd9e9d9ec90> with retainCount: 1\n```\n> 我们使用了一个全局的 __weak 变量 string_weak_ 来指向它。因为 __weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 \n\n最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。\n场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。\n\n### 场景2\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 2.1\n    @autoreleasepool {\n        NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        string_weak_ = string;\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 2.2\n    @autoreleasepool {\n        Fraction *fraction = [[Fraction alloc] init];\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        fraction_weak_ = fraction;\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景2.1(__weak NSString *) 结果\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)\n2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景2.2(__weak Fraction *) 结果\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 1\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 1\n2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: <Fraction: 0x7fe429f425e0> with retainCount: 3\n2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)\n2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n```\n\n### 场景3\n```\n__weak NSString *string_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 3.1\n    NSString *string = [NSString stringWithFormat:@\"I'm here!\"];\n    @autoreleasepool {\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        string_weak_ = string;\n        NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n        NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"string@viewDidLoad: %@ with retainCount: %@\", string, [string valueForKey:@\"retainCount\"]);\n    NSLog(@\"string_weak_@viewDidLoad: %@ with retainCount: %@\", string_weak_, [string_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n__weak Fraction *fraction_weak_ = nil;\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 场景 3.2\n    Fraction *fraction = [[Fraction alloc] init];\n    @autoreleasepool {\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        fraction_weak_ = fraction;\n        NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n        NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n    }\n\n    NSLog(@\"fraction@viewDidLoad: %@ with retainCount: %@\", fraction, [fraction valueForKey:@\"retainCount\"]);\n    NSLog(@\"fraction_weak_@viewDidLoad: %@ with retainCount: %@\", fraction_weak_, [fraction_weak_ valueForKey:@\"retainCount\"]);\n}\n```\n\n```\n// 场景3.1(__weak NSString *) 结果\n2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I'm here! with retainCount: 2\n2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I'm here! with retainCount: 4\n2016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I'm here! with retainCount: 3\n2016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)\n\n// 场景3.2(__weak Fraction *) 结果\n2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 3\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 1\n2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: <Fraction: 0x7ff031737ab0> with retainCount: 3\n2016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)\n2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null)\n```\n\n再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];\n向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：\n```\n+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(\"use object initializers instead\");\n- (void)dealloc OBJC_SWIFT_UNAVAILABLE(\"use 'deinit' to define a de-initializer\");\n```\n\n随后调用了init方法，同样，这来自于NSObject的实例方法。\n\nfraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。\n\n而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。\nOC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，`[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));`我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。\n\n提前阅读一些runtime的知识\n[iOS~runtime理解](http://www.jianshu.com/p/927c8384855a)\n[iOS中的runtime应用](http://www.jianshu.com/p/364eab29f4f5)\n","slug":"iOS基础：类、对象和方法","published":1,"updated":"2019-03-11T09:32:55.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i0z000inflwu25jki17","content":"<p>本文是在阅读<code>Objective-C程序设计  第6版</code>一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。</p>\n<h1 id=\"什么是对象\"><a href=\"#什么是对象\" class=\"headerlink\" title=\"什么是对象\"></a>什么是对象</h1><p>我们知道，OC是在C的基础上设计的<code>面向对象</code>的程序设计语言，而C则是<code>过程性语言</code>。<br>以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。<br>而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。</p>\n<p>我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。<br><a id=\"more\"></a></p>\n<h1 id=\"类、方法\"><a href=\"#类、方法\" class=\"headerlink\" title=\"类、方法\"></a>类、方法</h1><p><strong>Fraction类</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface Fraction : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print;</span><br><span class=\"line\">- (void)setNumerator: (int)n;</span><br><span class=\"line\">- (void)setDenominator: (int)d;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Fraction.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Fraction &#123;</span><br><span class=\"line\">    int numerator;</span><br><span class=\"line\">    int denominator;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print &#123;</span><br><span class=\"line\">    NSLog(@&quot;%i / %i&quot;, numerator, denominator);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setNumerator:(int)n &#123;</span><br><span class=\"line\">    numerator = n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setDenominator:(int)d &#123;</span><br><span class=\"line\">    denominator = d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>main函数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Fraction.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        // insert code here...</span><br><span class=\"line\">        Fraction *fraction;</span><br><span class=\"line\">        </span><br><span class=\"line\">        fraction = [[Fraction alloc] init];</span><br><span class=\"line\">        [fraction setNumerator:1];</span><br><span class=\"line\">        [fraction setDenominator:3];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;The value of fracton is: &quot;);</span><br><span class=\"line\">        [fraction print];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。<br>另外@符号在””前，表示这是常量NSString对象。</p>\n<p>然后来看main函数。<br>第一行中，我们就看到了<code>@autoreleasepool</code>，这是什么呢？</p>\n<h2 id=\"autoreleasepool\"><a href=\"#autoreleasepool\" class=\"headerlink\" title=\"autoreleasepool\"></a>autoreleasepool</h2><p>嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。<br>什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_8c87ba3b0100tgfs.html\" target=\"_blank\" rel=\"noopener\">对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</a></p>\n<p>以下对于autoreleasepool的分析参考了<a href=\"http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/\" target=\"_blank\" rel=\"noopener\">@雷纯锋的技术博客</a><br>文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。</p>\n<p>首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。</p>\n<h3 id=\"场景1\"><a href=\"#场景1\" class=\"headerlink\" title=\"场景1\"></a>场景1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.1</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    string_weak_ = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewWillAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__strong NSString *string_strong_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.2</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    string_strong_ = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_strong_@viewDidLoad: %@ with retainCount: %@&quot;, string_strong_, [string_strong_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ...省略</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.3</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    fraction_weak_ = fraction;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__strong Fraction *fraction_strong_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.4</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    fraction_strong_ = fraction;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_strong_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_strong_, [fraction_strong_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景1.1(__weak NSString *) 结果 </span><br><span class=\"line\">2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.2(__strong NSString *) 结果 </span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I&apos;m here! with retainCount: 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.3(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.4(__strong Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们使用了一个全局的 <strong>weak 变量 string_weak_ 来指向它。因为 </strong>weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 </p>\n</blockquote>\n<p>最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。<br>场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。</p>\n<h3 id=\"场景2\"><a href=\"#场景2\" class=\"headerlink\" title=\"场景2\"></a>场景2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 2.1</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        string_weak_ = string;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 2.2</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        fraction_weak_ = fraction;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景2.1(__weak NSString *) 结果</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景2.2(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br></pre></td></tr></table></figure>\n<h3 id=\"场景3\"><a href=\"#场景3\" class=\"headerlink\" title=\"场景3\"></a>场景3</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 3.1</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        string_weak_ = string;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 3.2</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        fraction_weak_ = fraction;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景3.1(__weak NSString *) 结果</span><br><span class=\"line\">2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景3.2(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br></pre></td></tr></table></figure>\n<p>再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];<br>向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">- (void)dealloc OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;deinit&apos; to define a de-initializer&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>随后调用了init方法，同样，这来自于NSObject的实例方法。</p>\n<p>fraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。</p>\n<p>而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。<br>OC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，<code>[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));</code>我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。</p>\n<p>提前阅读一些runtime的知识<br><a href=\"http://www.jianshu.com/p/927c8384855a\" target=\"_blank\" rel=\"noopener\">iOS~runtime理解</a><br><a href=\"http://www.jianshu.com/p/364eab29f4f5\" target=\"_blank\" rel=\"noopener\">iOS中的runtime应用</a></p>\n","site":{"data":{}},"excerpt":"<p>本文是在阅读<code>Objective-C程序设计  第6版</code>一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。</p>\n<h1 id=\"什么是对象\"><a href=\"#什么是对象\" class=\"headerlink\" title=\"什么是对象\"></a>什么是对象</h1><p>我们知道，OC是在C的基础上设计的<code>面向对象</code>的程序设计语言，而C则是<code>过程性语言</code>。<br>以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。<br>而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。</p>\n<p>我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。<br>","more":"</p>\n<h1 id=\"类、方法\"><a href=\"#类、方法\" class=\"headerlink\" title=\"类、方法\"></a>类、方法</h1><p><strong>Fraction类</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface Fraction : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print;</span><br><span class=\"line\">- (void)setNumerator: (int)n;</span><br><span class=\"line\">- (void)setDenominator: (int)d;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;Fraction.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Fraction &#123;</span><br><span class=\"line\">    int numerator;</span><br><span class=\"line\">    int denominator;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)print &#123;</span><br><span class=\"line\">    NSLog(@&quot;%i / %i&quot;, numerator, denominator);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setNumerator:(int)n &#123;</span><br><span class=\"line\">    numerator = n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setDenominator:(int)d &#123;</span><br><span class=\"line\">    denominator = d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>main函数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;Fraction.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        // insert code here...</span><br><span class=\"line\">        Fraction *fraction;</span><br><span class=\"line\">        </span><br><span class=\"line\">        fraction = [[Fraction alloc] init];</span><br><span class=\"line\">        [fraction setNumerator:1];</span><br><span class=\"line\">        [fraction setDenominator:3];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;The value of fracton is: &quot;);</span><br><span class=\"line\">        [fraction print];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。<br>另外@符号在””前，表示这是常量NSString对象。</p>\n<p>然后来看main函数。<br>第一行中，我们就看到了<code>@autoreleasepool</code>，这是什么呢？</p>\n<h2 id=\"autoreleasepool\"><a href=\"#autoreleasepool\" class=\"headerlink\" title=\"autoreleasepool\"></a>autoreleasepool</h2><p>嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。<br>什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。</p>\n<p><a href=\"http://blog.sina.com.cn/s/blog_8c87ba3b0100tgfs.html\" target=\"_blank\" rel=\"noopener\">对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</a></p>\n<p>以下对于autoreleasepool的分析参考了<a href=\"http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/\" target=\"_blank\" rel=\"noopener\">@雷纯锋的技术博客</a><br>文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。</p>\n<p>首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。</p>\n<h3 id=\"场景1\"><a href=\"#场景1\" class=\"headerlink\" title=\"场景1\"></a>场景1</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.1</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    string_weak_ = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewWillAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewWillAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class=\"line\">    [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__strong NSString *string_strong_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.2</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    string_strong_ = string;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_strong_@viewDidLoad: %@ with retainCount: %@&quot;, string_strong_, [string_strong_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ...省略</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.3</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    fraction_weak_ = fraction;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__strong Fraction *fraction_strong_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 1.4</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    fraction_strong_ = fraction;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_strong_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_strong_, [fraction_strong_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景1.1(__weak NSString *) 结果 </span><br><span class=\"line\">2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.2(__strong NSString *) 结果 </span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I&apos;m here! with retainCount: 1</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.3(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景1.4(__strong Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们使用了一个全局的 <strong>weak 变量 string_weak_ 来指向它。因为 </strong>weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 </p>\n</blockquote>\n<p>最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。<br>场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。</p>\n<h3 id=\"场景2\"><a href=\"#场景2\" class=\"headerlink\" title=\"场景2\"></a>场景2</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 2.1</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        string_weak_ = string;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 2.2</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        fraction_weak_ = fraction;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景2.1(__weak NSString *) 结果</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景2.2(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br></pre></td></tr></table></figure>\n<h3 id=\"场景3\"><a href=\"#场景3\" class=\"headerlink\" title=\"场景3\"></a>场景3</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak NSString *string_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 3.1</span><br><span class=\"line\">    NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;];</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        string_weak_ = string;</span><br><span class=\"line\">        NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Fraction *fraction_weak_ = nil;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 场景 3.2</span><br><span class=\"line\">    Fraction *fraction = [[Fraction alloc] init];</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        fraction_weak_ = fraction;</span><br><span class=\"line\">        NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">        NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">    NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 场景3.1(__weak NSString *) 结果</span><br><span class=\"line\">2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 2</span><br><span class=\"line\">2016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 4</span><br><span class=\"line\">2016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 3</span><br><span class=\"line\">2016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 场景3.2(__weak Fraction *) 结果</span><br><span class=\"line\">2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 1</span><br><span class=\"line\">2016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 3</span><br><span class=\"line\">2016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)</span><br><span class=\"line\">2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null)</span><br></pre></td></tr></table></figure>\n<p>再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];<br>向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);</span><br><span class=\"line\">- (void)dealloc OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;deinit&apos; to define a de-initializer&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>随后调用了init方法，同样，这来自于NSObject的实例方法。</p>\n<p>fraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。</p>\n<p>而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。<br>OC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，<code>[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));</code>我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。</p>\n<p>提前阅读一些runtime的知识<br><a href=\"http://www.jianshu.com/p/927c8384855a\" target=\"_blank\" rel=\"noopener\">iOS~runtime理解</a><br><a href=\"http://www.jianshu.com/p/364eab29f4f5\" target=\"_blank\" rel=\"noopener\">iOS中的runtime应用</a></p>"},{"title":"初学Objective-C","date":"2016-08-16T07:36:56.000Z","_content":"我们知道iOS中的frame由x, y, width, height决定的一个个矩形。\n接下来尝试用一个矩形类来探究如何使用类中的属性和方法。\n<!-- more -->\n\n**坐标类XYPoint。**\n```\n#import <Foundation/Foundation.h>\n\n@interface XYPoint : NSObject\n\n@property int x, y;\n\n- (void)setX:(int)xVal andY:(int)yVal;\n\n@end\n```\n\n```\n#import \"XYPoint.h\"\n\n@implementation XYPoint\n\n-(void)setX:(int)xVal andY:(int)yVal {\n    _x = xVal;\n    _y = yVal;\n}\n\n@end\n```\n<!-- more -->\n\n**矩形类MyRect**\n```\n#import <Foundation/Foundation.h>\n#import \"XYPoint.h\"\n\n@interface MyRect : NSObject\n\n@property (nonatomic) int width, height;\n@property (nonatomic) XYPoint *origin;\n\n- (void)setWidth:(int)w andHeight:(int)h;\n- (int)area;\n- (int)perimeter;\n\n@end\n```\n\n```\n#import \"MyRect.h\"\n\n@implementation MyRect\n\n- (XYPoint *)origin {\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    _origin = origin;\n}\n\n- (void)setWidth:(int)w andHeight:(int)h {\n    _width = w;\n    _height = h;\n}\n\n- (int)area {\n    return _width * _height;\n}\n\n- (int)perimeter {\n    return (_width + _height) * 2;\n}\n\n@end\n```\n\n**main函数**\n```\n#import <Foundation/Foundation.h>\n#import \"MyRect.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyRect *rect = [[MyRect alloc] init];\n        XYPoint *point = [[XYPoint alloc] init];\n        \n        [point setX:100 andY:200];\n        \n        [rect setWidth:5 andHeight:8];\n        rect.origin = point;\n        \n        NSLog(@\"Rect w = %i, h = %i\", rect.width, rect.height);\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        \n        [point setX:50 andY:50];\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n//        NSLog(@\"Area = %i, Perimeter = %i\", [rect area], [rect perimeter]);\n    }\n    return 0;\n}\n```\n\nXYPoint类非常简单，x，y属性，加上其set方法。\nMyRect类中有width，height以及一个XYPoint属性，加上一些方法。\nmain函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。\n\n我们的重点在于MyRect类，这段代码是有问题的。\n首先看头文件，利用@property自动声明get\\set方法。\n再看实现文件，在get方法中报`Use of undeclared indentifier '_origin'`error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为`\"_\" + 属性名`。但是当我们同时重写了get\\set方法时，系统就不再自动帮我生成实例变量了。\n\n现在我们加上`@synthesize origin = _origin;`。error彻底消失，我们也可以自由地重写get\\set方法了。\n运行main函数得到结果。\n```\n2016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 8\n2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)\n2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)\nProgram ended with exit code: 0\n```\n\n回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，\n```\n- (void)setOrigin:(XYPoint *)origin {\n    _origin = origin;\n}\n```\norigin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而`_origin = origin;`只是将这个对象的地址赋值给了实例变量`_origin`，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。\n\n如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。\n\n第一个方案，改造setOrigin方法。\n```\n- (void)setOrigin:(XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    _origin.x = origin.x;\n    _origin.y = origin.y;\n}\n```\n当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。\n运行结果：\n```\n2016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 8\n2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)\n2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)\nProgram ended with exit code: 0\n```\n\n很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。\n```\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    _origin.x = origin.x;\n    _origin.y = origin.y;\n}\n```\n运行代码，期待...\n```\n2016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 8\n2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)\n2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)\nProgram ended with exit code: 0\n```\n然而结果是这样的，x，y的值从始至终都是0。\n\n我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。\n```\nrect.origin;\nrect.origin = point;\n```\n运行，\n```\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 8\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)\nProgram ended with exit code: 0\n```\n很棒，实现了我们的目的。\n\n可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？\n于是...\n```\n@synthesize origin = _origin;\n\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    self.origin.x = origin.x;\n    self.origin.y = origin.y;\n}\n```\n这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。\n\n最后，整理一下思路，`MyRect`类中有一个`origin`属性，我们在它的实现中为它指定了实例变量`_origin`作为它的存储空间。然后我们重写了它的get\\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取`_origin`实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。\n另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。\n\n来看一下改造完的代码。\nMyRect类实现。\n```\n#import \"MyRect.h\"\n\n@implementation MyRect\n\n@synthesize origin = _origin;\n\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    self.origin.x = origin.x;\n    self.origin.y = origin.y;\n}\n\n- (void)setWidth:(int)w andHeight:(int)h {\n    self.width = w;\n    self.height = h;\n}\n\n- (int)area {\n    return self.width * self.height;\n}\n\n- (int)perimeter {\n    return (self.width + self.height) * 2;\n}\n\n@end\n```\n\nmain函数\n```\n#import <Foundation/Foundation.h>\n#import \"MyRect.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyRect *rect = [[MyRect alloc] init];\n        XYPoint *point = [[XYPoint alloc] init];\n        \n        [point setX:100 andY:200];\n        \n        [rect setWidth:5 andHeight:8];\n        rect.origin = point;\n        \n        NSLog(@\"Rect w = %i, h = %i\", rect.width, rect.height);\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        \n        [point setX:50 andY:50];\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        NSLog(@\"Area = %i, Perimeter = %i\", [rect area], [rect perimeter]);\n    }\n    return 0;\n}\n```\n\n运行结果\n```\n2016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 8\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26\nProgram ended with exit code: 0\n```","source":"_posts/初学Objective-C.md","raw":"---\ntitle: 初学Objective-C\ndate: 2016-08-16 15:36:56\ncategories: iOS基础知识\ntags:\n    - Objective-C\n    - 类\n    - 属性\n    - 方法\n    - 惰性实例化\n---\n我们知道iOS中的frame由x, y, width, height决定的一个个矩形。\n接下来尝试用一个矩形类来探究如何使用类中的属性和方法。\n<!-- more -->\n\n**坐标类XYPoint。**\n```\n#import <Foundation/Foundation.h>\n\n@interface XYPoint : NSObject\n\n@property int x, y;\n\n- (void)setX:(int)xVal andY:(int)yVal;\n\n@end\n```\n\n```\n#import \"XYPoint.h\"\n\n@implementation XYPoint\n\n-(void)setX:(int)xVal andY:(int)yVal {\n    _x = xVal;\n    _y = yVal;\n}\n\n@end\n```\n<!-- more -->\n\n**矩形类MyRect**\n```\n#import <Foundation/Foundation.h>\n#import \"XYPoint.h\"\n\n@interface MyRect : NSObject\n\n@property (nonatomic) int width, height;\n@property (nonatomic) XYPoint *origin;\n\n- (void)setWidth:(int)w andHeight:(int)h;\n- (int)area;\n- (int)perimeter;\n\n@end\n```\n\n```\n#import \"MyRect.h\"\n\n@implementation MyRect\n\n- (XYPoint *)origin {\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    _origin = origin;\n}\n\n- (void)setWidth:(int)w andHeight:(int)h {\n    _width = w;\n    _height = h;\n}\n\n- (int)area {\n    return _width * _height;\n}\n\n- (int)perimeter {\n    return (_width + _height) * 2;\n}\n\n@end\n```\n\n**main函数**\n```\n#import <Foundation/Foundation.h>\n#import \"MyRect.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyRect *rect = [[MyRect alloc] init];\n        XYPoint *point = [[XYPoint alloc] init];\n        \n        [point setX:100 andY:200];\n        \n        [rect setWidth:5 andHeight:8];\n        rect.origin = point;\n        \n        NSLog(@\"Rect w = %i, h = %i\", rect.width, rect.height);\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        \n        [point setX:50 andY:50];\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n//        NSLog(@\"Area = %i, Perimeter = %i\", [rect area], [rect perimeter]);\n    }\n    return 0;\n}\n```\n\nXYPoint类非常简单，x，y属性，加上其set方法。\nMyRect类中有width，height以及一个XYPoint属性，加上一些方法。\nmain函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。\n\n我们的重点在于MyRect类，这段代码是有问题的。\n首先看头文件，利用@property自动声明get\\set方法。\n再看实现文件，在get方法中报`Use of undeclared indentifier '_origin'`error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为`\"_\" + 属性名`。但是当我们同时重写了get\\set方法时，系统就不再自动帮我生成实例变量了。\n\n现在我们加上`@synthesize origin = _origin;`。error彻底消失，我们也可以自由地重写get\\set方法了。\n运行main函数得到结果。\n```\n2016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 8\n2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)\n2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)\nProgram ended with exit code: 0\n```\n\n回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，\n```\n- (void)setOrigin:(XYPoint *)origin {\n    _origin = origin;\n}\n```\norigin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而`_origin = origin;`只是将这个对象的地址赋值给了实例变量`_origin`，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。\n\n如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。\n\n第一个方案，改造setOrigin方法。\n```\n- (void)setOrigin:(XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    _origin.x = origin.x;\n    _origin.y = origin.y;\n}\n```\n当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。\n运行结果：\n```\n2016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 8\n2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)\n2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)\nProgram ended with exit code: 0\n```\n\n很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。\n```\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    _origin.x = origin.x;\n    _origin.y = origin.y;\n}\n```\n运行代码，期待...\n```\n2016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 8\n2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)\n2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)\nProgram ended with exit code: 0\n```\n然而结果是这样的，x，y的值从始至终都是0。\n\n我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。\n```\nrect.origin;\nrect.origin = point;\n```\n运行，\n```\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 8\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)\n2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)\nProgram ended with exit code: 0\n```\n很棒，实现了我们的目的。\n\n可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？\n于是...\n```\n@synthesize origin = _origin;\n\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    self.origin.x = origin.x;\n    self.origin.y = origin.y;\n}\n```\n这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。\n\n最后，整理一下思路，`MyRect`类中有一个`origin`属性，我们在它的实现中为它指定了实例变量`_origin`作为它的存储空间。然后我们重写了它的get\\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取`_origin`实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。\n另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。\n\n来看一下改造完的代码。\nMyRect类实现。\n```\n#import \"MyRect.h\"\n\n@implementation MyRect\n\n@synthesize origin = _origin;\n\n- (XYPoint *)origin {\n    if (!_origin) {\n        _origin = [[XYPoint alloc] init];\n    }\n    return _origin;\n}\n\n- (void)setOrigin:(XYPoint *)origin {\n    self.origin.x = origin.x;\n    self.origin.y = origin.y;\n}\n\n- (void)setWidth:(int)w andHeight:(int)h {\n    self.width = w;\n    self.height = h;\n}\n\n- (int)area {\n    return self.width * self.height;\n}\n\n- (int)perimeter {\n    return (self.width + self.height) * 2;\n}\n\n@end\n```\n\nmain函数\n```\n#import <Foundation/Foundation.h>\n#import \"MyRect.h\"\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        MyRect *rect = [[MyRect alloc] init];\n        XYPoint *point = [[XYPoint alloc] init];\n        \n        [point setX:100 andY:200];\n        \n        [rect setWidth:5 andHeight:8];\n        rect.origin = point;\n        \n        NSLog(@\"Rect w = %i, h = %i\", rect.width, rect.height);\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        \n        [point setX:50 andY:50];\n        NSLog(@\"Origin at (%i, %i)\", rect.origin.x, rect.origin.y);\n        NSLog(@\"Area = %i, Perimeter = %i\", [rect area], [rect perimeter]);\n    }\n    return 0;\n}\n```\n\n运行结果\n```\n2016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 8\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)\n2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26\nProgram ended with exit code: 0\n```","slug":"初学Objective-C","published":1,"updated":"2019-03-11T09:32:13.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i11000nnflwmc1q5kkb","content":"<p>我们知道iOS中的frame由x, y, width, height决定的一个个矩形。<br>接下来尝试用一个矩形类来探究如何使用类中的属性和方法。<br><a id=\"more\"></a></p>\n<p><strong>坐标类XYPoint。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XYPoint : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property int x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setX:(int)xVal andY:(int)yVal;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XYPoint.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XYPoint</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)setX:(int)xVal andY:(int)yVal &#123;</span><br><span class=\"line\">    _x = xVal;</span><br><span class=\"line\">    _y = yVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<!-- more -->\n<p><strong>矩形类MyRect</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;XYPoint.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface MyRect : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic) int width, height;</span><br><span class=\"line\">@property (nonatomic) XYPoint *origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h;</span><br><span class=\"line\">- (int)area;</span><br><span class=\"line\">- (int)perimeter;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyRect</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin = origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h &#123;</span><br><span class=\"line\">    _width = w;</span><br><span class=\"line\">    _height = h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)area &#123;</span><br><span class=\"line\">    return _width * _height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)perimeter &#123;</span><br><span class=\"line\">    return (_width + _height) * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>main函数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        MyRect *rect = [[MyRect alloc] init];</span><br><span class=\"line\">        XYPoint *point = [[XYPoint alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:100 andY:200];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [rect setWidth:5 andHeight:8];</span><br><span class=\"line\">        rect.origin = point;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height);</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:50 andY:50];</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">//        NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>XYPoint类非常简单，x，y属性，加上其set方法。<br>MyRect类中有width，height以及一个XYPoint属性，加上一些方法。<br>main函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。</p>\n<p>我们的重点在于MyRect类，这段代码是有问题的。<br>首先看头文件，利用@property自动声明get\\set方法。<br>再看实现文件，在get方法中报<code>Use of undeclared indentifier &#39;_origin&#39;</code>error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为<code>&quot;_&quot; + 属性名</code>。但是当我们同时重写了get\\set方法时，系统就不再自动帮我生成实例变量了。</p>\n<p>现在我们加上<code>@synthesize origin = _origin;</code>。error彻底消失，我们也可以自由地重写get\\set方法了。<br>运行main函数得到结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin = origin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>origin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而<code>_origin = origin;</code>只是将这个对象的地址赋值给了实例变量<code>_origin</code>，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。</p>\n<p>如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。</p>\n<p>第一个方案，改造setOrigin方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _origin.x = origin.x;</span><br><span class=\"line\">    _origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。<br>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin.x = origin.x;</span><br><span class=\"line\">    _origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行代码，期待…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)</span><br><span class=\"line\">2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>然而结果是这样的，x，y的值从始至终都是0。</p>\n<p>我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.origin;</span><br><span class=\"line\">rect.origin = point;</span><br></pre></td></tr></table></figure></p>\n<p>运行，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>很棒，实现了我们的目的。</p>\n<p>可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？<br>于是…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@synthesize origin = _origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    self.origin.x = origin.x;</span><br><span class=\"line\">    self.origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。</p>\n<p>最后，整理一下思路，<code>MyRect</code>类中有一个<code>origin</code>属性，我们在它的实现中为它指定了实例变量<code>_origin</code>作为它的存储空间。然后我们重写了它的get\\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取<code>_origin</code>实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。<br>另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。</p>\n<p>来看一下改造完的代码。<br>MyRect类实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyRect</span><br><span class=\"line\"></span><br><span class=\"line\">@synthesize origin = _origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    self.origin.x = origin.x;</span><br><span class=\"line\">    self.origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h &#123;</span><br><span class=\"line\">    self.width = w;</span><br><span class=\"line\">    self.height = h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)area &#123;</span><br><span class=\"line\">    return self.width * self.height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)perimeter &#123;</span><br><span class=\"line\">    return (self.width + self.height) * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>main函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        MyRect *rect = [[MyRect alloc] init];</span><br><span class=\"line\">        XYPoint *point = [[XYPoint alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:100 andY:200];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [rect setWidth:5 andHeight:8];</span><br><span class=\"line\">        rect.origin = point;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height);</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:50 andY:50];</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>我们知道iOS中的frame由x, y, width, height决定的一个个矩形。<br>接下来尝试用一个矩形类来探究如何使用类中的属性和方法。<br>","more":"</p>\n<p><strong>坐标类XYPoint。</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface XYPoint : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property int x, y;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setX:(int)xVal andY:(int)yVal;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;XYPoint.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation XYPoint</span><br><span class=\"line\"></span><br><span class=\"line\">-(void)setX:(int)xVal andY:(int)yVal &#123;</span><br><span class=\"line\">    _x = xVal;</span><br><span class=\"line\">    _y = yVal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<!-- more -->\n<p><strong>矩形类MyRect</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;XYPoint.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface MyRect : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic) int width, height;</span><br><span class=\"line\">@property (nonatomic) XYPoint *origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h;</span><br><span class=\"line\">- (int)area;</span><br><span class=\"line\">- (int)perimeter;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyRect</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin = origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h &#123;</span><br><span class=\"line\">    _width = w;</span><br><span class=\"line\">    _height = h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)area &#123;</span><br><span class=\"line\">    return _width * _height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)perimeter &#123;</span><br><span class=\"line\">    return (_width + _height) * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><strong>main函数</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        MyRect *rect = [[MyRect alloc] init];</span><br><span class=\"line\">        XYPoint *point = [[XYPoint alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:100 andY:200];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [rect setWidth:5 andHeight:8];</span><br><span class=\"line\">        rect.origin = point;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height);</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:50 andY:50];</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">//        NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>XYPoint类非常简单，x，y属性，加上其set方法。<br>MyRect类中有width，height以及一个XYPoint属性，加上一些方法。<br>main函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。</p>\n<p>我们的重点在于MyRect类，这段代码是有问题的。<br>首先看头文件，利用@property自动声明get\\set方法。<br>再看实现文件，在get方法中报<code>Use of undeclared indentifier &#39;_origin&#39;</code>error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为<code>&quot;_&quot; + 属性名</code>。但是当我们同时重写了get\\set方法时，系统就不再自动帮我生成实例变量了。</p>\n<p>现在我们加上<code>@synthesize origin = _origin;</code>。error彻底消失，我们也可以自由地重写get\\set方法了。<br>运行main函数得到结果。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin = origin;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>origin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而<code>_origin = origin;</code>只是将这个对象的地址赋值给了实例变量<code>_origin</code>，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。</p>\n<p>如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。</p>\n<p>第一个方案，改造setOrigin方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _origin.x = origin.x;</span><br><span class=\"line\">    _origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。<br>运行结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    _origin.x = origin.x;</span><br><span class=\"line\">    _origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行代码，期待…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)</span><br><span class=\"line\">2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>然而结果是这样的，x，y的值从始至终都是0。</p>\n<p>我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.origin;</span><br><span class=\"line\">rect.origin = point;</span><br></pre></td></tr></table></figure></p>\n<p>运行，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>\n<p>很棒，实现了我们的目的。</p>\n<p>可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？<br>于是…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@synthesize origin = _origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    self.origin.x = origin.x;</span><br><span class=\"line\">    self.origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。</p>\n<p>最后，整理一下思路，<code>MyRect</code>类中有一个<code>origin</code>属性，我们在它的实现中为它指定了实例变量<code>_origin</code>作为它的存储空间。然后我们重写了它的get\\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取<code>_origin</code>实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。<br>另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。</p>\n<p>来看一下改造完的代码。<br>MyRect类实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MyRect</span><br><span class=\"line\"></span><br><span class=\"line\">@synthesize origin = _origin;</span><br><span class=\"line\"></span><br><span class=\"line\">- (XYPoint *)origin &#123;</span><br><span class=\"line\">    if (!_origin) &#123;</span><br><span class=\"line\">        _origin = [[XYPoint alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setOrigin:(XYPoint *)origin &#123;</span><br><span class=\"line\">    self.origin.x = origin.x;</span><br><span class=\"line\">    self.origin.y = origin.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setWidth:(int)w andHeight:(int)h &#123;</span><br><span class=\"line\">    self.width = w;</span><br><span class=\"line\">    self.height = h;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)area &#123;</span><br><span class=\"line\">    return self.width * self.height;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (int)perimeter &#123;</span><br><span class=\"line\">    return (self.width + self.height) * 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>main函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &quot;MyRect.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, const char * argv[]) &#123;</span><br><span class=\"line\">    @autoreleasepool &#123;</span><br><span class=\"line\">        MyRect *rect = [[MyRect alloc] init];</span><br><span class=\"line\">        XYPoint *point = [[XYPoint alloc] init];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:100 andY:200];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [rect setWidth:5 andHeight:8];</span><br><span class=\"line\">        rect.origin = point;</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height);</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        </span><br><span class=\"line\">        [point setX:50 andY:50];</span><br><span class=\"line\">        NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);</span><br><span class=\"line\">        NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 8</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)</span><br><span class=\"line\">2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26</span><br><span class=\"line\">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>"},{"title":"开发笔记：Flutter","date":"2019-03-11T09:10:27.000Z","_content":"Flutter官方实例Gallery代码的阅读笔记。\nFlutter选择的dart语言方法名使用的是全小写下划线的规则，而类名命名则是驼峰。\n(dart命名规范)[https://www.dartlang.org/guides/language/effective-dart/style]\n\n# main.dart\napp入口，fullter的runApp方法如下\n```\nvoid runApp(Widget app) {\n  WidgetsFlutterBinding.ensureInitialized()\n    ..attachRootWidget(app)\n    ..scheduleWarmUpFrame();\n}\n```\n`..`是dart中的级联操作符，表示连续调用方法，WidgetsFlutterBinding继承于BindingBase，ensureInitialized方法很简单，创建了一个自身的实例。\n接下来attachRootWidget方法，flutter中有一个很重要的Widget概念，从app到一个按钮全都是Widget，而这些Widget与H5中的doom一样，构成了一个Widget树，attachRootWidget方法就获得了最顶层的根节点。\n最后的scheduleWarmUpFrame方法，里面有两个Timer，根据方法名看在做一些绘制的工作。\n\n#app.dart\nGalleryApp中有不少属性，除了几个bool类型的外，updateUrlFetcher用于App更新提醒（可以借鉴一下用于灰度testFlight），onSendFeedback用于反馈。\n_GalleryAppState中的GalleryOptions存放夜间模式、文字方向、字体大小等全局定义（这部分在自己开发时可以做成本地缓存或server下发，拉到数据之后映射到options）。AppStateModel其实很类似，用于购物车业务。\n在build方法中初始化GalleryHome，返回了一个ScopedModel StatelessWidget，指定home。\n\n","source":"_posts/开发笔记：Flutter.md","raw":"---\n\ntitle: 开发笔记：Flutter\ndate: 2019-03-11 17:10:27\ncategories: 笔记\ntags: \n    - Flutter \n    - iOS\n---\nFlutter官方实例Gallery代码的阅读笔记。\nFlutter选择的dart语言方法名使用的是全小写下划线的规则，而类名命名则是驼峰。\n(dart命名规范)[https://www.dartlang.org/guides/language/effective-dart/style]\n\n# main.dart\napp入口，fullter的runApp方法如下\n```\nvoid runApp(Widget app) {\n  WidgetsFlutterBinding.ensureInitialized()\n    ..attachRootWidget(app)\n    ..scheduleWarmUpFrame();\n}\n```\n`..`是dart中的级联操作符，表示连续调用方法，WidgetsFlutterBinding继承于BindingBase，ensureInitialized方法很简单，创建了一个自身的实例。\n接下来attachRootWidget方法，flutter中有一个很重要的Widget概念，从app到一个按钮全都是Widget，而这些Widget与H5中的doom一样，构成了一个Widget树，attachRootWidget方法就获得了最顶层的根节点。\n最后的scheduleWarmUpFrame方法，里面有两个Timer，根据方法名看在做一些绘制的工作。\n\n#app.dart\nGalleryApp中有不少属性，除了几个bool类型的外，updateUrlFetcher用于App更新提醒（可以借鉴一下用于灰度testFlight），onSendFeedback用于反馈。\n_GalleryAppState中的GalleryOptions存放夜间模式、文字方向、字体大小等全局定义（这部分在自己开发时可以做成本地缓存或server下发，拉到数据之后映射到options）。AppStateModel其实很类似，用于购物车业务。\n在build方法中初始化GalleryHome，返回了一个ScopedModel StatelessWidget，指定home。\n\n","slug":"开发笔记：Flutter","published":1,"updated":"2019-03-15T08:19:51.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i15000qnflwttr715f9","content":"<p>Flutter官方实例Gallery代码的阅读笔记。<br>Flutter选择的dart语言方法名使用的是全小写下划线的规则，而类名命名则是驼峰。<br>(dart命名规范)[<a href=\"https://www.dartlang.org/guides/language/effective-dart/style]\" target=\"_blank\" rel=\"noopener\">https://www.dartlang.org/guides/language/effective-dart/style]</a></p>\n<h1 id=\"main-dart\"><a href=\"#main-dart\" class=\"headerlink\" title=\"main.dart\"></a>main.dart</h1><p>app入口，fullter的runApp方法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void runApp(Widget app) &#123;</span><br><span class=\"line\">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class=\"line\">    ..attachRootWidget(app)</span><br><span class=\"line\">    ..scheduleWarmUpFrame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>..</code>是dart中的级联操作符，表示连续调用方法，WidgetsFlutterBinding继承于BindingBase，ensureInitialized方法很简单，创建了一个自身的实例。<br>接下来attachRootWidget方法，flutter中有一个很重要的Widget概念，从app到一个按钮全都是Widget，而这些Widget与H5中的doom一样，构成了一个Widget树，attachRootWidget方法就获得了最顶层的根节点。<br>最后的scheduleWarmUpFrame方法，里面有两个Timer，根据方法名看在做一些绘制的工作。</p>\n<p>#app.dart<br>GalleryApp中有不少属性，除了几个bool类型的外，updateUrlFetcher用于App更新提醒（可以借鉴一下用于灰度testFlight），onSendFeedback用于反馈。<br>_GalleryAppState中的GalleryOptions存放夜间模式、文字方向、字体大小等全局定义（这部分在自己开发时可以做成本地缓存或server下发，拉到数据之后映射到options）。AppStateModel其实很类似，用于购物车业务。<br>在build方法中初始化GalleryHome，返回了一个ScopedModel StatelessWidget，指定home。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Flutter官方实例Gallery代码的阅读笔记。<br>Flutter选择的dart语言方法名使用的是全小写下划线的规则，而类名命名则是驼峰。<br>(dart命名规范)[<a href=\"https://www.dartlang.org/guides/language/effective-dart/style]\" target=\"_blank\" rel=\"noopener\">https://www.dartlang.org/guides/language/effective-dart/style]</a></p>\n<h1 id=\"main-dart\"><a href=\"#main-dart\" class=\"headerlink\" title=\"main.dart\"></a>main.dart</h1><p>app入口，fullter的runApp方法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void runApp(Widget app) &#123;</span><br><span class=\"line\">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class=\"line\">    ..attachRootWidget(app)</span><br><span class=\"line\">    ..scheduleWarmUpFrame();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>..</code>是dart中的级联操作符，表示连续调用方法，WidgetsFlutterBinding继承于BindingBase，ensureInitialized方法很简单，创建了一个自身的实例。<br>接下来attachRootWidget方法，flutter中有一个很重要的Widget概念，从app到一个按钮全都是Widget，而这些Widget与H5中的doom一样，构成了一个Widget树，attachRootWidget方法就获得了最顶层的根节点。<br>最后的scheduleWarmUpFrame方法，里面有两个Timer，根据方法名看在做一些绘制的工作。</p>\n<p>#app.dart<br>GalleryApp中有不少属性，除了几个bool类型的外，updateUrlFetcher用于App更新提醒（可以借鉴一下用于灰度testFlight），onSendFeedback用于反馈。<br>_GalleryAppState中的GalleryOptions存放夜间模式、文字方向、字体大小等全局定义（这部分在自己开发时可以做成本地缓存或server下发，拉到数据之后映射到options）。AppStateModel其实很类似，用于购物车业务。<br>在build方法中初始化GalleryHome，返回了一个ScopedModel StatelessWidget，指定home。</p>\n"},{"title":"属性变量、实例变量、成员变量的内存泄漏测试","date":"2018-07-18T03:33:56.000Z","_content":"\n直接上代码\n```\n@interface TestViewController () {\n@private\n    NSString *name1;\n}\n\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, strong) TestObject *testObj;\n\n@property (nonatomic, strong) TestObject *testObj1;\n\n@property (nonatomic, copy) NSString *name2;\n@property (nonatomic, strong) TestObject *testObj2;\n@end\n```\n```\n// 无泄漏\n- (void)testBlock {\n    __weak typeof(self) weakSelf = self;\n    [self.testObj requestData:^(NSString *str) {\n        weakSelf.name = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock1 {\n    [self.testObj1 requestData:^(NSString *str) {\n        name1 = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock1_2 {\n    [self.testObj1 requestData:^(NSString *str) {\n        self->name1 = str;\n    }];\n}\n\n// 无泄漏\n- (void)testBlock1_3 {\n    __weak typeof(self) weakSelf = self;\n    [self.testObj1 requestData:^(NSString *str) {\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        strongSelf->name1 = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock2 {\n    [self.testObj2 requestData:^(NSString *str) {\n        _name2 = str;\n    }];\n}\n```\n\n属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self->name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。\n","source":"_posts/属性变量、实例变量、成员变量的内存泄漏测试.md","raw":"---\ntitle: 属性变量、实例变量、成员变量的内存泄漏测试\ndate: 2018-07-18 11:33:56\ncategories: iOS基础知识\ntags:\n    - Objective-C\n    - 内存泄漏\n---\n\n直接上代码\n```\n@interface TestViewController () {\n@private\n    NSString *name1;\n}\n\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, strong) TestObject *testObj;\n\n@property (nonatomic, strong) TestObject *testObj1;\n\n@property (nonatomic, copy) NSString *name2;\n@property (nonatomic, strong) TestObject *testObj2;\n@end\n```\n```\n// 无泄漏\n- (void)testBlock {\n    __weak typeof(self) weakSelf = self;\n    [self.testObj requestData:^(NSString *str) {\n        weakSelf.name = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock1 {\n    [self.testObj1 requestData:^(NSString *str) {\n        name1 = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock1_2 {\n    [self.testObj1 requestData:^(NSString *str) {\n        self->name1 = str;\n    }];\n}\n\n// 无泄漏\n- (void)testBlock1_3 {\n    __weak typeof(self) weakSelf = self;\n    [self.testObj1 requestData:^(NSString *str) {\n        __strong typeof(weakSelf) strongSelf = weakSelf;\n        strongSelf->name1 = str;\n    }];\n}\n\n// 泄漏\n- (void)testBlock2 {\n    [self.testObj2 requestData:^(NSString *str) {\n        _name2 = str;\n    }];\n}\n```\n\n属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self->name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。\n","slug":"属性变量、实例变量、成员变量的内存泄漏测试","published":1,"updated":"2019-03-11T09:32:17.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i19000tnflw81mntd9j","content":"<p>直接上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface TestViewController () &#123;</span><br><span class=\"line\">@private</span><br><span class=\"line\">    NSString *name1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name;</span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj1;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name2;</span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj2;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 无泄漏</span><br><span class=\"line\">- (void)testBlock &#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testObj requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        weakSelf.name = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock1 &#123;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock1_2 &#123;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        self-&gt;name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 无泄漏</span><br><span class=\"line\">- (void)testBlock1_3 &#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">        strongSelf-&gt;name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock2 &#123;</span><br><span class=\"line\">    [self.testObj2 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        _name2 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self-&gt;name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>直接上代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface TestViewController () &#123;</span><br><span class=\"line\">@private</span><br><span class=\"line\">    NSString *name1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name;</span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj1;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, copy) NSString *name2;</span><br><span class=\"line\">@property (nonatomic, strong) TestObject *testObj2;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 无泄漏</span><br><span class=\"line\">- (void)testBlock &#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testObj requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        weakSelf.name = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock1 &#123;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock1_2 &#123;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        self-&gt;name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 无泄漏</span><br><span class=\"line\">- (void)testBlock1_3 &#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    [self.testObj1 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        __strong typeof(weakSelf) strongSelf = weakSelf;</span><br><span class=\"line\">        strongSelf-&gt;name1 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 泄漏</span><br><span class=\"line\">- (void)testBlock2 &#123;</span><br><span class=\"line\">    [self.testObj2 requestData:^(NSString *str) &#123;</span><br><span class=\"line\">        _name2 = str;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self-&gt;name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。</p>\n"},{"title":"开发笔记：iOS中的好多坑","date":"2016-12-19T07:48:43.000Z","_content":"\n1. NSNumber类型判断是否为0不能使用`aIntegerNum == 0`，而应使用`[aIntegerNum isEqualToNumber:@0]`，前者比较地址，后者比较值。\n2. UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。\n3. 时间戳转换时间时会相差8小时，需要计算时区。\n4. iOS10中UISwitch的特异性\n5. 快速便利Array\\Set时，对元素进行操作必挂\n6. 在block中使用成员变量，会导致循环引用\n7. iOS10以下导航栏问题[http://www.jianshu.com/p/e4448c24d900](导航栏隐藏 && 导航栏错乱) [http://www.jianshu.com/p/4b8af425a7d0](iOS 隐藏导航栏导致导航栏错乱的那些坑)\n8. __block相当于unsafe_unretain，在某些情况下，会导致crash\n```\nself.string1 = @\"String 1\";   \nself.string2 = self.string1;   // unsafe_unretain\nself.string1 = nil;  \nNSLog(@\"String 2 = %@\", self.string2);  \n```\n9. MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。\n10. A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad。\n11. iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。\n12. Notification在主线程中是同步执行的。\n13. 若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。\n14. iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。\n15. 虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。\n16. 一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。\n17. UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照[https://www.jianshu.com/p/57b2c41448bf](UIButton选中状态下的点击)。","source":"_posts/开发笔记：iOS中的好多坑.md","raw":"---\ntitle: 开发笔记：iOS中的好多坑\ndate: 2016-12-19 15:48:43\ncategories: 笔记\ntags: \n    - iOS\n    - 笔记\n---\n\n1. NSNumber类型判断是否为0不能使用`aIntegerNum == 0`，而应使用`[aIntegerNum isEqualToNumber:@0]`，前者比较地址，后者比较值。\n2. UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。\n3. 时间戳转换时间时会相差8小时，需要计算时区。\n4. iOS10中UISwitch的特异性\n5. 快速便利Array\\Set时，对元素进行操作必挂\n6. 在block中使用成员变量，会导致循环引用\n7. iOS10以下导航栏问题[http://www.jianshu.com/p/e4448c24d900](导航栏隐藏 && 导航栏错乱) [http://www.jianshu.com/p/4b8af425a7d0](iOS 隐藏导航栏导致导航栏错乱的那些坑)\n8. __block相当于unsafe_unretain，在某些情况下，会导致crash\n```\nself.string1 = @\"String 1\";   \nself.string2 = self.string1;   // unsafe_unretain\nself.string1 = nil;  \nNSLog(@\"String 2 = %@\", self.string2);  \n```\n9. MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。\n10. A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad。\n11. iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。\n12. Notification在主线程中是同步执行的。\n13. 若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。\n14. iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。\n15. 虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。\n16. 一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。\n17. UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照[https://www.jianshu.com/p/57b2c41448bf](UIButton选中状态下的点击)。","slug":"开发笔记：iOS中的好多坑","published":1,"updated":"2019-03-11T09:29:42.822Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i1a000vnflwwvdz8alo","content":"<ol>\n<li>NSNumber类型判断是否为0不能使用<code>aIntegerNum == 0</code>，而应使用<code>[aIntegerNum isEqualToNumber:@0]</code>，前者比较地址，后者比较值。</li>\n<li>UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。</li>\n<li>时间戳转换时间时会相差8小时，需要计算时区。</li>\n<li>iOS10中UISwitch的特异性</li>\n<li>快速便利Array\\Set时，对元素进行操作必挂</li>\n<li>在block中使用成员变量，会导致循环引用</li>\n<li>iOS10以下导航栏问题<a href=\"导航栏隐藏 &amp;&amp; 导航栏错乱\">http://www.jianshu.com/p/e4448c24d900</a> <a href=\"iOS 隐藏导航栏导致导航栏错乱的那些坑\">http://www.jianshu.com/p/4b8af425a7d0</a></li>\n<li><p>__block相当于unsafe_unretain，在某些情况下，会导致crash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.string1 = @&quot;String 1&quot;;   </span><br><span class=\"line\">self.string2 = self.string1;   // unsafe_unretain</span><br><span class=\"line\">self.string1 = nil;  </span><br><span class=\"line\">NSLog(@&quot;String 2 = %@&quot;, self.string2);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。</p>\n</li>\n<li>A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad。</li>\n<li>iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。</li>\n<li>Notification在主线程中是同步执行的。</li>\n<li>若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。</li>\n<li>iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。</li>\n<li>虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。</li>\n<li>一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。</li>\n<li>UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照<a href=\"UIButton选中状态下的点击\">https://www.jianshu.com/p/57b2c41448bf</a>。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>NSNumber类型判断是否为0不能使用<code>aIntegerNum == 0</code>，而应使用<code>[aIntegerNum isEqualToNumber:@0]</code>，前者比较地址，后者比较值。</li>\n<li>UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。</li>\n<li>时间戳转换时间时会相差8小时，需要计算时区。</li>\n<li>iOS10中UISwitch的特异性</li>\n<li>快速便利Array\\Set时，对元素进行操作必挂</li>\n<li>在block中使用成员变量，会导致循环引用</li>\n<li>iOS10以下导航栏问题<a href=\"导航栏隐藏 &amp;&amp; 导航栏错乱\">http://www.jianshu.com/p/e4448c24d900</a> <a href=\"iOS 隐藏导航栏导致导航栏错乱的那些坑\">http://www.jianshu.com/p/4b8af425a7d0</a></li>\n<li><p>__block相当于unsafe_unretain，在某些情况下，会导致crash</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.string1 = @&quot;String 1&quot;;   </span><br><span class=\"line\">self.string2 = self.string1;   // unsafe_unretain</span><br><span class=\"line\">self.string1 = nil;  </span><br><span class=\"line\">NSLog(@&quot;String 2 = %@&quot;, self.string2);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。</p>\n</li>\n<li>A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad。</li>\n<li>iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。</li>\n<li>Notification在主线程中是同步执行的。</li>\n<li>若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。</li>\n<li>iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。</li>\n<li>虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。</li>\n<li>一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。</li>\n<li>UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照<a href=\"UIButton选中状态下的点击\">https://www.jianshu.com/p/57b2c41448bf</a>。</li>\n</ol>\n"},{"title":"开源库阅读笔记：YYKit-YYModel","date":"2017-03-13T10:33:05.000Z","_content":"\nYYKit，作者ibireme，[Blog](http://blog.ibireme.com)，[YYKitDemo](https://github.com/ibireme/YYKit)。\n\n# YYModel\nYYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。\nJSON解析过程如下：\n1. 判空，获取class。\n2. 若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。\n3. 根据JSON转化Model。\n自定义class属于扩展功能，先分析JSON转化Model这一主要功能。\n<!-- more -->\n\n## JSON转化Model\n此功能核心方法如下：\n```\n- (BOOL)modelSetWithDictionary:(NSDictionary *)dic {\n    if (!dic || dic == (id)kCFNull) return NO;\n    if (![dic isKindOfClass:[NSDictionary class]]) return NO;\n    \n    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];\n    if (modelMeta->_keyMappedCount == 0) return NO;\n    \n    if (modelMeta->_hasCustomWillTransformFromDictionary) {\n        dic = [((id<YYModel>)self) modelCustomWillTransformFromDictionary:dic];\n        if (![dic isKindOfClass:[NSDictionary class]]) return NO;\n    }\n    \n    ModelSetContext context = {0};\n    context.modelMeta = (__bridge void *)(modelMeta);\n    context.model = (__bridge void *)(self);\n    context.dictionary = (__bridge void *)(dic);\n    \n    if (modelMeta->_keyMappedCount >= CFDictionaryGetCount((CFDictionaryRef)dic)) {\n        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &context);\n        if (modelMeta->_keyPathPropertyMetas) {\n            CFArrayApplyFunction((CFArrayRef)modelMeta->_keyPathPropertyMetas,\n                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_keyPathPropertyMetas)),\n                                 ModelSetWithPropertyMetaArrayFunction,\n                                 &context);\n        }\n        if (modelMeta->_multiKeysPropertyMetas) {\n            CFArrayApplyFunction((CFArrayRef)modelMeta->_multiKeysPropertyMetas,\n                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_multiKeysPropertyMetas)),\n                                 ModelSetWithPropertyMetaArrayFunction,\n                                 &context);\n        }\n    } else {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_allPropertyMetas,\n                             CFRangeMake(0, modelMeta->_keyMappedCount),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n    \n    if (modelMeta->_hasCustomTransformFromDictionary) {\n        return [((id<YYModel>)self) modelCustomTransformFromDictionary:dic];\n    }\n    return YES;\n}\n```\n其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。\n\n### 异常处理\n首先对传入的NSDictionary进行了判空处理，如下。\n```\nif (!dic || dic == (id)kCFNull) return NO;\nif (![dic isKindOfClass:[NSDictionary class]]) return NO;\n```\n> 在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？\n> iOS中的空值类型有5种：nil\\Nil\\NULL\\NSNull\\kCFNull。\n> nil：指向一个实例对象的空指针。\n> Nil：指向一个类的空指针。\n> NULL：定义基本类型、C类型的空指针。\n> NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。\n> kCFNull：NSNull的单例。\n> 参考：[IOS 空值 nil Nil NULL NSNull kCFNull](http://www.jianshu.com/p/3aaefb3bcf73)\n\n### 获取元类\n```\n_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];\n```\n要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。\n> ![对象模型图](/对象模型图.png)\n> 可参考：[Objective-C中的类和对象](http://blog.ibireme.com/2013/11/25/objc-object/)\n> [object_getClass(obj)与[obj class]的区别](http://www.jianshu.com/p/ae5c32708bc6)\n> 测试代码如下：\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    TestClass *obj1 = [[TestClass alloc] init];\n    TestClass *obj2 = [[TestClass alloc] init];\n    \n    Class cls1 = object_getClass(obj1);\n    Class cls2 = object_getClass(cls1);\n    Class cls3 = object_getClass(cls2);\n    NSLog(@\"%@, %p\", obj1, obj1);\n    NSLog(@\"%@, %p\", cls1, cls1);\n    NSLog(@\"%@, %p\", cls2, cls2);\n    NSLog(@\"%@, %p\", cls3, cls3);\n    \n    Class cls4 = [obj1 class];\n    Class cls5 = [cls4 class];\n    Class cls6 = [cls5 class];\n    NSLog(@\"%@, %p\", obj2, obj2);\n    NSLog(@\"%@, %p\", cls4, cls4);\n    NSLog(@\"%@, %p\", cls5, cls5);\n    NSLog(@\"%@, %p\", cls6, cls6);\n    \n    Class cls7 = [cls1 class];\n    Class cls8 = [cls2 class];\n    Class cls9 = [cls3 class];\n    NSLog(@\"%@, %p\", cls7, cls7);\n    NSLog(@\"%@, %p\", cls8, cls8);\n    NSLog(@\"%@, %p\", cls9, cls9);\n}\n```\n> \n> 其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。\n> 结果如下：\n```\n2017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] <TestClass: 0x174007f90>, 0x174007f90\n2017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x100101258\n2017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8\n2017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] <TestClass: 0x174007fa0>, 0x174007fa0\n2017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x100101258\n2017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8\n```\n> \n> 可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。\n\n然后我们来看看YYModel中的元类`_YYModelMeta`，其数据结构如下：\n```\n@interface _YYModelMeta : NSObject {\n    @package\n    YYClassInfo *_classInfo;\n    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.\n    NSDictionary *_mapper;\n    /// Array<_YYModelPropertyMeta>, all property meta of this model.\n    NSArray *_allPropertyMetas;\n    /// Array<_YYModelPropertyMeta>, property meta which is mapped to a key path.\n    NSArray *_keyPathPropertyMetas;\n    /// Array<_YYModelPropertyMeta>, property meta which is mapped to multi keys.\n    NSArray *_multiKeysPropertyMetas;\n    /// The number of mapped key (and key path), same to _mapper.count.\n    NSUInteger _keyMappedCount;\n    /// Model class type.\n    YYEncodingNSType _nsType;\n    \n    BOOL _hasCustomWillTransformFromDictionary;\n    BOOL _hasCustomTransformFromDictionary;\n    BOOL _hasCustomTransformToDictionary;\n    BOOL _hasCustomClassFromDictionary;\n}\n@end\n```\n> Objective-C中有4种访问控制符：\n> @private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。\n> @package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。\n> @protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。\n> @public（公共访问权限）：成员可以在任意地方访问。\n\n`_YYModelMeta`存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给`_YYModelPropertyMeta`处理。\n```\n@interface _YYModelPropertyMeta : NSObject {\n    @package\n    NSString *_name;             ///< property's name\n    YYEncodingType _type;        ///< property's type\n    YYEncodingNSType _nsType;    ///< property's Foundation type\n    BOOL _isCNumber;             ///< is c number type\n    Class _cls;                  ///< property's class, or nil\n    Class _genericCls;           ///< container's generic class, or nil if threr's no generic class\n    SEL _getter;                 ///< getter, or nil if the instances cannot respond\n    SEL _setter;                 ///< setter, or nil if the instances cannot respond\n    BOOL _isKVCCompatible;       ///< YES if it can access with key-value coding\n    BOOL _isStructAvailableForKeyedArchiver; ///< YES if the struct can encoded with keyed archiver/unarchiver\n    BOOL _hasCustomClassFromDictionary; ///< class/generic class implements +modelCustomClassForDictionary:\n    \n    /*\n     property->key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil\n     property->keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil\n     property->keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)\n     */\n    NSString *_mappedToKey;      ///< the key mapped to\n    NSArray *_mappedToKeyPath;   ///< the key path mapped to (nil if the name is not key path)\n    NSArray *_mappedToKeyArray;  ///< the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys)\n    YYClassPropertyInfo *_info;  ///< property's info\n    _YYModelPropertyMeta *_next; ///< next meta if there are multiple properties mapped to the same key.\n}\n@end\n\n@interface YYClassPropertyInfo : NSObject\n@property (nonatomic, assign, readonly) objc_property_t property; ///< property's opaque struct\n@property (nonatomic, strong, readonly) NSString *name;           ///< property's name\n@property (nonatomic, assign, readonly) YYEncodingType type;      ///< property's type\n@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///< property's encoding value\n@property (nonatomic, strong, readonly) NSString *ivarName;       ///< property's ivar name\n@property (nullable, nonatomic, assign, readonly) Class cls;      ///< may be nil\n@property (nullable, nonatomic, strong, readonly) NSArray<NSString *> *protocols; ///< may nil\n@property (nonatomic, assign, readonly) SEL getter;               ///< getter (nonnull)\n@property (nonatomic, assign, readonly) SEL setter;               ///< setter (nonnull)\n@end\n```\n\n`YYClassInfo`则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。\n```\n@interface YYClassInfo : NSObject\n@property (nonatomic, assign, readonly) Class cls; ///< class object\n@property (nullable, nonatomic, assign, readonly) Class superCls; ///< super class object\n@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///< class's meta class object\n@property (nonatomic, readonly) BOOL isMeta; ///< whether this class is meta class\n@property (nonatomic, strong, readonly) NSString *name; ///< class name\n@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///< super class's class info\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassIvarInfo *> *ivarInfos; ///< ivars\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassMethodInfo *> *methodInfos; ///< methods\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassPropertyInfo *> *propertyInfos; ///< properties\n\n- (void)setNeedUpdate;\n- (BOOL)needUpdate;\n+ (nullable instancetype)classInfoWithClass:(Class)cls;\n+ (nullable instancetype)classInfoWithClassName:(NSString *)className;\n@end\n```\n> ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。\n\n随后通过`+ (instancetype)metaWithClass:(Class)cls;`进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下：\n> 1. [CFMutableDictionaryRef](https://developer.apple.com/reference/corefoundation/cfmutabledictionary-rpl)是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要\n> 2. dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看[资料1](http://www.jianshu.com/p/a84c2bf0d77b)[资料2](http://blog.ibireme.com/2015/10/26/yycache/)\n> 3. 两个时间宏\n> #define DISPATCH_TIME_NOW (0ull)\n> #define DISPATCH_TIME_FOREVER (~0ull)\n> 0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数\n\n真正的初始化方法是`- (instancetype)initWithClass:(Class)cls;`，其流程如下：\n1. 获取YYClassInfo。\n2. 获取黑名单。\n3. 获取白名单。\n4. 获取用户自定义属性。\n5. 循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入`_allPropertyMetas`、`_keyPathPropertyMetas`、`_multiKeysPropertyMetas`。\n6. 设置属性映射mapper。\n\n至此已获取YYModel元类，包括key/value属性映射关系，回到`- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;`进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。\n```\nModelSetContext context = {0};\ncontext.modelMeta = (__bridge void *)(modelMeta);\ncontext.model = (__bridge void *)(self);\ncontext.dictionary = (__bridge void *)(dic);\n\nif (modelMeta->_keyMappedCount >= CFDictionaryGetCount((CFDictionaryRef)dic)) {\n    CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &context);\n    if (modelMeta->_keyPathPropertyMetas) {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_keyPathPropertyMetas,\n                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_keyPathPropertyMetas)),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n    if (modelMeta->_multiKeysPropertyMetas) {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_multiKeysPropertyMetas,\n                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_multiKeysPropertyMetas)),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n} else {\n    CFArrayApplyFunction((CFArrayRef)modelMeta->_allPropertyMetas,\n                         CFRangeMake(0, modelMeta->_keyMappedCount),\n                         ModelSetWithPropertyMetaArrayFunction,\n                         &context);\n}\n\ntypedef struct {\n    void *modelMeta;  ///< _YYModelMeta\n    void *model;      ///< id (self)\n    void *dictionary; ///< NSDictionary (json)\n} ModelSetContext;\n```\n> SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。\n> IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。\n> \n> KVC(key value coding)\n> KVC涉及以下4个方法\n```\n- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值\n- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值\n- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值\n- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值\n```\n> [iOS开发技巧系列---详解KVC](http://www.jianshu.com/p/45cbd324ea65)\n> \n> KVO(key value obeserveing)\n> KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。\n```\n- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;\n- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;\n```\n> [IOS 开发中的KVC 和KVO](http://www.jianshu.com/p/c1dd046d9ce2)\n\n扩展阅读：\n[看 YYModel 源码的一些收获](http://www.cocoachina.com/cms/wap.php?action=article&id=17874)\n> 性能优化Tip\n> 缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。\n> 查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。\n> 避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。\n> 避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。\n> 避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。\n> 遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。\n> 尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。\n> 减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。","source":"_posts/开源库阅读笔记：YYKit-YYModel.md","raw":"---\ntitle: 开源库阅读笔记：YYKit-YYModel\ndate: 2017-03-13 18:33:05\ncategories: 笔记\ntags: \n    - 开源库阅读笔记\n---\n\nYYKit，作者ibireme，[Blog](http://blog.ibireme.com)，[YYKitDemo](https://github.com/ibireme/YYKit)。\n\n# YYModel\nYYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。\nJSON解析过程如下：\n1. 判空，获取class。\n2. 若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。\n3. 根据JSON转化Model。\n自定义class属于扩展功能，先分析JSON转化Model这一主要功能。\n<!-- more -->\n\n## JSON转化Model\n此功能核心方法如下：\n```\n- (BOOL)modelSetWithDictionary:(NSDictionary *)dic {\n    if (!dic || dic == (id)kCFNull) return NO;\n    if (![dic isKindOfClass:[NSDictionary class]]) return NO;\n    \n    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];\n    if (modelMeta->_keyMappedCount == 0) return NO;\n    \n    if (modelMeta->_hasCustomWillTransformFromDictionary) {\n        dic = [((id<YYModel>)self) modelCustomWillTransformFromDictionary:dic];\n        if (![dic isKindOfClass:[NSDictionary class]]) return NO;\n    }\n    \n    ModelSetContext context = {0};\n    context.modelMeta = (__bridge void *)(modelMeta);\n    context.model = (__bridge void *)(self);\n    context.dictionary = (__bridge void *)(dic);\n    \n    if (modelMeta->_keyMappedCount >= CFDictionaryGetCount((CFDictionaryRef)dic)) {\n        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &context);\n        if (modelMeta->_keyPathPropertyMetas) {\n            CFArrayApplyFunction((CFArrayRef)modelMeta->_keyPathPropertyMetas,\n                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_keyPathPropertyMetas)),\n                                 ModelSetWithPropertyMetaArrayFunction,\n                                 &context);\n        }\n        if (modelMeta->_multiKeysPropertyMetas) {\n            CFArrayApplyFunction((CFArrayRef)modelMeta->_multiKeysPropertyMetas,\n                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_multiKeysPropertyMetas)),\n                                 ModelSetWithPropertyMetaArrayFunction,\n                                 &context);\n        }\n    } else {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_allPropertyMetas,\n                             CFRangeMake(0, modelMeta->_keyMappedCount),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n    \n    if (modelMeta->_hasCustomTransformFromDictionary) {\n        return [((id<YYModel>)self) modelCustomTransformFromDictionary:dic];\n    }\n    return YES;\n}\n```\n其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。\n\n### 异常处理\n首先对传入的NSDictionary进行了判空处理，如下。\n```\nif (!dic || dic == (id)kCFNull) return NO;\nif (![dic isKindOfClass:[NSDictionary class]]) return NO;\n```\n> 在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？\n> iOS中的空值类型有5种：nil\\Nil\\NULL\\NSNull\\kCFNull。\n> nil：指向一个实例对象的空指针。\n> Nil：指向一个类的空指针。\n> NULL：定义基本类型、C类型的空指针。\n> NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。\n> kCFNull：NSNull的单例。\n> 参考：[IOS 空值 nil Nil NULL NSNull kCFNull](http://www.jianshu.com/p/3aaefb3bcf73)\n\n### 获取元类\n```\n_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];\n```\n要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。\n> ![对象模型图](/对象模型图.png)\n> 可参考：[Objective-C中的类和对象](http://blog.ibireme.com/2013/11/25/objc-object/)\n> [object_getClass(obj)与[obj class]的区别](http://www.jianshu.com/p/ae5c32708bc6)\n> 测试代码如下：\n```\n- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    \n    TestClass *obj1 = [[TestClass alloc] init];\n    TestClass *obj2 = [[TestClass alloc] init];\n    \n    Class cls1 = object_getClass(obj1);\n    Class cls2 = object_getClass(cls1);\n    Class cls3 = object_getClass(cls2);\n    NSLog(@\"%@, %p\", obj1, obj1);\n    NSLog(@\"%@, %p\", cls1, cls1);\n    NSLog(@\"%@, %p\", cls2, cls2);\n    NSLog(@\"%@, %p\", cls3, cls3);\n    \n    Class cls4 = [obj1 class];\n    Class cls5 = [cls4 class];\n    Class cls6 = [cls5 class];\n    NSLog(@\"%@, %p\", obj2, obj2);\n    NSLog(@\"%@, %p\", cls4, cls4);\n    NSLog(@\"%@, %p\", cls5, cls5);\n    NSLog(@\"%@, %p\", cls6, cls6);\n    \n    Class cls7 = [cls1 class];\n    Class cls8 = [cls2 class];\n    Class cls9 = [cls3 class];\n    NSLog(@\"%@, %p\", cls7, cls7);\n    NSLog(@\"%@, %p\", cls8, cls8);\n    NSLog(@\"%@, %p\", cls9, cls9);\n}\n```\n> \n> 其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。\n> 结果如下：\n```\n2017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] <TestClass: 0x174007f90>, 0x174007f90\n2017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x100101258\n2017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8\n2017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] <TestClass: 0x174007fa0>, 0x174007fa0\n2017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x100101280\n2017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x100101258\n2017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8\n```\n> \n> 可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。\n\n然后我们来看看YYModel中的元类`_YYModelMeta`，其数据结构如下：\n```\n@interface _YYModelMeta : NSObject {\n    @package\n    YYClassInfo *_classInfo;\n    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.\n    NSDictionary *_mapper;\n    /// Array<_YYModelPropertyMeta>, all property meta of this model.\n    NSArray *_allPropertyMetas;\n    /// Array<_YYModelPropertyMeta>, property meta which is mapped to a key path.\n    NSArray *_keyPathPropertyMetas;\n    /// Array<_YYModelPropertyMeta>, property meta which is mapped to multi keys.\n    NSArray *_multiKeysPropertyMetas;\n    /// The number of mapped key (and key path), same to _mapper.count.\n    NSUInteger _keyMappedCount;\n    /// Model class type.\n    YYEncodingNSType _nsType;\n    \n    BOOL _hasCustomWillTransformFromDictionary;\n    BOOL _hasCustomTransformFromDictionary;\n    BOOL _hasCustomTransformToDictionary;\n    BOOL _hasCustomClassFromDictionary;\n}\n@end\n```\n> Objective-C中有4种访问控制符：\n> @private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。\n> @package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。\n> @protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。\n> @public（公共访问权限）：成员可以在任意地方访问。\n\n`_YYModelMeta`存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给`_YYModelPropertyMeta`处理。\n```\n@interface _YYModelPropertyMeta : NSObject {\n    @package\n    NSString *_name;             ///< property's name\n    YYEncodingType _type;        ///< property's type\n    YYEncodingNSType _nsType;    ///< property's Foundation type\n    BOOL _isCNumber;             ///< is c number type\n    Class _cls;                  ///< property's class, or nil\n    Class _genericCls;           ///< container's generic class, or nil if threr's no generic class\n    SEL _getter;                 ///< getter, or nil if the instances cannot respond\n    SEL _setter;                 ///< setter, or nil if the instances cannot respond\n    BOOL _isKVCCompatible;       ///< YES if it can access with key-value coding\n    BOOL _isStructAvailableForKeyedArchiver; ///< YES if the struct can encoded with keyed archiver/unarchiver\n    BOOL _hasCustomClassFromDictionary; ///< class/generic class implements +modelCustomClassForDictionary:\n    \n    /*\n     property->key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil\n     property->keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil\n     property->keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)\n     */\n    NSString *_mappedToKey;      ///< the key mapped to\n    NSArray *_mappedToKeyPath;   ///< the key path mapped to (nil if the name is not key path)\n    NSArray *_mappedToKeyArray;  ///< the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys)\n    YYClassPropertyInfo *_info;  ///< property's info\n    _YYModelPropertyMeta *_next; ///< next meta if there are multiple properties mapped to the same key.\n}\n@end\n\n@interface YYClassPropertyInfo : NSObject\n@property (nonatomic, assign, readonly) objc_property_t property; ///< property's opaque struct\n@property (nonatomic, strong, readonly) NSString *name;           ///< property's name\n@property (nonatomic, assign, readonly) YYEncodingType type;      ///< property's type\n@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///< property's encoding value\n@property (nonatomic, strong, readonly) NSString *ivarName;       ///< property's ivar name\n@property (nullable, nonatomic, assign, readonly) Class cls;      ///< may be nil\n@property (nullable, nonatomic, strong, readonly) NSArray<NSString *> *protocols; ///< may nil\n@property (nonatomic, assign, readonly) SEL getter;               ///< getter (nonnull)\n@property (nonatomic, assign, readonly) SEL setter;               ///< setter (nonnull)\n@end\n```\n\n`YYClassInfo`则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。\n```\n@interface YYClassInfo : NSObject\n@property (nonatomic, assign, readonly) Class cls; ///< class object\n@property (nullable, nonatomic, assign, readonly) Class superCls; ///< super class object\n@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///< class's meta class object\n@property (nonatomic, readonly) BOOL isMeta; ///< whether this class is meta class\n@property (nonatomic, strong, readonly) NSString *name; ///< class name\n@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///< super class's class info\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassIvarInfo *> *ivarInfos; ///< ivars\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassMethodInfo *> *methodInfos; ///< methods\n@property (nullable, nonatomic, strong, readonly) NSDictionary<NSString *, YYClassPropertyInfo *> *propertyInfos; ///< properties\n\n- (void)setNeedUpdate;\n- (BOOL)needUpdate;\n+ (nullable instancetype)classInfoWithClass:(Class)cls;\n+ (nullable instancetype)classInfoWithClassName:(NSString *)className;\n@end\n```\n> ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。\n\n随后通过`+ (instancetype)metaWithClass:(Class)cls;`进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下：\n> 1. [CFMutableDictionaryRef](https://developer.apple.com/reference/corefoundation/cfmutabledictionary-rpl)是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要\n> 2. dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看[资料1](http://www.jianshu.com/p/a84c2bf0d77b)[资料2](http://blog.ibireme.com/2015/10/26/yycache/)\n> 3. 两个时间宏\n> #define DISPATCH_TIME_NOW (0ull)\n> #define DISPATCH_TIME_FOREVER (~0ull)\n> 0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数\n\n真正的初始化方法是`- (instancetype)initWithClass:(Class)cls;`，其流程如下：\n1. 获取YYClassInfo。\n2. 获取黑名单。\n3. 获取白名单。\n4. 获取用户自定义属性。\n5. 循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入`_allPropertyMetas`、`_keyPathPropertyMetas`、`_multiKeysPropertyMetas`。\n6. 设置属性映射mapper。\n\n至此已获取YYModel元类，包括key/value属性映射关系，回到`- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;`进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。\n```\nModelSetContext context = {0};\ncontext.modelMeta = (__bridge void *)(modelMeta);\ncontext.model = (__bridge void *)(self);\ncontext.dictionary = (__bridge void *)(dic);\n\nif (modelMeta->_keyMappedCount >= CFDictionaryGetCount((CFDictionaryRef)dic)) {\n    CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &context);\n    if (modelMeta->_keyPathPropertyMetas) {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_keyPathPropertyMetas,\n                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_keyPathPropertyMetas)),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n    if (modelMeta->_multiKeysPropertyMetas) {\n        CFArrayApplyFunction((CFArrayRef)modelMeta->_multiKeysPropertyMetas,\n                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta->_multiKeysPropertyMetas)),\n                             ModelSetWithPropertyMetaArrayFunction,\n                             &context);\n    }\n} else {\n    CFArrayApplyFunction((CFArrayRef)modelMeta->_allPropertyMetas,\n                         CFRangeMake(0, modelMeta->_keyMappedCount),\n                         ModelSetWithPropertyMetaArrayFunction,\n                         &context);\n}\n\ntypedef struct {\n    void *modelMeta;  ///< _YYModelMeta\n    void *model;      ///< id (self)\n    void *dictionary; ///< NSDictionary (json)\n} ModelSetContext;\n```\n> SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。\n> IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。\n> \n> KVC(key value coding)\n> KVC涉及以下4个方法\n```\n- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值\n- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值\n- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值\n- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值\n```\n> [iOS开发技巧系列---详解KVC](http://www.jianshu.com/p/45cbd324ea65)\n> \n> KVO(key value obeserveing)\n> KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。\n```\n- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;\n- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;\n```\n> [IOS 开发中的KVC 和KVO](http://www.jianshu.com/p/c1dd046d9ce2)\n\n扩展阅读：\n[看 YYModel 源码的一些收获](http://www.cocoachina.com/cms/wap.php?action=article&id=17874)\n> 性能优化Tip\n> 缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。\n> 查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。\n> 避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。\n> 避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。\n> 避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。\n> 遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。\n> 尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。\n> 减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。","slug":"开源库阅读笔记：YYKit-YYModel","published":1,"updated":"2019-03-11T09:32:29.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i1b000ynflwufx1ugt8","content":"<p>YYKit，作者ibireme，<a href=\"http://blog.ibireme.com\" target=\"_blank\" rel=\"noopener\">Blog</a>，<a href=\"https://github.com/ibireme/YYKit\" target=\"_blank\" rel=\"noopener\">YYKitDemo</a>。</p>\n<h1 id=\"YYModel\"><a href=\"#YYModel\" class=\"headerlink\" title=\"YYModel\"></a>YYModel</h1><p>YYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。<br>JSON解析过程如下：</p>\n<ol>\n<li>判空，获取class。</li>\n<li>若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。</li>\n<li>根据JSON转化Model。<br>自定义class属于扩展功能，先分析JSON转化Model这一主要功能。<a id=\"more\"></a>\n</li>\n</ol>\n<h2 id=\"JSON转化Model\"><a href=\"#JSON转化Model\" class=\"headerlink\" title=\"JSON转化Model\"></a>JSON转化Model</h2><p>此功能核心方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)modelSetWithDictionary:(NSDictionary *)dic &#123;</span><br><span class=\"line\">    if (!dic || dic == (id)kCFNull) return NO;</span><br><span class=\"line\">    if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br><span class=\"line\">    if (modelMeta-&gt;_keyMappedCount == 0) return NO;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class=\"line\">        dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic];</span><br><span class=\"line\">        if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ModelSetContext context = &#123;0&#125;;</span><br><span class=\"line\">    context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class=\"line\">    context.model = (__bridge void *)(self);</span><br><span class=\"line\">    context.dictionary = (__bridge void *)(dic);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class=\"line\">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class=\"line\">        if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class=\"line\">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class=\"line\">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class=\"line\">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                                 &amp;context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class=\"line\">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class=\"line\">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class=\"line\">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                                 &amp;context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class=\"line\">        return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。</p>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>首先对传入的NSDictionary进行了判空处理，如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!dic || dic == (id)kCFNull) return NO;</span><br><span class=\"line\">if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？<br>iOS中的空值类型有5种：nil\\Nil\\NULL\\NSNull\\kCFNull。<br>nil：指向一个实例对象的空指针。<br>Nil：指向一个类的空指针。<br>NULL：定义基本类型、C类型的空指针。<br>NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。<br>kCFNull：NSNull的单例。<br>参考：<a href=\"http://www.jianshu.com/p/3aaefb3bcf73\" target=\"_blank\" rel=\"noopener\">IOS 空值 nil Nil NULL NSNull kCFNull</a></p>\n</blockquote>\n<h3 id=\"获取元类\"><a href=\"#获取元类\" class=\"headerlink\" title=\"获取元类\"></a>获取元类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br></pre></td></tr></table></figure>\n<p>要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。</p>\n<blockquote>\n<p><img src=\"/对象模型图.png\" alt=\"对象模型图\"><br>可参考：<a href=\"http://blog.ibireme.com/2013/11/25/objc-object/\" target=\"_blank\" rel=\"noopener\">Objective-C中的类和对象</a><br><a href=\"http://www.jianshu.com/p/ae5c32708bc6\" target=\"_blank\" rel=\"noopener\">object_getClass(obj)与[obj class]的区别</a><br>测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    TestClass *obj1 = [[TestClass alloc] init];</span><br><span class=\"line\">    TestClass *obj2 = [[TestClass alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls1 = object_getClass(obj1);</span><br><span class=\"line\">    Class cls2 = object_getClass(cls1);</span><br><span class=\"line\">    Class cls3 = object_getClass(cls2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, obj1, obj1);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls1, cls1);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls2, cls2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls3, cls3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls4 = [obj1 class];</span><br><span class=\"line\">    Class cls5 = [cls4 class];</span><br><span class=\"line\">    Class cls6 = [cls5 class];</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, obj2, obj2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls4, cls4);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls5, cls5);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls6, cls6);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls7 = [cls1 class];</span><br><span class=\"line\">    Class cls8 = [cls2 class];</span><br><span class=\"line\">    Class cls9 = [cls3 class];</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls7, cls7);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls8, cls8);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls9, cls9);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。<br>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007f90&gt;, 0x174007f90</span><br><span class=\"line\">2017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x100101258</span><br><span class=\"line\">2017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8</span><br><span class=\"line\">2017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007fa0&gt;, 0x174007fa0</span><br><span class=\"line\">2017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x100101258</span><br><span class=\"line\">2017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。</p>\n</blockquote>\n<p>然后我们来看看YYModel中的元类<code>_YYModelMeta</code>，其数据结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface _YYModelMeta : NSObject &#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    YYClassInfo *_classInfo;</span><br><span class=\"line\">    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.</span><br><span class=\"line\">    NSDictionary *_mapper;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, all property meta of this model.</span><br><span class=\"line\">    NSArray *_allPropertyMetas;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to a key path.</span><br><span class=\"line\">    NSArray *_keyPathPropertyMetas;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to multi keys.</span><br><span class=\"line\">    NSArray *_multiKeysPropertyMetas;</span><br><span class=\"line\">    /// The number of mapped key (and key path), same to _mapper.count.</span><br><span class=\"line\">    NSUInteger _keyMappedCount;</span><br><span class=\"line\">    /// Model class type.</span><br><span class=\"line\">    YYEncodingNSType _nsType;</span><br><span class=\"line\">    </span><br><span class=\"line\">    BOOL _hasCustomWillTransformFromDictionary;</span><br><span class=\"line\">    BOOL _hasCustomTransformFromDictionary;</span><br><span class=\"line\">    BOOL _hasCustomTransformToDictionary;</span><br><span class=\"line\">    BOOL _hasCustomClassFromDictionary;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Objective-C中有4种访问控制符：<br>@private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。<br>@package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。<br>@protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。<br>@public（公共访问权限）：成员可以在任意地方访问。</p>\n</blockquote>\n<p><code>_YYModelMeta</code>存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给<code>_YYModelPropertyMeta</code>处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface _YYModelPropertyMeta : NSObject &#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    NSString *_name;             ///&lt; property&apos;s name</span><br><span class=\"line\">    YYEncodingType _type;        ///&lt; property&apos;s type</span><br><span class=\"line\">    YYEncodingNSType _nsType;    ///&lt; property&apos;s Foundation type</span><br><span class=\"line\">    BOOL _isCNumber;             ///&lt; is c number type</span><br><span class=\"line\">    Class _cls;                  ///&lt; property&apos;s class, or nil</span><br><span class=\"line\">    Class _genericCls;           ///&lt; container&apos;s generic class, or nil if threr&apos;s no generic class</span><br><span class=\"line\">    SEL _getter;                 ///&lt; getter, or nil if the instances cannot respond</span><br><span class=\"line\">    SEL _setter;                 ///&lt; setter, or nil if the instances cannot respond</span><br><span class=\"line\">    BOOL _isKVCCompatible;       ///&lt; YES if it can access with key-value coding</span><br><span class=\"line\">    BOOL _isStructAvailableForKeyedArchiver; ///&lt; YES if the struct can encoded with keyed archiver/unarchiver</span><br><span class=\"line\">    BOOL _hasCustomClassFromDictionary; ///&lt; class/generic class implements +modelCustomClassForDictionary:</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     property-&gt;key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil</span><br><span class=\"line\">     property-&gt;keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil</span><br><span class=\"line\">     property-&gt;keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    NSString *_mappedToKey;      ///&lt; the key mapped to</span><br><span class=\"line\">    NSArray *_mappedToKeyPath;   ///&lt; the key path mapped to (nil if the name is not key path)</span><br><span class=\"line\">    NSArray *_mappedToKeyArray;  ///&lt; the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys)</span><br><span class=\"line\">    YYClassPropertyInfo *_info;  ///&lt; property&apos;s info</span><br><span class=\"line\">    _YYModelPropertyMeta *_next; ///&lt; next meta if there are multiple properties mapped to the same key.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface YYClassPropertyInfo : NSObject</span><br><span class=\"line\">@property (nonatomic, assign, readonly) objc_property_t property; ///&lt; property&apos;s opaque struct</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *name;           ///&lt; property&apos;s name</span><br><span class=\"line\">@property (nonatomic, assign, readonly) YYEncodingType type;      ///&lt; property&apos;s type</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///&lt; property&apos;s encoding value</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *ivarName;       ///&lt; property&apos;s ivar name</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class cls;      ///&lt; may be nil</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols; ///&lt; may nil</span><br><span class=\"line\">@property (nonatomic, assign, readonly) SEL getter;               ///&lt; getter (nonnull)</span><br><span class=\"line\">@property (nonatomic, assign, readonly) SEL setter;               ///&lt; setter (nonnull)</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p><code>YYClassInfo</code>则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface YYClassInfo : NSObject</span><br><span class=\"line\">@property (nonatomic, assign, readonly) Class cls; ///&lt; class object</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class superCls; ///&lt; super class object</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///&lt; class&apos;s meta class object</span><br><span class=\"line\">@property (nonatomic, readonly) BOOL isMeta; ///&lt; whether this class is meta class</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *name; ///&lt; class name</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///&lt; super class&apos;s class info</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos; ///&lt; ivars</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos; ///&lt; methods</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos; ///&lt; properties</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setNeedUpdate;</span><br><span class=\"line\">- (BOOL)needUpdate;</span><br><span class=\"line\">+ (nullable instancetype)classInfoWithClass:(Class)cls;</span><br><span class=\"line\">+ (nullable instancetype)classInfoWithClassName:(NSString *)className;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。</p>\n</blockquote>\n<p>随后通过<code>+ (instancetype)metaWithClass:(Class)cls;</code>进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下：</p>\n<blockquote>\n<ol>\n<li><a href=\"https://developer.apple.com/reference/corefoundation/cfmutabledictionary-rpl\" target=\"_blank\" rel=\"noopener\">CFMutableDictionaryRef</a>是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要</li>\n<li>dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看<a href=\"http://www.jianshu.com/p/a84c2bf0d77b\" target=\"_blank\" rel=\"noopener\">资料1</a><a href=\"http://blog.ibireme.com/2015/10/26/yycache/\" target=\"_blank\" rel=\"noopener\">资料2</a></li>\n<li>两个时间宏<br>#define DISPATCH_TIME_NOW (0ull)<br>#define DISPATCH_TIME_FOREVER (~0ull)<br>0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数</li>\n</ol>\n</blockquote>\n<p>真正的初始化方法是<code>- (instancetype)initWithClass:(Class)cls;</code>，其流程如下：</p>\n<ol>\n<li>获取YYClassInfo。</li>\n<li>获取黑名单。</li>\n<li>获取白名单。</li>\n<li>获取用户自定义属性。</li>\n<li>循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入<code>_allPropertyMetas</code>、<code>_keyPathPropertyMetas</code>、<code>_multiKeysPropertyMetas</code>。</li>\n<li>设置属性映射mapper。</li>\n</ol>\n<p>至此已获取YYModel元类，包括key/value属性映射关系，回到<code>- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;</code>进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ModelSetContext context = &#123;0&#125;;</span><br><span class=\"line\">context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class=\"line\">context.model = (__bridge void *)(self);</span><br><span class=\"line\">context.dictionary = (__bridge void *)(dic);</span><br><span class=\"line\"></span><br><span class=\"line\">if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class=\"line\">    CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class=\"line\">    if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class=\"line\">                         CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class=\"line\">                         ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                         &amp;context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    void *modelMeta;  ///&lt; _YYModelMeta</span><br><span class=\"line\">    void *model;      ///&lt; id (self)</span><br><span class=\"line\">    void *dictionary; ///&lt; NSDictionary (json)</span><br><span class=\"line\">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。<br>IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。</p>\n<p>KVC(key value coding)<br>KVC涉及以下4个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值</span><br><span class=\"line\">- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值</span><br><span class=\"line\">- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值</span><br><span class=\"line\">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/45cbd324ea65\" target=\"_blank\" rel=\"noopener\">iOS开发技巧系列—详解KVC</a></p>\n<p>KVO(key value obeserveing)<br>KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class=\"line\">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/c1dd046d9ce2\" target=\"_blank\" rel=\"noopener\">IOS 开发中的KVC 和KVO</a></p>\n</blockquote>\n<p>扩展阅读：<br><a href=\"http://www.cocoachina.com/cms/wap.php?action=article&amp;id=17874\" target=\"_blank\" rel=\"noopener\">看 YYModel 源码的一些收获</a></p>\n<blockquote>\n<p>性能优化Tip<br>缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。<br>查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。<br>避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。<br>避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。<br>避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。<br>遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。<br>尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。<br>减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>YYKit，作者ibireme，<a href=\"http://blog.ibireme.com\" target=\"_blank\" rel=\"noopener\">Blog</a>，<a href=\"https://github.com/ibireme/YYKit\" target=\"_blank\" rel=\"noopener\">YYKitDemo</a>。</p>\n<h1 id=\"YYModel\"><a href=\"#YYModel\" class=\"headerlink\" title=\"YYModel\"></a>YYModel</h1><p>YYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。<br>JSON解析过程如下：</p>\n<ol>\n<li>判空，获取class。</li>\n<li>若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。</li>\n<li>根据JSON转化Model。<br>自定义class属于扩展功能，先分析JSON转化Model这一主要功能。","more":"</li>\n</ol>\n<h2 id=\"JSON转化Model\"><a href=\"#JSON转化Model\" class=\"headerlink\" title=\"JSON转化Model\"></a>JSON转化Model</h2><p>此功能核心方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)modelSetWithDictionary:(NSDictionary *)dic &#123;</span><br><span class=\"line\">    if (!dic || dic == (id)kCFNull) return NO;</span><br><span class=\"line\">    if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br><span class=\"line\">    if (modelMeta-&gt;_keyMappedCount == 0) return NO;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class=\"line\">        dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic];</span><br><span class=\"line\">        if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ModelSetContext context = &#123;0&#125;;</span><br><span class=\"line\">    context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class=\"line\">    context.model = (__bridge void *)(self);</span><br><span class=\"line\">    context.dictionary = (__bridge void *)(dic);</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class=\"line\">        CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class=\"line\">        if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class=\"line\">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class=\"line\">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class=\"line\">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                                 &amp;context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class=\"line\">            CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class=\"line\">                                 CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class=\"line\">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                                 &amp;context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class=\"line\">        return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。</p>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><p>首先对传入的NSDictionary进行了判空处理，如下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!dic || dic == (id)kCFNull) return NO;</span><br><span class=\"line\">if (![dic isKindOfClass:[NSDictionary class]]) return NO;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？<br>iOS中的空值类型有5种：nil\\Nil\\NULL\\NSNull\\kCFNull。<br>nil：指向一个实例对象的空指针。<br>Nil：指向一个类的空指针。<br>NULL：定义基本类型、C类型的空指针。<br>NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。<br>kCFNull：NSNull的单例。<br>参考：<a href=\"http://www.jianshu.com/p/3aaefb3bcf73\" target=\"_blank\" rel=\"noopener\">IOS 空值 nil Nil NULL NSNull kCFNull</a></p>\n</blockquote>\n<h3 id=\"获取元类\"><a href=\"#获取元类\" class=\"headerlink\" title=\"获取元类\"></a>获取元类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)];</span><br></pre></td></tr></table></figure>\n<p>要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。</p>\n<blockquote>\n<p><img src=\"/对象模型图.png\" alt=\"对象模型图\"><br>可参考：<a href=\"http://blog.ibireme.com/2013/11/25/objc-object/\" target=\"_blank\" rel=\"noopener\">Objective-C中的类和对象</a><br><a href=\"http://www.jianshu.com/p/ae5c32708bc6\" target=\"_blank\" rel=\"noopener\">object_getClass(obj)与[obj class]的区别</a><br>测试代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    TestClass *obj1 = [[TestClass alloc] init];</span><br><span class=\"line\">    TestClass *obj2 = [[TestClass alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls1 = object_getClass(obj1);</span><br><span class=\"line\">    Class cls2 = object_getClass(cls1);</span><br><span class=\"line\">    Class cls3 = object_getClass(cls2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, obj1, obj1);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls1, cls1);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls2, cls2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls3, cls3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls4 = [obj1 class];</span><br><span class=\"line\">    Class cls5 = [cls4 class];</span><br><span class=\"line\">    Class cls6 = [cls5 class];</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, obj2, obj2);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls4, cls4);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls5, cls5);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls6, cls6);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class cls7 = [cls1 class];</span><br><span class=\"line\">    Class cls8 = [cls2 class];</span><br><span class=\"line\">    Class cls9 = [cls3 class];</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls7, cls7);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls8, cls8);</span><br><span class=\"line\">    NSLog(@&quot;%@, %p&quot;, cls9, cls9);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。<br>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007f90&gt;, 0x174007f90</span><br><span class=\"line\">2017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x100101258</span><br><span class=\"line\">2017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8</span><br><span class=\"line\">2017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007fa0&gt;, 0x174007fa0</span><br><span class=\"line\">2017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x100101280</span><br><span class=\"line\">2017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x100101258</span><br><span class=\"line\">2017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。</p>\n</blockquote>\n<p>然后我们来看看YYModel中的元类<code>_YYModelMeta</code>，其数据结构如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface _YYModelMeta : NSObject &#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    YYClassInfo *_classInfo;</span><br><span class=\"line\">    /// Key:mapped key and key path, Value:_YYModelPropertyMeta.</span><br><span class=\"line\">    NSDictionary *_mapper;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, all property meta of this model.</span><br><span class=\"line\">    NSArray *_allPropertyMetas;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to a key path.</span><br><span class=\"line\">    NSArray *_keyPathPropertyMetas;</span><br><span class=\"line\">    /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to multi keys.</span><br><span class=\"line\">    NSArray *_multiKeysPropertyMetas;</span><br><span class=\"line\">    /// The number of mapped key (and key path), same to _mapper.count.</span><br><span class=\"line\">    NSUInteger _keyMappedCount;</span><br><span class=\"line\">    /// Model class type.</span><br><span class=\"line\">    YYEncodingNSType _nsType;</span><br><span class=\"line\">    </span><br><span class=\"line\">    BOOL _hasCustomWillTransformFromDictionary;</span><br><span class=\"line\">    BOOL _hasCustomTransformFromDictionary;</span><br><span class=\"line\">    BOOL _hasCustomTransformToDictionary;</span><br><span class=\"line\">    BOOL _hasCustomClassFromDictionary;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Objective-C中有4种访问控制符：<br>@private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。<br>@package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。<br>@protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。<br>@public（公共访问权限）：成员可以在任意地方访问。</p>\n</blockquote>\n<p><code>_YYModelMeta</code>存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给<code>_YYModelPropertyMeta</code>处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface _YYModelPropertyMeta : NSObject &#123;</span><br><span class=\"line\">    @package</span><br><span class=\"line\">    NSString *_name;             ///&lt; property&apos;s name</span><br><span class=\"line\">    YYEncodingType _type;        ///&lt; property&apos;s type</span><br><span class=\"line\">    YYEncodingNSType _nsType;    ///&lt; property&apos;s Foundation type</span><br><span class=\"line\">    BOOL _isCNumber;             ///&lt; is c number type</span><br><span class=\"line\">    Class _cls;                  ///&lt; property&apos;s class, or nil</span><br><span class=\"line\">    Class _genericCls;           ///&lt; container&apos;s generic class, or nil if threr&apos;s no generic class</span><br><span class=\"line\">    SEL _getter;                 ///&lt; getter, or nil if the instances cannot respond</span><br><span class=\"line\">    SEL _setter;                 ///&lt; setter, or nil if the instances cannot respond</span><br><span class=\"line\">    BOOL _isKVCCompatible;       ///&lt; YES if it can access with key-value coding</span><br><span class=\"line\">    BOOL _isStructAvailableForKeyedArchiver; ///&lt; YES if the struct can encoded with keyed archiver/unarchiver</span><br><span class=\"line\">    BOOL _hasCustomClassFromDictionary; ///&lt; class/generic class implements +modelCustomClassForDictionary:</span><br><span class=\"line\">    </span><br><span class=\"line\">    /*</span><br><span class=\"line\">     property-&gt;key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil</span><br><span class=\"line\">     property-&gt;keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil</span><br><span class=\"line\">     property-&gt;keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)</span><br><span class=\"line\">     */</span><br><span class=\"line\">    NSString *_mappedToKey;      ///&lt; the key mapped to</span><br><span class=\"line\">    NSArray *_mappedToKeyPath;   ///&lt; the key path mapped to (nil if the name is not key path)</span><br><span class=\"line\">    NSArray *_mappedToKeyArray;  ///&lt; the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys)</span><br><span class=\"line\">    YYClassPropertyInfo *_info;  ///&lt; property&apos;s info</span><br><span class=\"line\">    _YYModelPropertyMeta *_next; ///&lt; next meta if there are multiple properties mapped to the same key.</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@interface YYClassPropertyInfo : NSObject</span><br><span class=\"line\">@property (nonatomic, assign, readonly) objc_property_t property; ///&lt; property&apos;s opaque struct</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *name;           ///&lt; property&apos;s name</span><br><span class=\"line\">@property (nonatomic, assign, readonly) YYEncodingType type;      ///&lt; property&apos;s type</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *typeEncoding;   ///&lt; property&apos;s encoding value</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *ivarName;       ///&lt; property&apos;s ivar name</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class cls;      ///&lt; may be nil</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols; ///&lt; may nil</span><br><span class=\"line\">@property (nonatomic, assign, readonly) SEL getter;               ///&lt; getter (nonnull)</span><br><span class=\"line\">@property (nonatomic, assign, readonly) SEL setter;               ///&lt; setter (nonnull)</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p><code>YYClassInfo</code>则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface YYClassInfo : NSObject</span><br><span class=\"line\">@property (nonatomic, assign, readonly) Class cls; ///&lt; class object</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class superCls; ///&lt; super class object</span><br><span class=\"line\">@property (nullable, nonatomic, assign, readonly) Class metaCls;  ///&lt; class&apos;s meta class object</span><br><span class=\"line\">@property (nonatomic, readonly) BOOL isMeta; ///&lt; whether this class is meta class</span><br><span class=\"line\">@property (nonatomic, strong, readonly) NSString *name; ///&lt; class name</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///&lt; super class&apos;s class info</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos; ///&lt; ivars</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos; ///&lt; methods</span><br><span class=\"line\">@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos; ///&lt; properties</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)setNeedUpdate;</span><br><span class=\"line\">- (BOOL)needUpdate;</span><br><span class=\"line\">+ (nullable instancetype)classInfoWithClass:(Class)cls;</span><br><span class=\"line\">+ (nullable instancetype)classInfoWithClassName:(NSString *)className;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。</p>\n</blockquote>\n<p>随后通过<code>+ (instancetype)metaWithClass:(Class)cls;</code>进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下：</p>\n<blockquote>\n<ol>\n<li><a href=\"https://developer.apple.com/reference/corefoundation/cfmutabledictionary-rpl\" target=\"_blank\" rel=\"noopener\">CFMutableDictionaryRef</a>是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要</li>\n<li>dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看<a href=\"http://www.jianshu.com/p/a84c2bf0d77b\" target=\"_blank\" rel=\"noopener\">资料1</a><a href=\"http://blog.ibireme.com/2015/10/26/yycache/\" target=\"_blank\" rel=\"noopener\">资料2</a></li>\n<li>两个时间宏<br>#define DISPATCH_TIME_NOW (0ull)<br>#define DISPATCH_TIME_FOREVER (~0ull)<br>0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数</li>\n</ol>\n</blockquote>\n<p>真正的初始化方法是<code>- (instancetype)initWithClass:(Class)cls;</code>，其流程如下：</p>\n<ol>\n<li>获取YYClassInfo。</li>\n<li>获取黑名单。</li>\n<li>获取白名单。</li>\n<li>获取用户自定义属性。</li>\n<li>循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入<code>_allPropertyMetas</code>、<code>_keyPathPropertyMetas</code>、<code>_multiKeysPropertyMetas</code>。</li>\n<li>设置属性映射mapper。</li>\n</ol>\n<p>至此已获取YYModel元类，包括key/value属性映射关系，回到<code>- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;</code>进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ModelSetContext context = &#123;0&#125;;</span><br><span class=\"line\">context.modelMeta = (__bridge void *)(modelMeta);</span><br><span class=\"line\">context.model = (__bridge void *)(self);</span><br><span class=\"line\">context.dictionary = (__bridge void *)(dic);</span><br><span class=\"line\"></span><br><span class=\"line\">if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123;</span><br><span class=\"line\">    CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class=\"line\">    if (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class=\"line\">        CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class=\"line\">                             CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class=\"line\">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                             &amp;context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas,</span><br><span class=\"line\">                         CFRangeMake(0, modelMeta-&gt;_keyMappedCount),</span><br><span class=\"line\">                         ModelSetWithPropertyMetaArrayFunction,</span><br><span class=\"line\">                         &amp;context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123;</span><br><span class=\"line\">    void *modelMeta;  ///&lt; _YYModelMeta</span><br><span class=\"line\">    void *model;      ///&lt; id (self)</span><br><span class=\"line\">    void *dictionary; ///&lt; NSDictionary (json)</span><br><span class=\"line\">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。<br>IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。</p>\n<p>KVC(key value coding)<br>KVC涉及以下4个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (nullable id)valueForKey:(NSString *)key;                          //直接通过Key来取值</span><br><span class=\"line\">- (void)setValue:(nullable id)value forKey:(NSString *)key;          //通过Key来设值</span><br><span class=\"line\">- (nullable id)valueForKeyPath:(NSString *)keyPath;                  //通过KeyPath来取值</span><br><span class=\"line\">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  //通过KeyPath来设值</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/45cbd324ea65\" target=\"_blank\" rel=\"noopener\">iOS开发技巧系列—详解KVC</a></p>\n<p>KVO(key value obeserveing)<br>KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class=\"line\">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/c1dd046d9ce2\" target=\"_blank\" rel=\"noopener\">IOS 开发中的KVC 和KVO</a></p>\n</blockquote>\n<p>扩展阅读：<br><a href=\"http://www.cocoachina.com/cms/wap.php?action=article&amp;id=17874\" target=\"_blank\" rel=\"noopener\">看 YYModel 源码的一些收获</a></p>\n<blockquote>\n<p>性能优化Tip<br>缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。<br>查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。<br>避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。<br>避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。<br>避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。<br>遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。<br>尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。<br>减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。</p>\n</blockquote>"},{"title":"配置：Sublime-Text3","date":"2016-09-21T03:09:54.000Z","_content":"# 快捷键（Eclipse风格）\nSublime Text -> Preferences -> Key Bindings - User\n```\n[\n    /**\n     * 代码格式化\n     */\n    { \"keys\": [\"command+r\"], \"command\": \"markdown_preview\", \"args\": { \"target\": \"browser\"} },\n    {\n        \"keys\": [\"alt+shift+f\"],\n        \"command\": \"reindent\"\n    },\n    /**\n     * json格式化\n     */\n    { \"keys\": [\"command+shift+x\"], \"command\": \"tidy_xml\" },\n    { \"keys\": [\"command+shift+j\"], \"command\": \"pretty_json\" }, \n    { \"keys\": [\"command+shift+m\"], \"command\": \"un_pretty_json\" },\n    /**\n     * 适配eclipse快捷键\n     */\n    { \"keys\": [\"alt+/\"], \"command\": \"auto_complete\" },\n    { \"keys\": [\"command+i\"], \"command\": \"reindent\" },\n    // 当前行和下面一行交互位置\n    { \"keys\": [\"alt+up\"], \"command\": \"swap_line_up\" },\n    { \"keys\": [\"alt+down\"], \"command\": \"swap_line_down\" },\n    // 复制当前行到上一行\n    { \"keys\": [\"command+alt+up\"], \"command\": \"duplicate_line\" },\n    // 复制当前行到下一行\n    { \"keys\": [\"command+alt+down\"], \"command\": \"duplicate_line\" },\n    // 删除整行\n    { \"keys\": [\"command+d\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/Default/Delete Line.sublime-macro\"} },\n    // 光标移动到指定行\n    { \"keys\": [\"command+l\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \":\"} },\n    // 快速定位到选中的文字\n    { \"keys\": [\"command+k\"], \"command\": \"find_under_expand_skip\" },\n    // { \"keys\": [\"command+shift+x\"], \"command\": \"swap_case\" },\n    { \"keys\": [\"command+shift+x\"], \"command\": \"upper_case\" },\n    { \"keys\": [\"command+shift+y\"], \"command\": \"lower_case\" },\n    // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后)\n    { \"keys\": [\"shift+enter\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/Default/Add Line.sublime-macro\"} },\n    // 定位到对于的匹配符(譬如{})(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)\n    { \"keys\": [\"command+p\"], \"command\": \"move_to\", \"args\": {\"to\": \"brackets\"} },\n    // outline\n    { \"keys\": [\"command+o\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \"@\"} },\n    // 当前文件中的关键字(方便快速查找内容)\n    { \"keys\": [\"command+alt+o\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \"#\"} },\n    // open resource\n    { \"keys\": [\"command+shift+r\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"show_files\": true} },\n    // 文件内查找/替换\n    { \"keys\": [\"command+f\"], \"command\": \"show_panel\", \"args\": {\"panel\": \"replace\"} },\n    // 全局查找/替换, 在查询结果中双击跳转到匹配位置\n    {\"keys\": [\"command+h\"], \"command\": \"show_panel\", \"args\": {\"panel\": \"find_in_files\"} },\n \n    // plugin配置\n    { \"keys\": [\"alt+a\"], \"command\": \"alignment\" },\n    {\"keys\": [\"command+shift+f\"], \"command\": \"js_format\"}\n]\n```\n<!-- more -->\n\n# Color Scheme\nMonokai\n\n# Package Control\n安装方法各版本不同，以最新搜索结果为准。\n## 常用插件\nMarkdown Preview\nMarkdown Editing\n[Pretty Json](https://github.com/dzhibas/SublimePrettyJson)\n(也可以在chrome浏览器中安装JSON Formatter插件)\n\n# 激活\n原则上支持正版XD。\n","source":"_posts/配置：Sublime-Text3.md","raw":"---\ntitle: 配置：Sublime-Text3\ndate: 2016-09-21 11:09:54\ncategories: 开发配置\ntags:\n    - 开发环境配置\n    - Sublime Text\n---\n# 快捷键（Eclipse风格）\nSublime Text -> Preferences -> Key Bindings - User\n```\n[\n    /**\n     * 代码格式化\n     */\n    { \"keys\": [\"command+r\"], \"command\": \"markdown_preview\", \"args\": { \"target\": \"browser\"} },\n    {\n        \"keys\": [\"alt+shift+f\"],\n        \"command\": \"reindent\"\n    },\n    /**\n     * json格式化\n     */\n    { \"keys\": [\"command+shift+x\"], \"command\": \"tidy_xml\" },\n    { \"keys\": [\"command+shift+j\"], \"command\": \"pretty_json\" }, \n    { \"keys\": [\"command+shift+m\"], \"command\": \"un_pretty_json\" },\n    /**\n     * 适配eclipse快捷键\n     */\n    { \"keys\": [\"alt+/\"], \"command\": \"auto_complete\" },\n    { \"keys\": [\"command+i\"], \"command\": \"reindent\" },\n    // 当前行和下面一行交互位置\n    { \"keys\": [\"alt+up\"], \"command\": \"swap_line_up\" },\n    { \"keys\": [\"alt+down\"], \"command\": \"swap_line_down\" },\n    // 复制当前行到上一行\n    { \"keys\": [\"command+alt+up\"], \"command\": \"duplicate_line\" },\n    // 复制当前行到下一行\n    { \"keys\": [\"command+alt+down\"], \"command\": \"duplicate_line\" },\n    // 删除整行\n    { \"keys\": [\"command+d\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/Default/Delete Line.sublime-macro\"} },\n    // 光标移动到指定行\n    { \"keys\": [\"command+l\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \":\"} },\n    // 快速定位到选中的文字\n    { \"keys\": [\"command+k\"], \"command\": \"find_under_expand_skip\" },\n    // { \"keys\": [\"command+shift+x\"], \"command\": \"swap_case\" },\n    { \"keys\": [\"command+shift+x\"], \"command\": \"upper_case\" },\n    { \"keys\": [\"command+shift+y\"], \"command\": \"lower_case\" },\n    // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后)\n    { \"keys\": [\"shift+enter\"], \"command\": \"run_macro_file\", \"args\": {\"file\": \"Packages/Default/Add Line.sublime-macro\"} },\n    // 定位到对于的匹配符(譬如{})(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)\n    { \"keys\": [\"command+p\"], \"command\": \"move_to\", \"args\": {\"to\": \"brackets\"} },\n    // outline\n    { \"keys\": [\"command+o\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \"@\"} },\n    // 当前文件中的关键字(方便快速查找内容)\n    { \"keys\": [\"command+alt+o\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"text\": \"#\"} },\n    // open resource\n    { \"keys\": [\"command+shift+r\"], \"command\": \"show_overlay\", \"args\": {\"overlay\": \"goto\", \"show_files\": true} },\n    // 文件内查找/替换\n    { \"keys\": [\"command+f\"], \"command\": \"show_panel\", \"args\": {\"panel\": \"replace\"} },\n    // 全局查找/替换, 在查询结果中双击跳转到匹配位置\n    {\"keys\": [\"command+h\"], \"command\": \"show_panel\", \"args\": {\"panel\": \"find_in_files\"} },\n \n    // plugin配置\n    { \"keys\": [\"alt+a\"], \"command\": \"alignment\" },\n    {\"keys\": [\"command+shift+f\"], \"command\": \"js_format\"}\n]\n```\n<!-- more -->\n\n# Color Scheme\nMonokai\n\n# Package Control\n安装方法各版本不同，以最新搜索结果为准。\n## 常用插件\nMarkdown Preview\nMarkdown Editing\n[Pretty Json](https://github.com/dzhibas/SublimePrettyJson)\n(也可以在chrome浏览器中安装JSON Formatter插件)\n\n# 激活\n原则上支持正版XD。\n","slug":"配置：Sublime-Text3","published":1,"updated":"2019-03-11T09:38:42.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i1c0010nflwifibgnaq","content":"<h1 id=\"快捷键（Eclipse风格）\"><a href=\"#快捷键（Eclipse风格）\" class=\"headerlink\" title=\"快捷键（Eclipse风格）\"></a>快捷键（Eclipse风格）</h1><p>Sublime Text -&gt; Preferences -&gt; Key Bindings - User<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 代码格式化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+r&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123; &quot;target&quot;: &quot;browser&quot;&#125; &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;keys&quot;: [&quot;alt+shift+f&quot;],</span><br><span class=\"line\">        &quot;command&quot;: &quot;reindent&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * json格式化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;tidy_xml&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;, </span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 适配eclipse快捷键</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;auto_complete&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+i&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;,</span><br><span class=\"line\">    // 当前行和下面一行交互位置</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;,</span><br><span class=\"line\">    // 复制当前行到上一行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+up&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;,</span><br><span class=\"line\">    // 复制当前行到下一行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+down&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;,</span><br><span class=\"line\">    // 删除整行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;,</span><br><span class=\"line\">    // 光标移动到指定行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+l&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;,</span><br><span class=\"line\">    // 快速定位到选中的文字</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+k&quot;], &quot;command&quot;: &quot;find_under_expand_skip&quot; &#125;,</span><br><span class=\"line\">    // &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;swap_case&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;upper_case&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+y&quot;], &quot;command&quot;: &quot;lower_case&quot; &#125;,</span><br><span class=\"line\">    // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;shift+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Add Line.sublime-macro&quot;&#125; &#125;,</span><br><span class=\"line\">    // 定位到对于的匹配符(譬如&#123;&#125;)(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+p&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;,</span><br><span class=\"line\">    // outline</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;@&quot;&#125; &#125;,</span><br><span class=\"line\">    // 当前文件中的关键字(方便快速查找内容)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;#&quot;&#125; &#125;,</span><br><span class=\"line\">    // open resource</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+r&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;show_files&quot;: true&#125; &#125;,</span><br><span class=\"line\">    // 文件内查找/替换</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;replace&quot;&#125; &#125;,</span><br><span class=\"line\">    // 全局查找/替换, 在查询结果中双击跳转到匹配位置</span><br><span class=\"line\">    &#123;&quot;keys&quot;: [&quot;command+h&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;find_in_files&quot;&#125; &#125;,</span><br><span class=\"line\"> </span><br><span class=\"line\">    // plugin配置</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+a&quot;], &quot;command&quot;: &quot;alignment&quot; &#125;,</span><br><span class=\"line\">    &#123;&quot;keys&quot;: [&quot;command+shift+f&quot;], &quot;command&quot;: &quot;js_format&quot;&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h1 id=\"Color-Scheme\"><a href=\"#Color-Scheme\" class=\"headerlink\" title=\"Color Scheme\"></a>Color Scheme</h1><p>Monokai</p>\n<h1 id=\"Package-Control\"><a href=\"#Package-Control\" class=\"headerlink\" title=\"Package Control\"></a>Package Control</h1><p>安装方法各版本不同，以最新搜索结果为准。</p>\n<h2 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h2><p>Markdown Preview<br>Markdown Editing<br><a href=\"https://github.com/dzhibas/SublimePrettyJson\" target=\"_blank\" rel=\"noopener\">Pretty Json</a><br>(也可以在chrome浏览器中安装JSON Formatter插件)</p>\n<h1 id=\"激活\"><a href=\"#激活\" class=\"headerlink\" title=\"激活\"></a>激活</h1><p>原则上支持正版XD。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"快捷键（Eclipse风格）\"><a href=\"#快捷键（Eclipse风格）\" class=\"headerlink\" title=\"快捷键（Eclipse风格）\"></a>快捷键（Eclipse风格）</h1><p>Sublime Text -&gt; Preferences -&gt; Key Bindings - User<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 代码格式化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+r&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123; &quot;target&quot;: &quot;browser&quot;&#125; &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &quot;keys&quot;: [&quot;alt+shift+f&quot;],</span><br><span class=\"line\">        &quot;command&quot;: &quot;reindent&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * json格式化</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;tidy_xml&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;, </span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;,</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 适配eclipse快捷键</span><br><span class=\"line\">     */</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;auto_complete&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+i&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;,</span><br><span class=\"line\">    // 当前行和下面一行交互位置</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;,</span><br><span class=\"line\">    // 复制当前行到上一行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+up&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;,</span><br><span class=\"line\">    // 复制当前行到下一行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+down&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;,</span><br><span class=\"line\">    // 删除整行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;,</span><br><span class=\"line\">    // 光标移动到指定行</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+l&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;,</span><br><span class=\"line\">    // 快速定位到选中的文字</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+k&quot;], &quot;command&quot;: &quot;find_under_expand_skip&quot; &#125;,</span><br><span class=\"line\">    // &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;swap_case&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;upper_case&quot; &#125;,</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+y&quot;], &quot;command&quot;: &quot;lower_case&quot; &#125;,</span><br><span class=\"line\">    // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;shift+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Add Line.sublime-macro&quot;&#125; &#125;,</span><br><span class=\"line\">    // 定位到对于的匹配符(譬如&#123;&#125;)(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+p&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;,</span><br><span class=\"line\">    // outline</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;@&quot;&#125; &#125;,</span><br><span class=\"line\">    // 当前文件中的关键字(方便快速查找内容)</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+alt+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;#&quot;&#125; &#125;,</span><br><span class=\"line\">    // open resource</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+shift+r&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;show_files&quot;: true&#125; &#125;,</span><br><span class=\"line\">    // 文件内查找/替换</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;command+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;replace&quot;&#125; &#125;,</span><br><span class=\"line\">    // 全局查找/替换, 在查询结果中双击跳转到匹配位置</span><br><span class=\"line\">    &#123;&quot;keys&quot;: [&quot;command+h&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;find_in_files&quot;&#125; &#125;,</span><br><span class=\"line\"> </span><br><span class=\"line\">    // plugin配置</span><br><span class=\"line\">    &#123; &quot;keys&quot;: [&quot;alt+a&quot;], &quot;command&quot;: &quot;alignment&quot; &#125;,</span><br><span class=\"line\">    &#123;&quot;keys&quot;: [&quot;command+shift+f&quot;], &quot;command&quot;: &quot;js_format&quot;&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>","more":"<h1 id=\"Color-Scheme\"><a href=\"#Color-Scheme\" class=\"headerlink\" title=\"Color Scheme\"></a>Color Scheme</h1><p>Monokai</p>\n<h1 id=\"Package-Control\"><a href=\"#Package-Control\" class=\"headerlink\" title=\"Package Control\"></a>Package Control</h1><p>安装方法各版本不同，以最新搜索结果为准。</p>\n<h2 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h2><p>Markdown Preview<br>Markdown Editing<br><a href=\"https://github.com/dzhibas/SublimePrettyJson\" target=\"_blank\" rel=\"noopener\">Pretty Json</a><br>(也可以在chrome浏览器中安装JSON Formatter插件)</p>\n<h1 id=\"激活\"><a href=\"#激活\" class=\"headerlink\" title=\"激活\"></a>激活</h1><p>原则上支持正版XD。</p>"},{"title":"配置：Xcode快捷键配置","date":"2016-09-21T02:12:12.000Z","_content":"部分内容来自：[简书：为Xcode添加删除当前行、复制当前行快捷键](http://www.jianshu.com/p/2ed2c7ac6d53?nomobile=yes) 感谢作者的分享。\n本文仅为记录个人的开发配置。\n\nXcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。\n有一些eclipse带过来的快捷键习惯该如何设置呢？\n<!-- more -->\n\n# 上下移动当前行\nXcode -> Preference -> Key Bindings -> Move Line Up & Move Line Down\n\n# 复制当前行\n## 修改权限\n```\nsudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n\nsudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/\n```\n## 添加快捷键\n```\nopen /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n```\n在`Insertions and Indentations`中添加`Duplicate Current Line` - `selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:`\n## 设置快捷键\n重启后\nXcode -> Preference -> Key Bindings -> Insertions and Indentations\n\n# 删除当前行\n## 添加快捷键\n```\nopen /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n```\n在`Deletions`中添加`Delete Current Line` - `deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:`\n## 设置快捷键\n重启后\nXcode -> Preference -> Key Bindings -> Delete Current Line\n","source":"_posts/配置：Xcode快捷键配置.md","raw":"---\ntitle: 配置：Xcode快捷键配置\ndate: 2016-09-21 10:12:12\ncategories: 开发配置\ntags:\n    - 开发环境配置\n    - Xcode\n---\n部分内容来自：[简书：为Xcode添加删除当前行、复制当前行快捷键](http://www.jianshu.com/p/2ed2c7ac6d53?nomobile=yes) 感谢作者的分享。\n本文仅为记录个人的开发配置。\n\nXcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。\n有一些eclipse带过来的快捷键习惯该如何设置呢？\n<!-- more -->\n\n# 上下移动当前行\nXcode -> Preference -> Key Bindings -> Move Line Up & Move Line Down\n\n# 复制当前行\n## 修改权限\n```\nsudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n\nsudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/\n```\n## 添加快捷键\n```\nopen /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n```\n在`Insertions and Indentations`中添加`Duplicate Current Line` - `selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:`\n## 设置快捷键\n重启后\nXcode -> Preference -> Key Bindings -> Insertions and Indentations\n\n# 删除当前行\n## 添加快捷键\n```\nopen /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist\n```\n在`Deletions`中添加`Delete Current Line` - `deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:`\n## 设置快捷键\n重启后\nXcode -> Preference -> Key Bindings -> Delete Current Line\n","slug":"配置：Xcode快捷键配置","published":1,"updated":"2019-03-11T09:32:50.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i1d0012nflwy9t3v0xu","content":"<p>部分内容来自：<a href=\"http://www.jianshu.com/p/2ed2c7ac6d53?nomobile=yes\" target=\"_blank\" rel=\"noopener\">简书：为Xcode添加删除当前行、复制当前行快捷键</a> 感谢作者的分享。<br>本文仅为记录个人的开发配置。</p>\n<p>Xcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。<br>有一些eclipse带过来的快捷键习惯该如何设置呢？<br><a id=\"more\"></a></p>\n<h1 id=\"上下移动当前行\"><a href=\"#上下移动当前行\" class=\"headerlink\" title=\"上下移动当前行\"></a>上下移动当前行</h1><p>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Move Line Up &amp; Move Line Down</p>\n<h1 id=\"复制当前行\"><a href=\"#复制当前行\" class=\"headerlink\" title=\"复制当前行\"></a>复制当前行</h1><h2 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加快捷键\"><a href=\"#添加快捷键\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure>\n<p>在<code>Insertions and Indentations</code>中添加<code>Duplicate Current Line</code> - <code>selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:</code></p>\n<h2 id=\"设置快捷键\"><a href=\"#设置快捷键\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h2><p>重启后<br>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Insertions and Indentations</p>\n<h1 id=\"删除当前行\"><a href=\"#删除当前行\" class=\"headerlink\" title=\"删除当前行\"></a>删除当前行</h1><h2 id=\"添加快捷键-1\"><a href=\"#添加快捷键-1\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure>\n<p>在<code>Deletions</code>中添加<code>Delete Current Line</code> - <code>deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:</code></p>\n<h2 id=\"设置快捷键-1\"><a href=\"#设置快捷键-1\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h2><p>重启后<br>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Delete Current Line</p>\n","site":{"data":{}},"excerpt":"<p>部分内容来自：<a href=\"http://www.jianshu.com/p/2ed2c7ac6d53?nomobile=yes\" target=\"_blank\" rel=\"noopener\">简书：为Xcode添加删除当前行、复制当前行快捷键</a> 感谢作者的分享。<br>本文仅为记录个人的开发配置。</p>\n<p>Xcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。<br>有一些eclipse带过来的快捷键习惯该如何设置呢？<br>","more":"</p>\n<h1 id=\"上下移动当前行\"><a href=\"#上下移动当前行\" class=\"headerlink\" title=\"上下移动当前行\"></a>上下移动当前行</h1><p>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Move Line Up &amp; Move Line Down</p>\n<h1 id=\"复制当前行\"><a href=\"#复制当前行\" class=\"headerlink\" title=\"复制当前行\"></a>复制当前行</h1><h2 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br><span class=\"line\"></span><br><span class=\"line\">sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/</span><br></pre></td></tr></table></figure>\n<h2 id=\"添加快捷键\"><a href=\"#添加快捷键\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure>\n<p>在<code>Insertions and Indentations</code>中添加<code>Duplicate Current Line</code> - <code>selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:</code></p>\n<h2 id=\"设置快捷键\"><a href=\"#设置快捷键\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h2><p>重启后<br>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Insertions and Indentations</p>\n<h1 id=\"删除当前行\"><a href=\"#删除当前行\" class=\"headerlink\" title=\"删除当前行\"></a>删除当前行</h1><h2 id=\"添加快捷键-1\"><a href=\"#添加快捷键-1\" class=\"headerlink\" title=\"添加快捷键\"></a>添加快捷键</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure>\n<p>在<code>Deletions</code>中添加<code>Delete Current Line</code> - <code>deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:</code></p>\n<h2 id=\"设置快捷键-1\"><a href=\"#设置快捷键-1\" class=\"headerlink\" title=\"设置快捷键\"></a>设置快捷键</h2><p>重启后<br>Xcode -&gt; Preference -&gt; Key Bindings -&gt; Delete Current Line</p>"},{"title":"配置：Vim-Git-SVN","date":"2016-09-21T02:57:19.000Z","_content":"# bash\n`vim /etc/profile`，添加如下\n```\n# base\nalias ll=\"ls -la\"\n```\n\n# Vim\n`vim /etc/profile`，添加`export TERM=xterm`。\n\n## 样式\n`vim ~/.vimrc`，配置如下\n```\nsyntax on\nset tabstop=4\nset softtabstop=4\nset shiftwidth=4\nset autoindent\nset cindent\nset cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,>1s,=1s,:1s\n\nif &term==\"xterm\"\nset t_Co=8\nset t_Sb=^[[4%dm\nset t_Sf=^[[3%dm\nendif\n```\n<!-- more -->\n\n## 命令\n[vim命令大全](http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html)\n\n# Git\n## alias\n```\nvim ~/.gitconfig\n```\n```\n[alias]\n    co = checkout\n    ad = add\n    aa = add -A\n    au = add -u\n    ci = commit\n    ca = commit -a\n    st = status\n    pl = pull\n    pr = pull --rebase\n    ps = push\n    dt = difftool\n    l = log --stat\n    cp = cherry-pick\n    b = branch\n    lg = log --stat\n    lgp = log --stat -p\n    lgg = log --graph\n    lgga = log --graph --decorate --all\n    lgm = log --graph --max-count=10\n    lo = log --oneline --decorate\n    lol = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n    lola = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all\n    log = log --oneline --decorate --graph\n    loga = log --oneline --decorate --graph --all\n```\n\np.s.\n```\n# 三种add命令的区别\n1.  git add -A   保存所有的修改\n2.  git add .     保存新的添加和修改，但是不包括删除\n3.  git add -u   保存修改和删除，但是不包括新建文件\n\n# 查看命令帮助\ngit xxx -h\n```\n\n## 添加中文支持\nbash中输入`git config --global core.quotepath false`（已使用UTF-8字符集）。\n\n## ignore\n`vim ~/.gitignore_global`\n添加\n```\n*~\n.DS_Store\n# Xcode\n#\n# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore\n\n## Build generated\n#build/\nDerivedData/\n\n## Various settings\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\nxcuserdata/\n*.xcuserdatad\n\n## Other\n*.moved-aside\n*.xcuserstate\n\n## Obj-C/Swift specific\n*.hmap\n*.ipa\n*.dSYM.zip\n*.dSYM\n\n# CocoaPods\n#\n# We recommend against adding the Pods directory to your .gitignore. However\n# you should judge for yourself, the pros and cons are mentioned at:\n# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control\n#\n# Pods/\n\n# Carthage\n#\n# Add this line if you want to avoid checking in source code from Carthage dependencies.\n# Carthage/Checkouts\n\nCarthage/Build\n\n# fastlane\n#\n# It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the \n# screenshots whenever they are needed.\n# For more information about the recommended setup visit:\n# https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.md\n\nfastlane/report.xml\nfastlane/Preview.html\nfastlane/screenshots\nfastlane/test_output\n\n# Code Injection\n#\n# After new code Injection tools there's a generated folder /iOSInjectionProject\n# https://github.com/johnno1962/injectionforxcode\n\niOSInjectionProject/\n```\n\nGerrit审查模式配置\n切换到相应的git库目录下，执行`git config remote.origin.push refs/heads/*:refs/for/*`命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。\n\np.s.\n删除误提交的xcuserdata\n```\n// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。\ngit rm -r -n --cached  */src/\\*\n\n// 删除文件的版本控制\ngit rm -r --cached  */src/\\*      \n```\n\n# SVN\n`vim /etc/profile`，添加`export SVN_EDITOR=vim`。\n全局和局部参数配置用户信息，略。","source":"_posts/配置：Vim-Git-SVN.md","raw":"---\ntitle: 配置：Vim-Git-SVN\ndate: 2016-09-21 10:57:19\ncategories: 开发配置\ntags:\n    - 开发环境配置\n    - bash\n    - Vim\n    - Git\n    - SVN\n---\n# bash\n`vim /etc/profile`，添加如下\n```\n# base\nalias ll=\"ls -la\"\n```\n\n# Vim\n`vim /etc/profile`，添加`export TERM=xterm`。\n\n## 样式\n`vim ~/.vimrc`，配置如下\n```\nsyntax on\nset tabstop=4\nset softtabstop=4\nset shiftwidth=4\nset autoindent\nset cindent\nset cinoptions={0,1s,t0,n-2,p2s,(03s,=.5s,>1s,=1s,:1s\n\nif &term==\"xterm\"\nset t_Co=8\nset t_Sb=^[[4%dm\nset t_Sf=^[[3%dm\nendif\n```\n<!-- more -->\n\n## 命令\n[vim命令大全](http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html)\n\n# Git\n## alias\n```\nvim ~/.gitconfig\n```\n```\n[alias]\n    co = checkout\n    ad = add\n    aa = add -A\n    au = add -u\n    ci = commit\n    ca = commit -a\n    st = status\n    pl = pull\n    pr = pull --rebase\n    ps = push\n    dt = difftool\n    l = log --stat\n    cp = cherry-pick\n    b = branch\n    lg = log --stat\n    lgp = log --stat -p\n    lgg = log --graph\n    lgga = log --graph --decorate --all\n    lgm = log --graph --max-count=10\n    lo = log --oneline --decorate\n    lol = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n    lola = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --all\n    log = log --oneline --decorate --graph\n    loga = log --oneline --decorate --graph --all\n```\n\np.s.\n```\n# 三种add命令的区别\n1.  git add -A   保存所有的修改\n2.  git add .     保存新的添加和修改，但是不包括删除\n3.  git add -u   保存修改和删除，但是不包括新建文件\n\n# 查看命令帮助\ngit xxx -h\n```\n\n## 添加中文支持\nbash中输入`git config --global core.quotepath false`（已使用UTF-8字符集）。\n\n## ignore\n`vim ~/.gitignore_global`\n添加\n```\n*~\n.DS_Store\n# Xcode\n#\n# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore\n\n## Build generated\n#build/\nDerivedData/\n\n## Various settings\n*.pbxuser\n!default.pbxuser\n*.mode1v3\n!default.mode1v3\n*.mode2v3\n!default.mode2v3\n*.perspectivev3\n!default.perspectivev3\nxcuserdata/\n*.xcuserdatad\n\n## Other\n*.moved-aside\n*.xcuserstate\n\n## Obj-C/Swift specific\n*.hmap\n*.ipa\n*.dSYM.zip\n*.dSYM\n\n# CocoaPods\n#\n# We recommend against adding the Pods directory to your .gitignore. However\n# you should judge for yourself, the pros and cons are mentioned at:\n# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control\n#\n# Pods/\n\n# Carthage\n#\n# Add this line if you want to avoid checking in source code from Carthage dependencies.\n# Carthage/Checkouts\n\nCarthage/Build\n\n# fastlane\n#\n# It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the \n# screenshots whenever they are needed.\n# For more information about the recommended setup visit:\n# https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.md\n\nfastlane/report.xml\nfastlane/Preview.html\nfastlane/screenshots\nfastlane/test_output\n\n# Code Injection\n#\n# After new code Injection tools there's a generated folder /iOSInjectionProject\n# https://github.com/johnno1962/injectionforxcode\n\niOSInjectionProject/\n```\n\nGerrit审查模式配置\n切换到相应的git库目录下，执行`git config remote.origin.push refs/heads/*:refs/for/*`命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。\n\np.s.\n删除误提交的xcuserdata\n```\n// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。\ngit rm -r -n --cached  */src/\\*\n\n// 删除文件的版本控制\ngit rm -r --cached  */src/\\*      \n```\n\n# SVN\n`vim /etc/profile`，添加`export SVN_EDITOR=vim`。\n全局和局部参数配置用户信息，略。","slug":"配置：Vim-Git-SVN","published":1,"updated":"2019-03-11T09:32:46.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i1e0017nflwda1y6i64","content":"<h1 id=\"bash\"><a href=\"#bash\" class=\"headerlink\" title=\"bash\"></a>bash</h1><p><code>vim /etc/profile</code>，添加如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># base</span><br><span class=\"line\">alias ll=&quot;ls -la&quot;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h1><p><code>vim /etc/profile</code>，添加<code>export TERM=xterm</code>。</p>\n<h2 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h2><p><code>vim ~/.vimrc</code>，配置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax on</span><br><span class=\"line\">set tabstop=4</span><br><span class=\"line\">set softtabstop=4</span><br><span class=\"line\">set shiftwidth=4</span><br><span class=\"line\">set autoindent</span><br><span class=\"line\">set cindent</span><br><span class=\"line\">set cinoptions=&#123;0,1s,t0,n-2,p2s,(03s,=.5s,&gt;1s,=1s,:1s</span><br><span class=\"line\"></span><br><span class=\"line\">if &amp;term==&quot;xterm&quot;</span><br><span class=\"line\">set t_Co=8</span><br><span class=\"line\">set t_Sb=^[[4%dm</span><br><span class=\"line\">set t_Sf=^[[3%dm</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p><a href=\"http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html\" target=\"_blank\" rel=\"noopener\">vim命令大全</a></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h2 id=\"alias\"><a href=\"#alias\" class=\"headerlink\" title=\"alias\"></a>alias</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.gitconfig</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[alias]</span><br><span class=\"line\">    co = checkout</span><br><span class=\"line\">    ad = add</span><br><span class=\"line\">    aa = add -A</span><br><span class=\"line\">    au = add -u</span><br><span class=\"line\">    ci = commit</span><br><span class=\"line\">    ca = commit -a</span><br><span class=\"line\">    st = status</span><br><span class=\"line\">    pl = pull</span><br><span class=\"line\">    pr = pull --rebase</span><br><span class=\"line\">    ps = push</span><br><span class=\"line\">    dt = difftool</span><br><span class=\"line\">    l = log --stat</span><br><span class=\"line\">    cp = cherry-pick</span><br><span class=\"line\">    b = branch</span><br><span class=\"line\">    lg = log --stat</span><br><span class=\"line\">    lgp = log --stat -p</span><br><span class=\"line\">    lgg = log --graph</span><br><span class=\"line\">    lgga = log --graph --decorate --all</span><br><span class=\"line\">    lgm = log --graph --max-count=10</span><br><span class=\"line\">    lo = log --oneline --decorate</span><br><span class=\"line\">    lol = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class=\"line\">    lola = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --all</span><br><span class=\"line\">    log = log --oneline --decorate --graph</span><br><span class=\"line\">    loga = log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure>\n<p>p.s.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 三种add命令的区别</span><br><span class=\"line\">1.  git add -A   保存所有的修改</span><br><span class=\"line\">2.  git add .     保存新的添加和修改，但是不包括删除</span><br><span class=\"line\">3.  git add -u   保存修改和删除，但是不包括新建文件</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看命令帮助</span><br><span class=\"line\">git xxx -h</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"添加中文支持\"><a href=\"#添加中文支持\" class=\"headerlink\" title=\"添加中文支持\"></a>添加中文支持</h2><p>bash中输入<code>git config --global core.quotepath false</code>（已使用UTF-8字符集）。</p>\n<h2 id=\"ignore\"><a href=\"#ignore\" class=\"headerlink\" title=\"ignore\"></a>ignore</h2><p><code>vim ~/.gitignore_global</code><br>添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*~</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\"># Xcode</span><br><span class=\"line\">#</span><br><span class=\"line\"># gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore</span><br><span class=\"line\"></span><br><span class=\"line\">## Build generated</span><br><span class=\"line\">#build/</span><br><span class=\"line\">DerivedData/</span><br><span class=\"line\"></span><br><span class=\"line\">## Various settings</span><br><span class=\"line\">*.pbxuser</span><br><span class=\"line\">!default.pbxuser</span><br><span class=\"line\">*.mode1v3</span><br><span class=\"line\">!default.mode1v3</span><br><span class=\"line\">*.mode2v3</span><br><span class=\"line\">!default.mode2v3</span><br><span class=\"line\">*.perspectivev3</span><br><span class=\"line\">!default.perspectivev3</span><br><span class=\"line\">xcuserdata/</span><br><span class=\"line\">*.xcuserdatad</span><br><span class=\"line\"></span><br><span class=\"line\">## Other</span><br><span class=\"line\">*.moved-aside</span><br><span class=\"line\">*.xcuserstate</span><br><span class=\"line\"></span><br><span class=\"line\">## Obj-C/Swift specific</span><br><span class=\"line\">*.hmap</span><br><span class=\"line\">*.ipa</span><br><span class=\"line\">*.dSYM.zip</span><br><span class=\"line\">*.dSYM</span><br><span class=\"line\"></span><br><span class=\"line\"># CocoaPods</span><br><span class=\"line\">#</span><br><span class=\"line\"># We recommend against adding the Pods directory to your .gitignore. However</span><br><span class=\"line\"># you should judge for yourself, the pros and cons are mentioned at:</span><br><span class=\"line\"># https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control</span><br><span class=\"line\">#</span><br><span class=\"line\"># Pods/</span><br><span class=\"line\"></span><br><span class=\"line\"># Carthage</span><br><span class=\"line\">#</span><br><span class=\"line\"># Add this line if you want to avoid checking in source code from Carthage dependencies.</span><br><span class=\"line\"># Carthage/Checkouts</span><br><span class=\"line\"></span><br><span class=\"line\">Carthage/Build</span><br><span class=\"line\"></span><br><span class=\"line\"># fastlane</span><br><span class=\"line\">#</span><br><span class=\"line\"># It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the </span><br><span class=\"line\"># screenshots whenever they are needed.</span><br><span class=\"line\"># For more information about the recommended setup visit:</span><br><span class=\"line\"># https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.md</span><br><span class=\"line\"></span><br><span class=\"line\">fastlane/report.xml</span><br><span class=\"line\">fastlane/Preview.html</span><br><span class=\"line\">fastlane/screenshots</span><br><span class=\"line\">fastlane/test_output</span><br><span class=\"line\"></span><br><span class=\"line\"># Code Injection</span><br><span class=\"line\">#</span><br><span class=\"line\"># After new code Injection tools there&apos;s a generated folder /iOSInjectionProject</span><br><span class=\"line\"># https://github.com/johnno1962/injectionforxcode</span><br><span class=\"line\"></span><br><span class=\"line\">iOSInjectionProject/</span><br></pre></td></tr></table></figure></p>\n<p>Gerrit审查模式配置<br>切换到相应的git库目录下，执行<code>git config remote.origin.push refs/heads/*:refs/for/*</code>命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。</p>\n<p>p.s.<br>删除误提交的xcuserdata<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span><br><span class=\"line\">git rm -r -n --cached  */src/\\*</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除文件的版本控制</span><br><span class=\"line\">git rm -r --cached  */src/\\*</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"SVN\"><a href=\"#SVN\" class=\"headerlink\" title=\"SVN\"></a>SVN</h1><p><code>vim /etc/profile</code>，添加<code>export SVN_EDITOR=vim</code>。<br>全局和局部参数配置用户信息，略。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"bash\"><a href=\"#bash\" class=\"headerlink\" title=\"bash\"></a>bash</h1><p><code>vim /etc/profile</code>，添加如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># base</span><br><span class=\"line\">alias ll=&quot;ls -la&quot;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h1><p><code>vim /etc/profile</code>，添加<code>export TERM=xterm</code>。</p>\n<h2 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h2><p><code>vim ~/.vimrc</code>，配置如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax on</span><br><span class=\"line\">set tabstop=4</span><br><span class=\"line\">set softtabstop=4</span><br><span class=\"line\">set shiftwidth=4</span><br><span class=\"line\">set autoindent</span><br><span class=\"line\">set cindent</span><br><span class=\"line\">set cinoptions=&#123;0,1s,t0,n-2,p2s,(03s,=.5s,&gt;1s,=1s,:1s</span><br><span class=\"line\"></span><br><span class=\"line\">if &amp;term==&quot;xterm&quot;</span><br><span class=\"line\">set t_Co=8</span><br><span class=\"line\">set t_Sb=^[[4%dm</span><br><span class=\"line\">set t_Sf=^[[3%dm</span><br><span class=\"line\">endif</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p><a href=\"http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html\" target=\"_blank\" rel=\"noopener\">vim命令大全</a></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h2 id=\"alias\"><a href=\"#alias\" class=\"headerlink\" title=\"alias\"></a>alias</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim ~/.gitconfig</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[alias]</span><br><span class=\"line\">    co = checkout</span><br><span class=\"line\">    ad = add</span><br><span class=\"line\">    aa = add -A</span><br><span class=\"line\">    au = add -u</span><br><span class=\"line\">    ci = commit</span><br><span class=\"line\">    ca = commit -a</span><br><span class=\"line\">    st = status</span><br><span class=\"line\">    pl = pull</span><br><span class=\"line\">    pr = pull --rebase</span><br><span class=\"line\">    ps = push</span><br><span class=\"line\">    dt = difftool</span><br><span class=\"line\">    l = log --stat</span><br><span class=\"line\">    cp = cherry-pick</span><br><span class=\"line\">    b = branch</span><br><span class=\"line\">    lg = log --stat</span><br><span class=\"line\">    lgp = log --stat -p</span><br><span class=\"line\">    lgg = log --graph</span><br><span class=\"line\">    lgga = log --graph --decorate --all</span><br><span class=\"line\">    lgm = log --graph --max-count=10</span><br><span class=\"line\">    lo = log --oneline --decorate</span><br><span class=\"line\">    lol = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit</span><br><span class=\"line\">    lola = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --all</span><br><span class=\"line\">    log = log --oneline --decorate --graph</span><br><span class=\"line\">    loga = log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure>\n<p>p.s.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 三种add命令的区别</span><br><span class=\"line\">1.  git add -A   保存所有的修改</span><br><span class=\"line\">2.  git add .     保存新的添加和修改，但是不包括删除</span><br><span class=\"line\">3.  git add -u   保存修改和删除，但是不包括新建文件</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看命令帮助</span><br><span class=\"line\">git xxx -h</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"添加中文支持\"><a href=\"#添加中文支持\" class=\"headerlink\" title=\"添加中文支持\"></a>添加中文支持</h2><p>bash中输入<code>git config --global core.quotepath false</code>（已使用UTF-8字符集）。</p>\n<h2 id=\"ignore\"><a href=\"#ignore\" class=\"headerlink\" title=\"ignore\"></a>ignore</h2><p><code>vim ~/.gitignore_global</code><br>添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*~</span><br><span class=\"line\">.DS_Store</span><br><span class=\"line\"># Xcode</span><br><span class=\"line\">#</span><br><span class=\"line\"># gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore</span><br><span class=\"line\"></span><br><span class=\"line\">## Build generated</span><br><span class=\"line\">#build/</span><br><span class=\"line\">DerivedData/</span><br><span class=\"line\"></span><br><span class=\"line\">## Various settings</span><br><span class=\"line\">*.pbxuser</span><br><span class=\"line\">!default.pbxuser</span><br><span class=\"line\">*.mode1v3</span><br><span class=\"line\">!default.mode1v3</span><br><span class=\"line\">*.mode2v3</span><br><span class=\"line\">!default.mode2v3</span><br><span class=\"line\">*.perspectivev3</span><br><span class=\"line\">!default.perspectivev3</span><br><span class=\"line\">xcuserdata/</span><br><span class=\"line\">*.xcuserdatad</span><br><span class=\"line\"></span><br><span class=\"line\">## Other</span><br><span class=\"line\">*.moved-aside</span><br><span class=\"line\">*.xcuserstate</span><br><span class=\"line\"></span><br><span class=\"line\">## Obj-C/Swift specific</span><br><span class=\"line\">*.hmap</span><br><span class=\"line\">*.ipa</span><br><span class=\"line\">*.dSYM.zip</span><br><span class=\"line\">*.dSYM</span><br><span class=\"line\"></span><br><span class=\"line\"># CocoaPods</span><br><span class=\"line\">#</span><br><span class=\"line\"># We recommend against adding the Pods directory to your .gitignore. However</span><br><span class=\"line\"># you should judge for yourself, the pros and cons are mentioned at:</span><br><span class=\"line\"># https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control</span><br><span class=\"line\">#</span><br><span class=\"line\"># Pods/</span><br><span class=\"line\"></span><br><span class=\"line\"># Carthage</span><br><span class=\"line\">#</span><br><span class=\"line\"># Add this line if you want to avoid checking in source code from Carthage dependencies.</span><br><span class=\"line\"># Carthage/Checkouts</span><br><span class=\"line\"></span><br><span class=\"line\">Carthage/Build</span><br><span class=\"line\"></span><br><span class=\"line\"># fastlane</span><br><span class=\"line\">#</span><br><span class=\"line\"># It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the </span><br><span class=\"line\"># screenshots whenever they are needed.</span><br><span class=\"line\"># For more information about the recommended setup visit:</span><br><span class=\"line\"># https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.md</span><br><span class=\"line\"></span><br><span class=\"line\">fastlane/report.xml</span><br><span class=\"line\">fastlane/Preview.html</span><br><span class=\"line\">fastlane/screenshots</span><br><span class=\"line\">fastlane/test_output</span><br><span class=\"line\"></span><br><span class=\"line\"># Code Injection</span><br><span class=\"line\">#</span><br><span class=\"line\"># After new code Injection tools there&apos;s a generated folder /iOSInjectionProject</span><br><span class=\"line\"># https://github.com/johnno1962/injectionforxcode</span><br><span class=\"line\"></span><br><span class=\"line\">iOSInjectionProject/</span><br></pre></td></tr></table></figure></p>\n<p>Gerrit审查模式配置<br>切换到相应的git库目录下，执行<code>git config remote.origin.push refs/heads/*:refs/for/*</code>命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。</p>\n<p>p.s.<br>删除误提交的xcuserdata<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span><br><span class=\"line\">git rm -r -n --cached  */src/\\*</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除文件的版本控制</span><br><span class=\"line\">git rm -r --cached  */src/\\*</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"SVN\"><a href=\"#SVN\" class=\"headerlink\" title=\"SVN\"></a>SVN</h1><p><code>vim /etc/profile</code>，添加<code>export SVN_EDITOR=vim</code>。<br>全局和局部参数配置用户信息，略。</p>"},{"title":"配置：迁移hexo","date":"2016-09-02T16:21:26.000Z","_content":"\nBlog托管在github，拉取代码后。\n- 下载nodejs，[Node.js官网](https://nodejs.org/en/)\n- 安装hexo，`sudo npm install -g hexo`\n- 保留原有deploy配置，执行`sudo npm install hexo-deployer-git --save`\n- 安装server，`sudo npm install hexo-server`\n<!-- more -->\n\n如发生github pages init错误，删除.deploy_git文件\n\ntheme中配置`_config.yml`文件，将被墙资源改为cdn资源。\n另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。\n目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。\n\n记录NEXT theme中一个bug：\npost_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。\n```\n  // 旧方法存在bug，无法选中指定toc\n  // $('.post-toc a').on('click', function (e) {\n  //   e.preventDefault();\n  //   var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));\n  //   var offset = $(targetSelector).offset().top;\n\n  //   hasVelocity ?\n  //     html.velocity('stop').velocity('scroll', {\n  //       offset: offset  + 'px',\n  //       mobileHA: false\n  //     }) :\n  //     $('html, body').stop().animate({\n  //       scrollTop: offset\n  //     }, 500);\n  // });\n```\n修改如下：\n```\n  $('.post-toc a').on('click', function (e) {\n    e.preventDefault();\n    $('html, body').animate({\n        scrollTop: $( $.attr(this, 'href') ).offset().top\n    }, 500);\n  });\n```\n\n入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。","source":"_posts/配置：迁移hexo.md","raw":"---\ntitle: 配置：迁移hexo\ndate: 2016-09-03 00:21:26\ncategories: 开发配置\ntags:\n    - hexo\n---\n\nBlog托管在github，拉取代码后。\n- 下载nodejs，[Node.js官网](https://nodejs.org/en/)\n- 安装hexo，`sudo npm install -g hexo`\n- 保留原有deploy配置，执行`sudo npm install hexo-deployer-git --save`\n- 安装server，`sudo npm install hexo-server`\n<!-- more -->\n\n如发生github pages init错误，删除.deploy_git文件\n\ntheme中配置`_config.yml`文件，将被墙资源改为cdn资源。\n另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。\n目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。\n\n记录NEXT theme中一个bug：\npost_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。\n```\n  // 旧方法存在bug，无法选中指定toc\n  // $('.post-toc a').on('click', function (e) {\n  //   e.preventDefault();\n  //   var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));\n  //   var offset = $(targetSelector).offset().top;\n\n  //   hasVelocity ?\n  //     html.velocity('stop').velocity('scroll', {\n  //       offset: offset  + 'px',\n  //       mobileHA: false\n  //     }) :\n  //     $('html, body').stop().animate({\n  //       scrollTop: offset\n  //     }, 500);\n  // });\n```\n修改如下：\n```\n  $('.post-toc a').on('click', function (e) {\n    e.preventDefault();\n    $('html, body').animate({\n        scrollTop: $( $.attr(this, 'href') ).offset().top\n    }, 500);\n  });\n```\n\n入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。","slug":"配置：迁移hexo","published":1,"updated":"2019-03-11T09:32:37.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuav7i1f001anflwhstkgwry","content":"<p>Blog托管在github，拉取代码后。</p>\n<ul>\n<li>下载nodejs，<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js官网</a></li>\n<li>安装hexo，<code>sudo npm install -g hexo</code></li>\n<li>保留原有deploy配置，执行<code>sudo npm install hexo-deployer-git --save</code></li>\n<li>安装server，<code>sudo npm install hexo-server</code><a id=\"more\"></a>\n</li>\n</ul>\n<p>如发生github pages init错误，删除.deploy_git文件</p>\n<p>theme中配置<code>_config.yml</code>文件，将被墙资源改为cdn资源。<br>另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。<br>目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。</p>\n<p>记录NEXT theme中一个bug：<br>post_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 旧方法存在bug，无法选中指定toc</span><br><span class=\"line\">// $(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">//   e.preventDefault();</span><br><span class=\"line\">//   var targetSelector = NexT.utils.escapeSelector(this.getAttribute(&apos;href&apos;));</span><br><span class=\"line\">//   var offset = $(targetSelector).offset().top;</span><br><span class=\"line\"></span><br><span class=\"line\">//   hasVelocity ?</span><br><span class=\"line\">//     html.velocity(&apos;stop&apos;).velocity(&apos;scroll&apos;, &#123;</span><br><span class=\"line\">//       offset: offset  + &apos;px&apos;,</span><br><span class=\"line\">//       mobileHA: false</span><br><span class=\"line\">//     &#125;) :</span><br><span class=\"line\">//     $(&apos;html, body&apos;).stop().animate(&#123;</span><br><span class=\"line\">//       scrollTop: offset</span><br><span class=\"line\">//     &#125;, 500);</span><br><span class=\"line\">// &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">  e.preventDefault();</span><br><span class=\"line\">  $(&apos;html, body&apos;).animate(&#123;</span><br><span class=\"line\">      scrollTop: $( $.attr(this, &apos;href&apos;) ).offset().top</span><br><span class=\"line\">  &#125;, 500);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。</p>\n","site":{"data":{}},"excerpt":"<p>Blog托管在github，拉取代码后。</p>\n<ul>\n<li>下载nodejs，<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Node.js官网</a></li>\n<li>安装hexo，<code>sudo npm install -g hexo</code></li>\n<li>保留原有deploy配置，执行<code>sudo npm install hexo-deployer-git --save</code></li>\n<li>安装server，<code>sudo npm install hexo-server</code>","more":"</li>\n</ul>\n<p>如发生github pages init错误，删除.deploy_git文件</p>\n<p>theme中配置<code>_config.yml</code>文件，将被墙资源改为cdn资源。<br>另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。<br>目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。</p>\n<p>记录NEXT theme中一个bug：<br>post_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 旧方法存在bug，无法选中指定toc</span><br><span class=\"line\">// $(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">//   e.preventDefault();</span><br><span class=\"line\">//   var targetSelector = NexT.utils.escapeSelector(this.getAttribute(&apos;href&apos;));</span><br><span class=\"line\">//   var offset = $(targetSelector).offset().top;</span><br><span class=\"line\"></span><br><span class=\"line\">//   hasVelocity ?</span><br><span class=\"line\">//     html.velocity(&apos;stop&apos;).velocity(&apos;scroll&apos;, &#123;</span><br><span class=\"line\">//       offset: offset  + &apos;px&apos;,</span><br><span class=\"line\">//       mobileHA: false</span><br><span class=\"line\">//     &#125;) :</span><br><span class=\"line\">//     $(&apos;html, body&apos;).stop().animate(&#123;</span><br><span class=\"line\">//       scrollTop: offset</span><br><span class=\"line\">//     &#125;, 500);</span><br><span class=\"line\">// &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>修改如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;</span><br><span class=\"line\">  e.preventDefault();</span><br><span class=\"line\">  $(&apos;html, body&apos;).animate(&#123;</span><br><span class=\"line\">      scrollTop: $( $.attr(this, &apos;href&apos;) ).offset().top</span><br><span class=\"line\">  &#125;, 500);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。</p>"}],"PostAsset":[{"_id":"source/_posts/Objective-C基础知识小结/GCD03.png","slug":"GCD03.png","post":"cjuav7i0l0002nflwk37pzip9","modified":1,"renderable":0},{"_id":"source/_posts/Objective-C基础知识小结/调试02.png","slug":"调试02.png","post":"cjuav7i0l0002nflwk37pzip9","modified":1,"renderable":0},{"_id":"source/_posts/Objective-C基础知识小结/GCD02.png","slug":"GCD02.png","post":"cjuav7i0l0002nflwk37pzip9","modified":1,"renderable":0},{"_id":"source/_posts/开源库阅读笔记：YYKit-YYModel/对象模型图.png","post":"cjuav7i1b000ynflwufx1ugt8","slug":"对象模型图.png","modified":1,"renderable":1},{"_id":"source/_posts/Objective-C基础知识小结/GCD01.png","slug":"GCD01.png","post":"cjuav7i0l0002nflwk37pzip9","modified":1,"renderable":0},{"_id":"source/_posts/Objective-C基础知识小结/内存空间.png","post":"cjuav7i0l0002nflwk37pzip9","slug":"内存空间.png","modified":1,"renderable":1},{"_id":"source/_posts/Objective-C基础知识小结/调试01.png","post":"cjuav7i0l0002nflwk37pzip9","slug":"调试01.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjuav7i0q0006nflwz2gargpz","category_id":"cjuav7i0n0003nflwz0cj226o","_id":"cjuav7i0v000cnflwkx1kl83r"},{"post_id":"cjuav7i0h0000nflwxnqrdwqf","category_id":"cjuav7i0n0003nflwz0cj226o","_id":"cjuav7i0y000gnflwbtj3yf03"},{"post_id":"cjuav7i0r0007nflwfmk9nld0","category_id":"cjuav7i0n0003nflwz0cj226o","_id":"cjuav7i10000jnflwzr9pswlb"},{"post_id":"cjuav7i0t000anflw9ib185fz","category_id":"cjuav7i0n0003nflwz0cj226o","_id":"cjuav7i12000onflwb6lz9e9j"},{"post_id":"cjuav7i0l0002nflwk37pzip9","category_id":"cjuav7i0n0003nflwz0cj226o","_id":"cjuav7i16000rnflwyhnkwg58"},{"post_id":"cjuav7i0x000fnflwfxa6tx6a","category_id":"cjuav7i0w000dnflw616i1g9v","_id":"cjuav7i1a000unflwowsuljir"},{"post_id":"cjuav7i0p0005nflwgtsahtwi","category_id":"cjuav7i0w000dnflw616i1g9v","_id":"cjuav7i1b000wnflw0bx1p1ne"},{"post_id":"cjuav7i0z000inflwu25jki17","category_id":"cjuav7i0n0003nflwz0cj226o","_id":"cjuav7i1c000znflwghfqtriz"},{"post_id":"cjuav7i11000nnflwmc1q5kkb","category_id":"cjuav7i0n0003nflwz0cj226o","_id":"cjuav7i1d0011nflwrgs1nai1"},{"post_id":"cjuav7i0v000bnflw4pkrbgo8","category_id":"cjuav7i0w000dnflw616i1g9v","_id":"cjuav7i1e0013nflwsodipx2l"},{"post_id":"cjuav7i15000qnflwttr715f9","category_id":"cjuav7i0w000dnflw616i1g9v","_id":"cjuav7i1f0018nflwsi2oi0yr"},{"post_id":"cjuav7i19000tnflw81mntd9j","category_id":"cjuav7i0n0003nflwz0cj226o","_id":"cjuav7i1g001bnflwqlj7b6gh"},{"post_id":"cjuav7i1a000vnflwwvdz8alo","category_id":"cjuav7i0w000dnflw616i1g9v","_id":"cjuav7i1h001fnflwaivgsalq"},{"post_id":"cjuav7i1b000ynflwufx1ugt8","category_id":"cjuav7i0w000dnflw616i1g9v","_id":"cjuav7i1i001gnflwaas2bzsv"},{"post_id":"cjuav7i1f001anflwhstkgwry","category_id":"cjuav7i1e0015nflwmg36uoh9","_id":"cjuav7i1i001jnflwj0m28945"},{"post_id":"cjuav7i1c0010nflwifibgnaq","category_id":"cjuav7i1e0015nflwmg36uoh9","_id":"cjuav7i1i001knflwciuut20k"},{"post_id":"cjuav7i1d0012nflwy9t3v0xu","category_id":"cjuav7i1e0015nflwmg36uoh9","_id":"cjuav7i1j001mnflwqubofrne"},{"post_id":"cjuav7i1e0017nflwda1y6i64","category_id":"cjuav7i1e0015nflwmg36uoh9","_id":"cjuav7i1k001qnflw3kk9x2sl"}],"PostTag":[{"post_id":"cjuav7i0h0000nflwxnqrdwqf","tag_id":"cjuav7i0o0004nflw6w0a0jlo","_id":"cjuav7i0z000hnflwolh9nxqq"},{"post_id":"cjuav7i0h0000nflwxnqrdwqf","tag_id":"cjuav7i0s0009nflwzbbj4us8","_id":"cjuav7i10000knflwbmlf4gux"},{"post_id":"cjuav7i0l0002nflwk37pzip9","tag_id":"cjuav7i0o0004nflw6w0a0jlo","_id":"cjuav7i12000pnflwdzsh0lu7"},{"post_id":"cjuav7i0p0005nflwgtsahtwi","tag_id":"cjuav7i10000mnflwouzsenwl","_id":"cjuav7i1e0016nflwc1cgm2nv"},{"post_id":"cjuav7i0p0005nflwgtsahtwi","tag_id":"cjuav7i18000snflwmftk17zr","_id":"cjuav7i1f0019nflw5iwwbp7e"},{"post_id":"cjuav7i0p0005nflwgtsahtwi","tag_id":"cjuav7i1b000xnflwqpx9i2cw","_id":"cjuav7i1h001dnflw4t2kk79z"},{"post_id":"cjuav7i0q0006nflwz2gargpz","tag_id":"cjuav7i10000mnflwouzsenwl","_id":"cjuav7i1j001nnflwbr2104vb"},{"post_id":"cjuav7i0q0006nflwz2gargpz","tag_id":"cjuav7i1g001cnflwbstxkxqq","_id":"cjuav7i1j001onflwrtd83p1b"},{"post_id":"cjuav7i0q0006nflwz2gargpz","tag_id":"cjuav7i1i001hnflwe30nxh9s","_id":"cjuav7i1k001rnflwvy4vnlpu"},{"post_id":"cjuav7i0r0007nflwfmk9nld0","tag_id":"cjuav7i10000mnflwouzsenwl","_id":"cjuav7i1l001tnflwns4phans"},{"post_id":"cjuav7i0r0007nflwfmk9nld0","tag_id":"cjuav7i1k001pnflw0ghw48ag","_id":"cjuav7i1l001unflwvar6mi1x"},{"post_id":"cjuav7i0t000anflw9ib185fz","tag_id":"cjuav7i10000mnflwouzsenwl","_id":"cjuav7i1m001ynflwjb41p43q"},{"post_id":"cjuav7i0t000anflw9ib185fz","tag_id":"cjuav7i1l001vnflwk72zuyyv","_id":"cjuav7i1m001znflw9i44wbo1"},{"post_id":"cjuav7i0t000anflw9ib185fz","tag_id":"cjuav7i1m001wnflw6q54fepq","_id":"cjuav7i1n0021nflwu0j8cyhs"},{"post_id":"cjuav7i0v000bnflw4pkrbgo8","tag_id":"cjuav7i10000mnflwouzsenwl","_id":"cjuav7i1n0023nflw7egpcqyr"},{"post_id":"cjuav7i0v000bnflw4pkrbgo8","tag_id":"cjuav7i1n0020nflwrqct33oc","_id":"cjuav7i1n0024nflwg57ttzl5"},{"post_id":"cjuav7i0x000fnflwfxa6tx6a","tag_id":"cjuav7i1n0022nflwofe9suoo","_id":"cjuav7i1o0027nflwm7pbo108"},{"post_id":"cjuav7i0x000fnflwfxa6tx6a","tag_id":"cjuav7i1n0025nflwg0bsvoev","_id":"cjuav7i1o0028nflwxi7198nr"},{"post_id":"cjuav7i0z000inflwu25jki17","tag_id":"cjuav7i10000mnflwouzsenwl","_id":"cjuav7i1p002fnflw1xbv7q91"},{"post_id":"cjuav7i0z000inflwu25jki17","tag_id":"cjuav7i1o0029nflwdyswz81k","_id":"cjuav7i1p002gnflw35e3x32i"},{"post_id":"cjuav7i0z000inflwu25jki17","tag_id":"cjuav7i1o002anflw20dfikwh","_id":"cjuav7i1q002inflwuoz58hlb"},{"post_id":"cjuav7i0z000inflwu25jki17","tag_id":"cjuav7i1o002bnflwitp1i2mj","_id":"cjuav7i1q002jnflwxr4mx524"},{"post_id":"cjuav7i0z000inflwu25jki17","tag_id":"cjuav7i1p002cnflw98ixifo5","_id":"cjuav7i1q002lnflw4psp8nfh"},{"post_id":"cjuav7i0z000inflwu25jki17","tag_id":"cjuav7i1p002dnflwggirs875","_id":"cjuav7i1r002mnflws91iqf0n"},{"post_id":"cjuav7i11000nnflwmc1q5kkb","tag_id":"cjuav7i0o0004nflw6w0a0jlo","_id":"cjuav7i1r002pnflw8tumky8a"},{"post_id":"cjuav7i11000nnflwmc1q5kkb","tag_id":"cjuav7i1o002anflw20dfikwh","_id":"cjuav7i1r002qnflw0p6k1kac"},{"post_id":"cjuav7i11000nnflwmc1q5kkb","tag_id":"cjuav7i1p002hnflwphss1x15","_id":"cjuav7i1r002snflw83murzw4"},{"post_id":"cjuav7i11000nnflwmc1q5kkb","tag_id":"cjuav7i1p002cnflw98ixifo5","_id":"cjuav7i1s002tnflw7tsmmhx9"},{"post_id":"cjuav7i11000nnflwmc1q5kkb","tag_id":"cjuav7i1r002nnflwl1sx00tg","_id":"cjuav7i1s002vnflw7a7w9npv"},{"post_id":"cjuav7i15000qnflwttr715f9","tag_id":"cjuav7i1r002onflwg0cu5np1","_id":"cjuav7i1s002wnflwmd31rzus"},{"post_id":"cjuav7i15000qnflwttr715f9","tag_id":"cjuav7i10000mnflwouzsenwl","_id":"cjuav7i1s002ynflwwpyfy8wp"},{"post_id":"cjuav7i19000tnflw81mntd9j","tag_id":"cjuav7i0o0004nflw6w0a0jlo","_id":"cjuav7i1s002znflw1an5r0sd"},{"post_id":"cjuav7i19000tnflw81mntd9j","tag_id":"cjuav7i1r002rnflwm28je88f","_id":"cjuav7i1t0031nflw7b5jlwhk"},{"post_id":"cjuav7i1a000vnflwwvdz8alo","tag_id":"cjuav7i10000mnflwouzsenwl","_id":"cjuav7i1t0032nflw3b4vpjez"},{"post_id":"cjuav7i1a000vnflwwvdz8alo","tag_id":"cjuav7i1n0025nflwg0bsvoev","_id":"cjuav7i1t0033nflwdi3g4rb3"},{"post_id":"cjuav7i1b000ynflwufx1ugt8","tag_id":"cjuav7i1s002xnflw6nw4qt0p","_id":"cjuav7i1t0035nflw9h0wlm6b"},{"post_id":"cjuav7i1c0010nflwifibgnaq","tag_id":"cjuav7i1t0030nflw3x698nqm","_id":"cjuav7i1u0037nflwstatrq6p"},{"post_id":"cjuav7i1c0010nflwifibgnaq","tag_id":"cjuav7i1t0034nflwr2s3h85e","_id":"cjuav7i1u0038nflw03kydr2c"},{"post_id":"cjuav7i1d0012nflwy9t3v0xu","tag_id":"cjuav7i1t0030nflw3x698nqm","_id":"cjuav7i1u003bnflwhq5a6ite"},{"post_id":"cjuav7i1d0012nflwy9t3v0xu","tag_id":"cjuav7i1u0039nflwrtqh6mdp","_id":"cjuav7i1v003cnflw9fhc9ss6"},{"post_id":"cjuav7i1e0017nflwda1y6i64","tag_id":"cjuav7i1t0030nflw3x698nqm","_id":"cjuav7i1w003inflwt21bqd7w"},{"post_id":"cjuav7i1e0017nflwda1y6i64","tag_id":"cjuav7i1v003dnflw0tmw2t4z","_id":"cjuav7i1w003jnflw4gb8arsh"},{"post_id":"cjuav7i1e0017nflwda1y6i64","tag_id":"cjuav7i1v003enflwfdmaa19t","_id":"cjuav7i1w003knflw4srnwe8h"},{"post_id":"cjuav7i1e0017nflwda1y6i64","tag_id":"cjuav7i1v003fnflwk6qre198","_id":"cjuav7i1w003lnflwxzicauwp"},{"post_id":"cjuav7i1e0017nflwda1y6i64","tag_id":"cjuav7i1v003gnflw9ndpest7","_id":"cjuav7i1w003mnflwxgqw5umv"},{"post_id":"cjuav7i1f001anflwhstkgwry","tag_id":"cjuav7i1v003hnflwnibyxnwr","_id":"cjuav7i1w003nnflwmnon8rpg"}],"Tag":[{"name":"Objective-C","_id":"cjuav7i0o0004nflw6w0a0jlo"},{"name":"NSNotificationCenter","_id":"cjuav7i0s0009nflwzbbj4us8"},{"name":"iOS","_id":"cjuav7i10000mnflwouzsenwl"},{"name":"iOS 10","_id":"cjuav7i18000snflwmftk17zr"},{"name":"BUG","_id":"cjuav7i1b000xnflwqpx9i2cw"},{"name":"UIControl","_id":"cjuav7i1g001cnflwbstxkxqq"},{"name":"UIControlState","_id":"cjuav7i1i001hnflwe30nxh9s"},{"name":"UIViewController","_id":"cjuav7i1k001pnflw0ghw48ag"},{"name":"多线程","_id":"cjuav7i1l001vnflwk72zuyyv"},{"name":"GCD","_id":"cjuav7i1m001wnflw6q54fepq"},{"name":"warning","_id":"cjuav7i1n0020nflwrqct33oc"},{"name":"flutter","_id":"cjuav7i1n0022nflwofe9suoo"},{"name":"笔记","_id":"cjuav7i1n0025nflwg0bsvoev"},{"name":"程序设计基础","_id":"cjuav7i1o0029nflwdyswz81k"},{"name":"类","_id":"cjuav7i1o002anflw20dfikwh"},{"name":"对象","_id":"cjuav7i1o002bnflwitp1i2mj"},{"name":"方法","_id":"cjuav7i1p002cnflw98ixifo5"},{"name":"autoreleasepool","_id":"cjuav7i1p002dnflwggirs875"},{"name":"属性","_id":"cjuav7i1p002hnflwphss1x15"},{"name":"惰性实例化","_id":"cjuav7i1r002nnflwl1sx00tg"},{"name":"Flutter","_id":"cjuav7i1r002onflwg0cu5np1"},{"name":"内存泄漏","_id":"cjuav7i1r002rnflwm28je88f"},{"name":"开源库阅读笔记","_id":"cjuav7i1s002xnflw6nw4qt0p"},{"name":"开发环境配置","_id":"cjuav7i1t0030nflw3x698nqm"},{"name":"Sublime Text","_id":"cjuav7i1t0034nflwr2s3h85e"},{"name":"Xcode","_id":"cjuav7i1u0039nflwrtqh6mdp"},{"name":"bash","_id":"cjuav7i1v003dnflw0tmw2t4z"},{"name":"Vim","_id":"cjuav7i1v003enflwfdmaa19t"},{"name":"Git","_id":"cjuav7i1v003fnflwk6qre198"},{"name":"SVN","_id":"cjuav7i1v003gnflw9ndpest7"},{"name":"hexo","_id":"cjuav7i1v003hnflwnibyxnwr"}]}}