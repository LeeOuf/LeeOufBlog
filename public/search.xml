<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter：基础知识]]></title>
    <url>%2F2019%2F06%2F11%2FFlutter%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[编译模式JIT与AOT参考https://www.stephenw.cc/2018/07/30/flutter-compile-mode/ Flutter的架构 Framework：日常开发中直接接触的一层，包括UI组件、动画等。 Engine：基于C/C++的引擎，包括绘制引擎skia，Dart VM，Platform Channel。 Embedder：嵌入层，将Flutter嵌入到各平台。做原生Plugin、线程管理等。 线程模型 参考Flutter Engine线程管理与Dart Isolate机制Flutter Engine 线程模型 Widget生命周期 参考flutter中的生命周期]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime：ivar]]></title>
    <url>%2F2019%2F06%2F08%2FRuntime%EF%BC%9Aivar%2F</url>
    <content type="text"><![CDATA[ivar本质12345678910111213141516171819202122232425262728293031323334struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;struct objc_ivar &#123; char *ivar_name OBJC2_UNAVAILABLE; char *ivar_type OBJC2_UNAVAILABLE; int ivar_offset OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; objc_class中包含一个objc_ivar_list类型的ivars，管理了一个class中所有的成员变量，objc_ivar_list中包含ivar_count(ivar数量)、space(占用内存空间)、ivar_list(变长结构体)。objc_ivar中包含着ivar_name(ivar名)、ivar_type(ivar类型)、ivar_offset(基地址偏移字节)、space(占用内存空间)。 变长结构体要理解ivar_list要首先理解C语言中变长结构体的概念。变长结构体最后一个元素是一个没有元素的数组，因此我们可以动态开辟一个比结构体更大的空间，让数组指针指向这块空间。需要注意的是ivar_list与整个数据结构的内存地址是连续的，若是链表则是不连续的内存地址，连续内存有助于减少内存的碎片化，简化内存管理。 怎么添加ivar我们常说OC是一门运行时语言，它有一部分东西是runtime时才决定的，但我们在常规开发中，很少去动态添加ivar。动态添加ivar主要有两种方式： runtime动态关联对象。 class_addIvar，但是它只能在objc_allocateClassPair和objc_allocateClassPair两个函数之间调用，因此只有在runtime中动态创建class时才能动态添加ivar。关联对象原理其实关联对象的原理与我们在分类中添加一个全局变量的get\set方法类似，关联对象并没有直接加在class中，而是添加在AssociationsManager的hash map里与class关联了起来。可以参考iOS底层原理总结 - 关联对象实现原理]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>ivar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime：OC对象创建和销毁过程]]></title>
    <url>%2F2019%2F06%2F08%2FRuntime%EF%BC%9AOC%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[对象创建OC的创建对象，如[[MyClass alloc] init]，从消息发送角度说，就是给MyClass类对象发了两个消息，逐层lookup找到NSObject中的这两个方法，随后根据MyClass所需内存空间大小分配内存，然后把isa指针指向MyClass，最后将这两个方法加入缓存方法列表。那么再往底层看，Runtime具体做了些什么呢， + (id)alloc12345678910111213141516171819202122232425262728293031323334353637383940414243+ (id)alloc &#123; return _objc_rootAlloc(self);&#125;id _objc_rootAlloc(Class cls)&#123; return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/);&#125;// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.static ALWAYS_INLINE id callAlloc(Class cls, bool checkNil, bool allocWithZone=false)&#123; // 做类型检查 if (checkNil &amp;&amp; !cls) return nil;#if __OBJC2__ // 若没有实现allocWithZone方法 if (! cls-&gt;ISA()-&gt;hasCustomAWZ()) &#123; // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast&apos;s summary // canAllocFast默认返回false，应该是有一些类做了系统优化直接放到bits里了 if (cls-&gt;canAllocFast()) &#123; // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (!obj) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; &#125; else &#123; // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (!obj) return callBadAllocHandler(cls); return obj; &#125; &#125;#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];&#125; 可以看到我们最关心最常用的是class_createInstance方法，接下来看看这里面干了些啥。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354id class_createInstance(Class cls, size_t extraBytes)&#123; return _class_createInstanceFromZone(cls, extraBytes, nil);&#125;static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil)&#123; if (!cls) return nil; assert(cls-&gt;isRealized()); // Read class&apos;s info bits all at once for performance bool hasCxxCtor = cls-&gt;hasCxxCtor(); bool hasCxxDtor = cls-&gt;hasCxxDtor(); bool fast = cls-&gt;canAllocIndexed(); // 字节对齐，OC对象16字节对齐，一个对象最少16字节，isa 8字节。一个对象的内存地址从其第一个成员开始，也就是从isa指针开始。 size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; // 分配内存空间，创建对象 id obj; if (!UseGC &amp;&amp; !zone &amp;&amp; fast) &#123; obj = (id)calloc(1, size); if (!obj) return nil; obj-&gt;initInstanceIsa(cls, hasCxxDtor); &#125; else &#123;#if SUPPORT_GC if (UseGC) &#123; obj = (id)auto_zone_allocate_object(gc_zone, size, AUTO_OBJECT_SCANNED, 0, 1); &#125; else #endif if (zone) &#123; obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); &#125; else &#123; obj = (id)calloc(1, size); &#125; if (!obj) return nil; // Use non-indexed isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); &#125; if (cxxConstruct &amp;&amp; hasCxxCtor) &#123; obj = _objc_constructOrFree(obj, cls); &#125; return obj;&#125; + (id)init123456789101112131415// Replaced by CF (throws an NSException)+ (id)init &#123; return (id)self;&#125;- (id)init &#123; return _objc_rootInit(self);&#125;id _objc_rootInit(id obj)&#123; // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;&#125; 苹果并没有做什么事情，让人觉得其实只需要写[MyClass alloc]就好了，不过你要是真写出如下代码，是会抛出EXC_BAD_ACCESS (code=1, address=0x0)Crash的。1234self.testView = [UIView alloc];self.testView.frame = CGRectMake(50, 50, 100, 100);self.testView.backgroundColor = [UIColor blueColor];[self.view addSubview:self.testView]; 对象销毁1234567891011121314151617181920212223242526272829// Replaced by NSZombies// 应该是与debug时的僵尸对象有关，苹果可能是通过类似方法交换的黑魔法对dealloc做了一些事情。- (void)dealloc &#123; _objc_rootDealloc(self);&#125;void _objc_rootDealloc(id obj) &#123; assert(obj); obj-&gt;rootDealloc();&#125;inline void objc_object::rootDealloc() &#123; assert(!UseGC); if (isTaggedPointer()) return; // 如果没有weak引用 &amp;&amp; 没有关联对象 &amp;&amp; 没有c++析构 &amp;&amp; 没有side table借位 // 释放内存空间 if (isa.indexed &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc) &#123; assert(!sidetable_present()); free(this); &#125; else &#123; object_dispose((id)this); &#125;&#125; 再继续看object_dispose方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556id object_dispose(id obj) &#123; if (!obj) return nil; objc_destructInstance(obj); #if SUPPORT_GC if (UseGC) &#123; auto_zone_retain(gc_zone, obj); // gc free expects rc==1 &#125;#endif free(obj); return nil;&#125;/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory. * Calls C++ destructors.* Calls ARR ivar cleanup.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.* Be warned that GC DOES NOT CALL THIS. If you edit this, also edit finalize.* CoreFoundation and other clients do call this under GC.**********************************************************************/void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = !UseGC &amp;&amp; obj-&gt;hasAssociatedObjects(); bool dealloc = !UseGC; // This order is important. // 特别强调了这里的时序很重要 if (cxx) object_cxxDestruct(obj); // C++析构函数 if (assoc) _object_remove_assocations(obj); // 移除关联对象 if (dealloc) obj-&gt;clearDeallocating(); // 清理引用 &#125; return obj;&#125;inline void objc_object::clearDeallocating() &#123; if (!isa.indexed) &#123; // Slow path for raw pointer isa. // 清理sideTable中的引用计数表 sidetable_clearDeallocating(); &#125; else if (isa.weakly_referenced || isa.has_sidetable_rc) &#123; // Slow path for non-pointer isa with weak refs and/or side table data. // 清理sideTable中的weak表 clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125;]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>OC对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime：引用计数和Weak表]]></title>
    <url>%2F2019%2F06%2F07%2FRuntime%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%92%8CWeak%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[retainCount(引用计数)可以说是iOS内存管理的基础，当一个对象的retianCount为0时，没有任何地方引用，该对象的内存就会被释放。iOS进入ARC时代后RD们已经很少看和写retain release这些操作引用计数的代码，那么我们进入Runtime看看底层都做了些什么。 SideTables123static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);&#125; 在iOS中StripedMap管理着一个长度64(StripeCount)的数组，其本身是一个void * -&gt; T的map，通过indexForPointer方法找到对应的数组下标，在hash过程中通过取余StripeCount来防止数组越界。StripedMap的作用不仅限于管理SideTable，还可以用来管理spinlock_t(自旋锁)或其他包含着自旋锁的数据结构。 SideTable123456789101112131415161718192021222324struct SideTable &#123; spinlock_t slock; // 自旋锁，防止多线程访问冲突。 RefcountMap refcnts; // 引用计数Map weak_table_t weak_table; // 弱引用Map SideTable() &#123; memset(&amp;weak_table, 0, sizeof(weak_table)); &#125; ~SideTable() &#123; _objc_fatal(&quot;Do not delete SideTable.&quot;); &#125; void lock() &#123; slock.lock(); &#125; void unlock() &#123; slock.unlock(); &#125; bool trylock() &#123; return slock.trylock(); &#125; // Address-ordered lock discipline for a pair of side tables. template&lt;bool HaveOld, bool HaveNew&gt; static void lockTwo(SideTable *lock1, SideTable *lock2); template&lt;bool HaveOld, bool HaveNew&gt; static void unlockTwo(SideTable *lock1, SideTable *lock2);&#125;; spinlock_t自旋锁，是为了解决多线程资源互斥利用提出的一种机制。是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。优点：不会产生线程状态的切换，线程始终active，处于用户态。相对于其他的锁，会频繁在用户态和内核态之间切换，带来极大的性能损耗。 RefcountMap123// RefcountMap disguises its pointers because we // don&apos;t want the table to act as a root for `leaks`.typedef objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;,size_t,true&gt; RefcountMap; 这里的三个入参DisguisedPtr&lt;objc_object&gt;,size_t,true分别表示hash key、value、value==0时是否自动释放hash节点。实际上key就是OC对象，value是引用计数。 weak_table_t12345678910/** * The global weak references table. Stores object ids as keys, * and weak_entry_t structs as their values. */struct weak_table_t &#123; weak_entry_t *weak_entries; // hash数组 size_t num_entries; // 数组中存放的元素个数 uintptr_t mask; // 数组长度，防止数组越界 uintptr_t max_hash_displacement; // hash冲突的最大次数&#125;; weak_entry_t12345678910111213141516171819#define WEAK_INLINE_COUNT 4struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; // 被弱引用的对象 union &#123; // 动态数组 struct &#123; weak_referrer_t *referrers; // 指向referent内存地址的指针的地址的hash数组 uintptr_t out_of_line : 1; // 是否使用动态hash数组标记为 uintptr_t num_refs : PTR_MINUS_1; // 数组中元素个数 uintptr_t mask; // 数组长度 uintptr_t max_hash_displacement; // hash冲突的最大次数 &#125;; // 定长数组 struct &#123; // out_of_line=0 is LSB of one of these (don&apos;t care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;;&#125;; 注意WEAK_INLINE_COUNT，引用指针数量小于等于WEAK_INLINE_COUNT为定长数组，超过后就始终使用动态数组。]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>引用计数</tag>
        <tag>Weak表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime：load和initialize]]></title>
    <url>%2F2019%2F06%2F07%2FRuntime%EF%BC%9Aload%E5%92%8Cinitialize%2F</url>
    <content type="text"><![CDATA[Load和Initialize往死了问是一种怎样的体验？这篇blog有很好的参考价值，不过有一些细节仍然存在错误。 + load()方法，顾名思义是类的加载方法，在main()函数之前调用，其官方文档如下：123456789101112131415161718192021222324252627282930313233Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.当类（Class）或者类别（Category）加入Runtime中时（就是被引用的时候）。实现该方法，可以在加载时做一些类特有的操作。DiscussionThe load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.The order of initialization is as follows:All initializers in any framework you link to.调用所有的Framework中的初始化方法All +load methods in your image.调用所有的+load方法All C++ static initializers and C/C++ attribute(constructor) functions in your image.调用C++的静态初始化方及C/C++中的attribute(constructor)函数All initializers in frameworks that link to you.调用所有链接到目标文件的framework中的初始化方法In addition:A class’s +load method is called after all of its superclasses’ +load methods.一个类的+load方法在其父类的+load方法后调用A category +load method is called after the class’s own +load method.一个Category的+load方法在被其扩展的类的自有+load方法后调用In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.在+load方法中，可以安全地向同一二进制包中的其它无关的类发送消息，但接收消息的类中的+load方法可能尚未被调用。 + initialize()方法，顾名思义即类的初始化方法，其官方文档如下：123456789Initializes the class before it receives its first message.在这个类接收第一条消息之前调用。DiscussionThe runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.Runtime在一个程序中每一个类的一个程序中发送一个初始化一次，或是从它继承的任何类中，都是在程序中发送第一条消息。（因此，当该类不使用时，该方法可能永远不会被调用。）运行时发送一个线程安全的方式初始化消息。父类的调用一定在子类之前。 其基础特征及调用时序可以在文档中有一个大概的了解，然后我们在这个基础上提出问题。前提：A类、B类，均实现其load及initialize方法，B为A的子类，另外C1、C2为A的分类。 不做任何操作，求时序。 对A类发消息，求时序。 对B类发消息，求时序。此后问题删除分类。 先对A类发消息，再对B类发消息，求时序。 先对B类发消息，再对A类发消息，求时序。 删除B类initialize方法，先对A类发消息，再对B类发消息，求时序。 在A类的load方法中对B类发消息，此外对A类发消息，求时序。 取消B类和A类的继承关系，改为继承NSObject，条件同问题7，求时序。 输入如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950问题1：2019-06-07 14:25:28.996053+0800 LKTestOC[59335:5384227] A: father load2019-06-07 14:25:28.996694+0800 LKTestOC[59335:5384227] B: son load2019-06-07 14:25:28.996812+0800 LKTestOC[59335:5384227] C1: category load2019-06-07 14:25:28.996881+0800 LKTestOC[59335:5384227] C2: category load结论：load方法时序 父类-&gt;子类-&gt;分类，不会覆盖，且与消息发送无关。问题2：2019-06-07 14:26:33.960364+0800 LKTestOC[59510:5385993] A: father load2019-06-07 14:26:33.960938+0800 LKTestOC[59510:5385993] B: son load2019-06-07 14:26:33.961009+0800 LKTestOC[59510:5385993] C1: category load2019-06-07 14:26:33.961078+0800 LKTestOC[59510:5385993] C2: category load2019-06-07 14:26:34.069072+0800 LKTestOC[59510:5385993] C2: category initialize结论：initialize方法在消息发送后调用，会覆盖，分类时序最后，且与主类是否import分类无关。问题3：2019-06-07 14:32:15.164806+0800 LKTestOC[60397:5393459] A: father load2019-06-07 14:32:15.165367+0800 LKTestOC[60397:5393459] B: son load2019-06-07 14:32:15.165457+0800 LKTestOC[60397:5393459] C1: category load2019-06-07 14:32:15.165530+0800 LKTestOC[60397:5393459] C2: category load2019-06-07 14:32:15.269258+0800 LKTestOC[60397:5393459] C2: category initialize2019-06-07 14:32:15.269361+0800 LKTestOC[60397:5393459] B: son initialize结论：initialize方法时序 父类-&gt;分类-&gt;子类，分类覆盖父类。问题4、5：2019-06-07 14:33:54.319935+0800 LKTestOC[60679:5396081] A: father load2019-06-07 14:33:54.320518+0800 LKTestOC[60679:5396081] B: son load2019-06-07 14:33:54.466408+0800 LKTestOC[60679:5396081] A: father initialize2019-06-07 14:33:54.466562+0800 LKTestOC[60679:5396081] B: son initialize结论：子类的initliaze会自动调用父类方法，且每个类初始化时只会调用一次initliaze。问题6：2019-06-07 14:38:39.735874+0800 LKTestOC[61421:5403318] A: father load2019-06-07 14:38:39.736519+0800 LKTestOC[61421:5403318] B: son load2019-06-07 14:38:39.921747+0800 LKTestOC[61421:5403318] A: father initialize2019-06-07 14:38:39.921889+0800 LKTestOC[61421:5403318] A: father initialize结论：如官方文档所说，子类未实现intialize时父类会调用多次，此处要重点注意，如果想利用initialize做懒加载，需防止调用多次，可利用(self == [ClassName self])做判断。问题7：2019-06-07 14:43:10.949354+0800 LKTestOC[62160:5409931] A: father initialize2019-06-07 14:43:10.949928+0800 LKTestOC[62160:5409931] B: son initialize2019-06-07 14:43:11.008578+0800 LKTestOC[62160:5409931] A: father load2019-06-07 14:43:11.008811+0800 LKTestOC[62160:5409931] B: son load结论：initialize方法不一定在main()之后，严格遵循发送消息时调用。问题8：2019-06-07 14:44:12.102702+0800 LKTestOC[62327:5411529] B: son initialize2019-06-07 14:44:12.105044+0800 LKTestOC[62327:5411529] A: father load2019-06-07 14:44:12.105306+0800 LKTestOC[62327:5411529] B: son load结论：符合预期。]]></content>
      <categories>
        <category>Runtime</category>
      </categories>
      <tags>
        <tag>load</tag>
        <tag>initialize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：知识面归纳]]></title>
    <url>%2F2019%2F05%2F27%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%9F%A5%E8%AF%86%E9%9D%A2%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[对这几年来开发中遇到的常见基础知识点做一个总结。 Block参考iOS-Block的本质关于Block用copy修饰的原因的一点自己的理解 Block本质Block是一种OC对象，内部有isa指针，它封装了函数调用和函数调用环境的OC对象。它会捕获变量的临时值（遇到过一个BUG，Block初始化时捕获了变量值，后续每一次调用时本应该基于最新的值来做业务），若想要在block内部改变外部值，使用__block。 Block类型 NSGlobalBlock （ _NSConcreteGlobalBlock ） 数据区 NSStackBlock （ _NSConcreteStackBlock ） 堆区 NSMallocBlock （ _NSConcreteMallocBlock ） 栈区 如何判断block是哪种类型 没有访问auto变量的block是NSGlobalBlock ，放在数据段 访问了auto变量的block是NSStackBlock [NSStackBlock copy]操作就变成了NSMallocBlock 因此 NSGlobalBlock 调用copy操作后，什么也不做 NSStackBlock 调用copy操作后，复制效果是：从栈复制到堆；副本存储位置是堆 NSStackBlock 调用copy操作后，复制效果是：引用计数增加；副本存储位置是堆 ARC下Block何时自动复制到堆上 block作为函数返回值时 将block赋值给__strong指针时 block作为Cocoa API中方法名含有usingBlock的方法参数时 block作为GCD API的方法参数时 为什么用copy修饰栈区Block在MRC下不会像ARC中那样自动copy，因此栈区的Block容易在方法执行完后自动释放导致野指针crash。 Block的内存泄漏Block最典型的循环引用就是self持有block，block持有self，为了避免循环引用，通常使用weak或block的弱引用，在此基础上，还衍生出了weak strong dance，来避免block内部引用对象被释放导致的野指针crash或bug。 Runtime参考iOS运行时(Runtime)详解+Demo Runtime本质OC是一门由C和汇编语言写的面向对象的动态语言。关键在于理解Class的数据结构定义。1234567891011121314151617181920212223242526272829typedef struct object_class *Class;struct object_class&#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list *methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表#endif&#125;OBJC2_UNAVAILABLE;typedef struct objc_object *id;struct objc_object&#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;typedef struct objc_category *Categorystruct objc_category&#123; char *category_name OBJC2_UNAVAILABLE; // 分类名 char *class_name OBJC2_UNAVAILABLE; // 分类所属的类名 struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; // 实例方法列表 struct objc_method_list *class_methods OBJC2_UNAVAILABLE; // 类方法列表 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 分类所实现的协议列表&#125; isaisa是一个指向Class的指针，实例对象的isa指向它的类，他的类的isa指向其元类，元类的isa指向根元类，根元类的isa指向其自身。需要注意NSObject的元类，父类指针指向NSObject，形成一个环。 SEL和IMP的区别SEL的数据结构：typedef struct objc_selector *SEL；，它是指向一个方法的指针；IMP的定义：id (*IMP)(id, SEL,...)，它是一个函数指针，指向方法实现的地址。第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)第二个参数：是方法选择器(selector) Method123456typedef struct objc_method *Methodstruct objc_method&#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; Method可以理解为方法名和方法实现的map映射，便于我们通过方法指针找到方法实现。OC的消息转发、方法动态绑定、方法交换都是基于这个机制。 消息发送 - objc_msgSend()参考Objective-C 消息发送与转发机制原理 检测selector、target。 从这个类的缓存方法列表里找，是否有执行过这个方法。 找不到就从方法列表里找。 找不到就从父类的方法列表里找，直到NSObject。 找不到进入动态方法解析，类对象+ (BOOL)resolveClassMethod:(SEL)sel和元类对象+ (BOOL)resolveInstanceMethod:(SEL)sel 找不到进入消息转发，- (id)forwardingTargetForSelector:(SEL)aSelector生成NSInvocation，forwardInvocation:转发。 load方法和initialize方法的异同Runtime-load和initialize RunLoop参考iOS底层原理总结-RunLoop RunLoop本质就是一个while循环……源码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;;typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* must have the run loop locked before locking this */ CFStringRef _name; Boolean _stopped; char _padding[3]; CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers; CFMutableDictionaryRef _portToV1SourceMap; __CFPortSet _portSet; CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS dispatch_source_t _timerSource; dispatch_queue_t _queue; Boolean _timerFired; // set to true by the source when a timer has fired Boolean _dispatchTimerArmed;#endif#if USE_MK_TIMER_TOO mach_port_t _timerPort; Boolean _mkTimerArmed;#endif#if DEPLOYMENT_TARGET_WINDOWS DWORD _msgQMask; void (*_msgPump)(void);#endif uint64_t _timerSoftDeadline; /* TSR */ uint64_t _timerHardDeadline; /* TSR */&#125;; RunLoop作用 保证主线程不被销毁（写过那么多hello world应该知道main函数顺序执行完就退出了，很好理解）。 处理用户事件，传感器、通知。 调度CPU资源，让我们在空闲时能干很多事。 RunLoop流程 RunLoop Mode kCFRunLoopDefaultMode：默认模式，主线程是在这个运行模式下运行 UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响） UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到 kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案 RunLoop几种状态123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入RunLoop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; 内存管理相关ARCARC的本质ARC本质上和MRC没有区别，都是依靠引用计数进行管理，只是编译器帮我们做了内存管理的操作。ARC有4种修饰符strong,weak,autoreleasing,unsafe_unretained。 内存泄漏内存泄漏最常出现在循环引用，表现为A强引用B，B强引用A的循环，会导致双方的引用计数不可能为0，无法释放，内存无法释放的结果就是app占用内存逐渐扩大，最终被看门狗杀死进程crash。 野指针Crash中出现频率较高的BAD_ACCESS就是野指针Crash之一，即指针指向的内存已经在别处被回收。通常出现在MRC或者iOS9以前的ARC上，常见的如block（见过最多的就是把block从通知中抛出给别的地方处理，省事的代码容易挖坑）等。调试方式主要依靠XCode的Zoombie Object和Address Sanitizer。 Autoreleasepool参考 AutoreleasepoolAutoreleasePool底层实现原理 AutoreleasePool创建是在一个RunLoop事件开始之前(push) AutoreleasePool释放是在一个RunLoop事件即将结束之前(pop)。 AutoreleasePool里的Autorelease对象的加入是在RunLoop事件中，AutoreleasePool里的Autorelease对象的释放是在AutoreleasePool释放时。 MRC怎么写像init，copy这些实例方法，是由对象持有者管理内存的，所以在MRC中要主动release，而stringWithFormat之类的类方法则是由类自身去管理。 UIKitUIView与CALayer UIView基于UIKit，继承于UIResponder，CALayer基于QuartzCore，继承于NSObject。 UIView是CALayer的delegate，UIView负责处理事件，CALayer负责绘制。 CALayer不需要处理交互事件，所以更轻量。 frame与bounds frame以父级页面坐标系为基础，bounds是以自身左上角为原点。 animation先看一段代码1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; self.testView = [[UIView alloc] initWithFrame:CGRectMake(40, 50, 200, 100)]; [self.view addSubview:self.testView]; [self printFrame]; [UIView animateWithDuration:5.0f animations:^&#123; self.testView.transform = CGAffineTransformMakeScale(2, 2); &#125; completion:^(BOOL finished) &#123; NSLog(@&quot;animate complete&quot;); [self printFrame]; &#125;]; // NSLog(@&quot;before change&quot;);// self.testView.frame = CGRectMake(40, 50, 50, 25);// [self printFrame];// NSLog(@&quot;after change&quot;); self.timer = [NSTimer timerWithTimeInterval:1.0f target:self selector:@selector(printFrame) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSDefaultRunLoopMode];&#125;- (void)printFrame &#123; NSLog(@&quot;frame:%@ - bounds:%@&quot;, NSStringFromCGRect(self.testView.frame), NSStringFromCGRect(self.testView.bounds));&#125; 此时的输出是123456782019-05-30 13:20:38.968830+0800 LKTestOC[26445:12812774] frame:&#123;&#123;40, 50&#125;, &#123;200, 100&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;2019-05-30 13:20:39.970986+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;2019-05-30 13:20:40.970806+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;2019-05-30 13:20:41.971040+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;2019-05-30 13:20:42.970473+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;2019-05-30 13:20:43.970007+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;2019-05-30 13:20:43.980835+0800 LKTestOC[26445:12812774] animate complete2019-05-30 13:20:43.981103+0800 LKTestOC[26445:12812774] frame:&#123;&#123;-60, 0&#125;, &#123;400, 200&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125; 打开注释后的输出是：12345678910112019-05-30 13:21:57.706688+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;200, 100&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;200, 100&#125;&#125;2019-05-30 13:21:57.707726+0800 LKTestOC[26631:12816453] before change2019-05-30 13:21:57.707959+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;2019-05-30 13:21:57.708076+0800 LKTestOC[26631:12816453] after change2019-05-30 13:21:58.708456+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;2019-05-30 13:21:59.708621+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;2019-05-30 13:22:00.708491+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;2019-05-30 13:22:01.708489+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;2019-05-30 13:22:02.708597+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125;2019-05-30 13:22:02.719551+0800 LKTestOC[26631:12816453] animate complete2019-05-30 13:22:02.719705+0800 LKTestOC[26631:12816453] frame:&#123;&#123;40, 50&#125;, &#123;50, 25&#125;&#125; - bounds:&#123;&#123;0, 0&#125;, &#123;25, 12.5&#125;&#125; 可以看出 animate后frame是直接变化的，而在屏幕上的绘制是逐渐变化。 bounds可以看成是view在其自身坐标系上的真实大小，frame应该是bounds与transform等叠加之后在父级坐标系中的值。 因为frame是直接变化的，因此在动画开始后改frame是基于这个值直接变化。 涂色后可以看出，在动画开始后改变frame，真实的动画是从(25,12.5)放大到(50,25)的过程。 事件响应链参考iOS hitTesthitTest方法调用步骤如下： 首先在当前视图的hitTest方法中调用pointInside方法判断触摸点是否在当前视图内 若pointInside方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest返回nil，该视图不处理该事件 若pointInside方法返回YES，说明触摸点在当前视图内，则从最上层的子视图开始（即从subviews数组的末尾向前遍历），遍历当前视图的所有子视图，调用子视图的hitTest方法重复步骤1-3 直到有子视图的hitTest方法返回非空对象或者全部子视图遍历完毕 若第一次有子视图的hitTest方法返回非空对象，则当前视图的hitTest方法就返回此对象，处理结束 若所有子视图的hitTest方法都返回nil，则当前视图的hitTest方法返回当前视图本身，最终由该对象处理触摸事件而事件传递的顺序则与hitTest调用顺序相反，如下：view -&gt; superView …- &gt; UIViewController.view -&gt; UIViewController -&gt; UIWindow -&gt; UIApplication -&gt; 事件丢弃 UITableView调优系统API Cell复用池 预估高度 TableViewKit封装封装tableview、datasource、delegate等，提供： 二维数组数据源。 Cell内部高度计算类方法。 上下拉刷新、左右滑动。 内容优化 减少主线程操作，异步加载，如图片。 异步绘制，如YYTextLabel。 减少对象创建，创建好，改变hidden。 减少属性赋值，frame的改变会引发重绘，在android端有一个实践，把Cell拆分成N个小Cell，在直觉上这是违背优化的，但是带来了非常可观的性能优化，我认为当业务到达一定复杂度阈值的时候，将Cell拆分可以减少频繁赋值导致的性能开销。 减少离屏渲染，如masks\shadow\corner等，尽量用hidden避免用alpha。 谨慎使用autolayout。 LayouterLayouter与MVVM思想类似，将server端的数据转化为与View绑定的ViewModel（整理上游数据，保证View能用）。一次计算好布局数据后就可以避免在heightForRow和cellForRow-bindData过程中重复计算。再进一步也可以作为下次更新的缓存，用于预估高度、减少白屏时间等。缓存高度最好是在runloop空闲时，参考SDWebImage。 性能检测工具 profile instruments 代码打点 多线程概念多线程就是说可以进行多个任务并发，通常线程数等于物理核心数，在后来有了四核八线程等基于逻辑核心的超线程技术。 GCD参考iOS 多线程：『GCD』详尽总结GCD有两个核心概念，队列和任务，重点在理解串行、并发队列；主线程、子线程；同步执行、异步执行。除了常见的同步、异步dispatch外，还有dispatch_barrier_async（栅栏）、dispatch_after（延时）、dispatch_once（只执行一次）、dispatch_apply（迭代）、dispatch_group（组）、dispatch_group_notify、dispatch_group_wait、dispatch_group_enter、dispatch_group_leave等。 dispatch_barrier和dispatch_group的区别参考dispatch_barrier_async和dispatch_barrier_sync的区别和详细解析dispatch_barrier_async和sync的区别：相同点： 等待在它前面插入队列的任务先执行完 等待他们自己的任务执行完再执行后面的任务不同点： dispatch_barrier_sync将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们。 dispatch_barrier_async将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务。 NSOperationCCD基于C，NSOperation基于OC，其底层也是通过GCD实现，NSOperation比GCD更抽象，API更丰富，效率较低，在大多数普通业务中更倾向于用GCD。 缓存iOS数据持久化方案 沙盒 - 每个应用程序对应的系统目录1.1. plist1.2. SQLite FMDatabase1.3. NSKeyedArchiver 归档成文件 NSFileManager CoreData iOS缓存 NSCache NSURLCache 内存缓存 网络TCP和UDPTCP有三次握手，可靠传输，UDP是不可靠传输。TCP的滑动窗口是接收方为了流量控制限制的窗口大小，控制发送速度防止自己被淹没。 Https，SSLHttp是无状态的，而Https是加入了SSL层，可进行加密传输、身份认证的网络协议。 cookie和sessioncookie和session的最大区别就是cookie保存在客户端，session保存在服务端。 热更新JSPatch参考JSPatch-实现原理详解通过JSContext来实现JS调用OC方法，通过方法交换替换掉IMP指针。 RN基于JSCore的解析引擎，通过bridge调用native方法，UI基于OEM widgets。 Flutter自己实现了渲染框架，底层skia引擎，Widgets Rendering。通过Platform Method Channels与原生代码通信。 Protobuf解析二进制字节流，有效地压缩数据，数据量体积小，使用Tag - Length - Value编码方式，存储紧凑，空间利用率高。 Varint编码方式T-V，值越小的数字，使用越少的字节数表示。 Zigzag将 有符号数 转换成 无符号数，然后再采用Varint编码。 数组repeated字段，编码方式Tag - Length - Value -Value -Value。 optional &amp; requiredoptional默认值，可删除。 散乱知识点 KVO、Delegate、Notification 区别及相关使用场景，KVO isa-swizzling，根据原类创建中间类，重写方法，然后返回原类的Class 什么是类簇 —— 类簇是Foundation的一种设计模式，比如NSNumber下的int、double、long。可以很方便的用一个类来管理不同的数据类型。]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>iOS基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter：踩坑记录]]></title>
    <url>%2F2019%2F04%2F10%2FFlutter%EF%BC%9A%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Flutter 踩坑记录问题索引TabBar及PageView状态保存ScrollView滚动进度保存ListView下拉刷新后数据已返回，UI未更新中文汉字变形热重载hot reload未生效转场动画在list内黑屏不生效Android plugin内不能使用AAR包Android plugin内AAR包内的so库加载不出来Json注解制动生成的解析文件解析数据失败加载更多后头像加载慢或不加载dio安卓上网络请求失败NestedScrollView中的子View使用controller监听会导致Sliver控件吸顶效果失效枚举值需要取index，否则打印类名flutter动画不执行在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失dispose后不允许setState滑动冲突Row中的Text控件出现overflow警告webview无法连接网络 q001TabBar及PageView状态保存 Flutter 1.2.1 statble 子页面离开屏幕时，state会被销毁引发的bughttps://juejin.im/post/5b73c3b3f265da27d701473a q002ScrollView滚动进度保存 Flutter 1.2.1 statble 进入其他页面返回后保存scrollView的offsethttps://stackoverflow.com/questions/49087703/preserving-state-between-tab-view-pages q003ListView下拉刷新后数据已返回，UI未更新 Flutter 1.2.1 statble ListView需要有Key，否则被复用引发的UI不立即更新bughttps://stackoverflow.com/questions/51279611/flutter-listview-builder-not-updating-after-insert q004中文汉字变形 Flutter 1.2.1 statble 该问题发生在MaterialApp中，多数情况与fontfamily有关。https://github.com/flutter/flutter/issues/22966https://github.com/flutter/flutter/issues/26752https://github.com/flutter/flutter/issues/25726 q005热重载hot reload未生效 Flutter 1.2.1 statble 目前已知几种情况下，hot reload无法生效 需要build_runner做代码生成部分的代码 使用了新添加的资源 发现hot reload无效，可以尝试使用hot restart重新启动应用，若还是无效，可以考虑执行ScriptForCI/update.sh后，重新flutter run。 q006转场动画在list内黑屏不生效Hero转场动画在list内黑屏不生效原因：list内可能存在多个元素，Hero tag固定的情况下会判定view tree里面存在多个相同tag的转场元素解决方案：tag随机生成，并通过参数传入下个页面 q007Android plugin内不能使用AAR包Android插件开发中，AAR包引用不到原因：flutter暂不支持AAR的引用，仅支持gradle方式引用解决方案： 放弃插件方案，直接在application工程下开发flutter与native的交互方案 百度私服。将AAR文件放入百度私服maven库，通过gradle方式引用。WIKI：http://wiki.baidu.com/pages/viewpage.action?pageId=465488650maven库地址：http://maven.baidu-int.com/nexus/content/groups/public链接：http://maven.baidu-int.com/nexus/content/groups/public/com/baidu/bdpass/使用方法：compile ‘com.baidu.bdpass:HWOpenSDK:3.3.3@aar’接口人：zhanghuaming@baidu.com q008Android plugin内AAR包内的so库加载不出来Android 插件通过gradle方式引用AAR包，但是其中的so库load不出来原因：flutter对AAR包的引用支持不好解决方案：放弃使用pass提供的AAR包，用贴吧主端的sofire-sdk-3.1.9.3.jar + libfire.so替代 q009Json注解制动生成的解析文件解析数据失败原因：server返回的数据有问题，一个map的结构体可能返回list类型的空串解决方案：在解析之前对可能发生错误的地方做预处理，如果类型不对直接置null q010Json注解制动生成的解析文件解析数据失败原因：View复用导致没有刷新解决方案：需要给头像控件增加一个单独的Key ##q011原因：没有网络请求的权限解决方案：在tbflutterlite/android/app/src/main/AndroidMainifest.xml中添加网络请求权限，同理如果需要读写SD卡也需要声明对应的权限 ##q012原因：未知解决方案：改用NotificationListener q014flutter动画不执行原因：flutter TickerProvider同一时间只能对一个动画生效，且动画执行完一次后，下次执行时起始数据在末尾方案：动画controller写成全局变量，执行动画前先调reset方法。 q015在SilverAppBar内使用滑动控件（ScrollView、PageView等）滑动控件消失原因不明。 1234567SliverAppBar( flexibleSpace: FlexibleSpaceBar( background: PageView.builder( ... ... ) )) PageView若更换成其他非滑动型控件，则无此问题。 q016原因：内存泄漏方案：dispose时将callBack等异步操作取消或置null q017滑动冲突原因：flutter事件传递机制是由外向内传递的，外层如果处理了事件，会直接resume掉事件流，内层控件没有机会处理事件解决方案：对于GestureDetector onScale 和 onDrag事件不能共存的问题，通过两层嵌套的GestureDetector解决。对于系统外层控件直接处理滑动事件的情况（例如tabView），通过内层控件回调外层标志位决定外层是否处理事件，例如1234TabBarView( children: children, physics: _needHandleScroll ? PageScrollPhysics() : NeverScrollableScrollPhysics(),), q018方案：将Text嵌套在Expanded中 q019Info.plist中加入1234567&lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt;&lt;true/&gt;&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>笔记</tag>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[研发效率：iOS常见warning梳理]]></title>
    <url>%2F2018%2F07%2F26%2F%E7%A0%94%E5%8F%91%E6%95%88%E7%8E%87%EF%BC%9AiOS%E5%B8%B8%E8%A7%81warning%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[iOS常见warning梳理常见warning类型 warning类型 影响 修复方式 严重等级 方法有定义无实现 crash 补齐或删除方法 P0 调用不存在的方法 crash 调用正确方法 P0 调用系统DEPRECATED方法/属性 crash、bug 分系统进行调用 P0 方法调用中参数类型错误 crash、bug 转化对象类型 P0 赋值类型不一致 crash、bug 转化对象类型 P0 未调用super方法 内存泄漏、bug 调用super P0 循环引用 内存泄漏 weak strong dance P0 重名代理 bug 改名 P1 重名宏 bug 改名 P1 子类与父类有重名同类型属性 bug 删除其中一个 P1 子类与父类有重名不同类型属性 bug 子类添加忽略警告标记，@dynamic动态合成属性 P1 格式化输出类型不一致 bug 强制转换类型 P1 @required代理未实现 bug 补齐代理方法 P1 工程未按推荐方式配置 warning提示等级、编译选项等存在风险 更新到recommend settings P1 MRC文件内存泄漏警告 性能浪费 修复代码或添加ARC标记 P1 临时变量无初始值 bug 赋初始值 P1 枚举赋值类型不一致 bug 修改代码 P1 非对象属性加了* bug 删除* P1 代码中包含非法字符 编译器无法识别 删除非法字符 P1 Nullable/NonNull标记不全 产生大量warning 删除或补全该文件内的标记 P2 未使用的临时变量 性能浪费 删除无用变量 P2 未使用的static变量 性能浪费 删除无用变量 P2 代理类未添加代理标记 类型检查警告 添加代理 P2 performSelector 不推荐使用的方法调用方式 直接调用方法 P2 第三方库最低版本与主工程不一致 编译警告 添加-w linker标记 P2 .c文件的64/32位警告 编译警告 添加-Wno-shorten-64-to-32文件标记 P2 import文件名大小写错误 无 修复文件名 P3 非法注释 注释格式不规范，无法快捷查看定义 使用系统快捷注释 P3 block定义不规范 类型检查警告 补齐void P3 工程有文件引用但文件不存在 文件索引失败 bug P3 asset有索引无文件 bug 删除索引 P3 search path存在，文件不存在 找不到索引 删除search path P3 修复warning的方式 根据编译器提示修复。 对于暂不修复的warning有三种忽略方式。2.1. 选中warning，右键选择Reveal in Log，复制warning类型，在代码中添加ignored标记。2.2. 对于某个文件，忽略某种类型的warning，与打ARC标记相同，添加对应类型的编译标记。2.3. 全局忽略某一类型warning，在工程配置中添加编译选项。]]></content>
      <categories>
        <category>研发效率</category>
      </categories>
      <tags>
        <tag>warning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：属性变量、实例变量、成员变量的内存泄漏]]></title>
    <url>%2F2018%2F07%2F18%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B1%9E%E6%80%A7%E5%8F%98%E9%87%8F%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[直接上代码12345678910111213@interface TestViewController () &#123;@private NSString *name1;&#125;@property (nonatomic, copy) NSString *name;@property (nonatomic, strong) TestObject *testObj;@property (nonatomic, strong) TestObject *testObj1;@property (nonatomic, copy) NSString *name2;@property (nonatomic, strong) TestObject *testObj2;@end 12345678910111213141516171819202122232425262728293031323334353637// 无泄漏- (void)testBlock &#123; __weak typeof(self) weakSelf = self; [self.testObj requestData:^(NSString *str) &#123; weakSelf.name = str; &#125;];&#125;// 泄漏- (void)testBlock1 &#123; [self.testObj1 requestData:^(NSString *str) &#123; name1 = str; &#125;];&#125;// 泄漏- (void)testBlock1_2 &#123; [self.testObj1 requestData:^(NSString *str) &#123; self-&gt;name1 = str; &#125;];&#125;// 无泄漏- (void)testBlock1_3 &#123; __weak typeof(self) weakSelf = self; [self.testObj1 requestData:^(NSString *str) &#123; __strong typeof(weakSelf) strongSelf = weakSelf; strongSelf-&gt;name1 = str; &#125;];&#125;// 泄漏- (void)testBlock2 &#123; [self.testObj2 requestData:^(NSString *str) &#123; _name2 = str; &#125;];&#125; 属性变量与实例变量的内存泄漏非常常见，需要关注的是成员变量name1，通过name1和self-&gt;name1均会造成内存泄漏，应与属性变量一样使用weak strong dance。]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：NSNotificationCenter小结]]></title>
    <url>%2F2018%2F01%2F02%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9ANSNotificationCenter%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[线程问题日常开发中会遇到一些异步线程修改UI的crash，很难追查，其中有一大部分可能来源于对通知的错误使用。NSNotificationCenter是iOS开发中很常见的观察者模式，分为post和observer，其中涉及多线程的原则其实很简单，通知在哪个线程发出，observer就会在哪个线程处理。测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950- (void)viewDidLoad&#123; [super viewDidLoad]; UIButton *test = [[UIButton alloc] initWithFrame:CGRectMake(50, 50, 100, 40)]; test.backgroundColor = [UIColor blueColor]; [test addTarget:self action:@selector(syncPost) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:test]; dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner) name:@&quot;asycObserverNotification&quot; object:nil]; &#125;); UIButton *test1 = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 100, 40)]; test1.backgroundColor = [UIColor blueColor]; [test1 addTarget:self action:@selector(asyncPost) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:test1]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(lisetner1) name:@&quot;asycPostNotification&quot; object:nil];&#125;// 主线程发- (void)syncPost&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycObserverNotification&quot; object:nil];&#125;// 子线程收- (void)lisetner&#123; NSLog(@&quot;Async Observer! - %@&quot;, [NSThread currentThread]);&#125;// 子线程发- (void)asyncPost&#123; dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;asycPostNotification&quot; object:nil]; &#125;);&#125;// 主线程收- (void)lisetner1&#123; NSLog(@&quot;Async Post! - %@&quot;, [NSThread currentThread]); self.view.backgroundColor = [UIColor grayColor]; [self.view layoutIfNeeded];&#125; 执行结果如下：1232018-01-02 14:57:56.048000+0800 LKTestApp[5192:2351336] Async Observer! - &lt;NSThread: 0x1c407d4c0&gt;&#123;number = 1, name = main&#125;2018-01-02 14:58:09.066149+0800 LKTestApp[5192:2353929] Async Post! - &lt;NSThread: 0x1c027dc40&gt;&#123;number = 5, name = (null)&#125;]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>NSNotificationCenter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库阅读笔记：YYModel]]></title>
    <url>%2F2017%2F03%2F13%2F%E5%BC%80%E6%BA%90%E5%BA%93%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%9AYYModel%2F</url>
    <content type="text"><![CDATA[YYKit，作者ibireme，Blog，YYKitDemo。 YYModelYYModel作为NSObject的Category，具有JSON字符串与Model相互转化的功能。JSON解析过程如下： 判空，获取class。 若用户自定义class，则根据元类YYModelMeta获取class（如根据字段将类分为圆、正方形等）。 根据JSON转化Model。自定义class属于扩展功能，先分析JSON转化Model这一主要功能。 JSON转化Model此功能核心方法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243- (BOOL)modelSetWithDictionary:(NSDictionary *)dic &#123; if (!dic || dic == (id)kCFNull) return NO; if (![dic isKindOfClass:[NSDictionary class]]) return NO; _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)]; if (modelMeta-&gt;_keyMappedCount == 0) return NO; if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123; dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic]; if (![dic isKindOfClass:[NSDictionary class]]) return NO; &#125; ModelSetContext context = &#123;0&#125;; context.modelMeta = (__bridge void *)(modelMeta); context.model = (__bridge void *)(self); context.dictionary = (__bridge void *)(dic); if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123; CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context); if (modelMeta-&gt;_keyPathPropertyMetas) &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; if (modelMeta-&gt;_multiKeysPropertyMetas) &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; &#125; else &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas, CFRangeMake(0, modelMeta-&gt;_keyMappedCount), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123; return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic]; &#125; return YES;&#125; 其思路简单明了，通过class获取YYMoel元类，随后根据YYModelMeta递归调用自身，直到将Model中所有属性转化完成，接下来仔细阅读代码。 异常处理首先对传入的NSDictionary进行了判空处理，如下。12if (!dic || dic == (id)kCFNull) return NO;if (![dic isKindOfClass:[NSDictionary class]]) return NO; 在开发时对NSDictionary的判空一般使用nil，kCFNull是什么呢？iOS中的空值类型有5种：nil\Nil\NULL\NSNull\kCFNull。nil：指向一个实例对象的空指针。Nil：指向一个类的空指针。NULL：定义基本类型、C类型的空指针。NSNull：数组中元素的占位符，数组元素若为nil则数组结束，但是可以为NSNull。kCFNull：NSNull的单例。参考：IOS 空值 nil Nil NULL NSNull kCFNull 获取元类1_YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)]; 要想理解这部分思想，首先需要理解Objective-C对象和runtime的概念。 可参考：Objective-C中的类和对象object_getClass(obj)与[obj class]的区别测试代码如下：123456789101112131415161718192021222324252627282930- (void)viewDidLoad&#123; [super viewDidLoad]; TestClass *obj1 = [[TestClass alloc] init]; TestClass *obj2 = [[TestClass alloc] init]; Class cls1 = object_getClass(obj1); Class cls2 = object_getClass(cls1); Class cls3 = object_getClass(cls2); NSLog(@&quot;%@, %p&quot;, obj1, obj1); NSLog(@&quot;%@, %p&quot;, cls1, cls1); NSLog(@&quot;%@, %p&quot;, cls2, cls2); NSLog(@&quot;%@, %p&quot;, cls3, cls3); Class cls4 = [obj1 class]; Class cls5 = [cls4 class]; Class cls6 = [cls5 class]; NSLog(@&quot;%@, %p&quot;, obj2, obj2); NSLog(@&quot;%@, %p&quot;, cls4, cls4); NSLog(@&quot;%@, %p&quot;, cls5, cls5); NSLog(@&quot;%@, %p&quot;, cls6, cls6); Class cls7 = [cls1 class]; Class cls8 = [cls2 class]; Class cls9 = [cls3 class]; NSLog(@&quot;%@, %p&quot;, cls7, cls7); NSLog(@&quot;%@, %p&quot;, cls8, cls8); NSLog(@&quot;%@, %p&quot;, cls9, cls9);&#125; 其中TestClass继承TestSuperClass，TestSuperClass继承NSObject。结果如下：12345678910112017-04-14 12:41:23.561943+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007f90&gt;, 0x174007f902017-04-14 12:41:23.562018+0800 LKTestApp[829:229808] TestClass, 0x1001012802017-04-14 12:41:23.562037+0800 LKTestApp[829:229808] TestClass, 0x1001012582017-04-14 12:41:23.562051+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec82017-04-14 12:41:23.562090+0800 LKTestApp[829:229808] &lt;TestClass: 0x174007fa0&gt;, 0x174007fa02017-04-14 12:41:23.562103+0800 LKTestApp[829:229808] TestClass, 0x1001012802017-04-14 12:41:23.562115+0800 LKTestApp[829:229808] TestClass, 0x1001012802017-04-14 12:41:23.562126+0800 LKTestApp[829:229808] TestClass, 0x1001012802017-04-14 12:41:23.562138+0800 LKTestApp[829:229808] TestClass, 0x1001012802017-04-14 12:41:23.562149+0800 LKTestApp[829:229808] TestClass, 0x1001012582017-04-14 12:41:23.562160+0800 LKTestApp[829:229808] NSObject, 0x1a9129ec8 可知object_getClass(obj)返回了obj的isa指针，[obj class]obj为实例对象时调用实例方法，返回isa指针，若为类对象则调用类方法返回自身。 然后我们来看看YYModel中的元类_YYModelMeta，其数据结构如下：12345678910111213141516171819202122@interface _YYModelMeta : NSObject &#123; @package YYClassInfo *_classInfo; /// Key:mapped key and key path, Value:_YYModelPropertyMeta. NSDictionary *_mapper; /// Array&lt;_YYModelPropertyMeta&gt;, all property meta of this model. NSArray *_allPropertyMetas; /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to a key path. NSArray *_keyPathPropertyMetas; /// Array&lt;_YYModelPropertyMeta&gt;, property meta which is mapped to multi keys. NSArray *_multiKeysPropertyMetas; /// The number of mapped key (and key path), same to _mapper.count. NSUInteger _keyMappedCount; /// Model class type. YYEncodingNSType _nsType; BOOL _hasCustomWillTransformFromDictionary; BOOL _hasCustomTransformFromDictionary; BOOL _hasCustomTransformToDictionary; BOOL _hasCustomClassFromDictionary;&#125;@end Objective-C中有4种访问控制符：@private（当前类访问权限）：成员只能在当前类内部可以访问，在类实现部分定义的成员变量相当于默认使用了这种访问权限。@package（同映像访问权限）：成员可以在当前类或和当前类实现的同一映像中使用。同一映像就是编译后生成的同一框架或同一个执行文件。@protected（子类访问权限）：成员可以在当前类和当前类的子类中访问。在类接口部分定义的成员变量默认是这种访问权限。@public（公共访问权限）：成员可以在任意地方访问。 _YYModelMeta存储了原始key value的映射信息，将多个key对应一个value(keyPath)和一个key对应多个value(keyArray)等复杂情况交给_YYModelPropertyMeta处理。1234567891011121314151617181920212223242526272829303132333435363738@interface _YYModelPropertyMeta : NSObject &#123; @package NSString *_name; ///&lt; property&apos;s name YYEncodingType _type; ///&lt; property&apos;s type YYEncodingNSType _nsType; ///&lt; property&apos;s Foundation type BOOL _isCNumber; ///&lt; is c number type Class _cls; ///&lt; property&apos;s class, or nil Class _genericCls; ///&lt; container&apos;s generic class, or nil if threr&apos;s no generic class SEL _getter; ///&lt; getter, or nil if the instances cannot respond SEL _setter; ///&lt; setter, or nil if the instances cannot respond BOOL _isKVCCompatible; ///&lt; YES if it can access with key-value coding BOOL _isStructAvailableForKeyedArchiver; ///&lt; YES if the struct can encoded with keyed archiver/unarchiver BOOL _hasCustomClassFromDictionary; ///&lt; class/generic class implements +modelCustomClassForDictionary: /* property-&gt;key: _mappedToKey:key _mappedToKeyPath:nil _mappedToKeyArray:nil property-&gt;keyPath: _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil property-&gt;keys: _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath _mappedToKeyArray:keys(array) */ NSString *_mappedToKey; ///&lt; the key mapped to NSArray *_mappedToKeyPath; ///&lt; the key path mapped to (nil if the name is not key path) NSArray *_mappedToKeyArray; ///&lt; the key(NSString) or keyPath(NSArray) array (nil if not mapped to multiple keys) YYClassPropertyInfo *_info; ///&lt; property&apos;s info _YYModelPropertyMeta *_next; ///&lt; next meta if there are multiple properties mapped to the same key.&#125;@end@interface YYClassPropertyInfo : NSObject@property (nonatomic, assign, readonly) objc_property_t property; ///&lt; property&apos;s opaque struct@property (nonatomic, strong, readonly) NSString *name; ///&lt; property&apos;s name@property (nonatomic, assign, readonly) YYEncodingType type; ///&lt; property&apos;s type@property (nonatomic, strong, readonly) NSString *typeEncoding; ///&lt; property&apos;s encoding value@property (nonatomic, strong, readonly) NSString *ivarName; ///&lt; property&apos;s ivar name@property (nullable, nonatomic, assign, readonly) Class cls; ///&lt; may be nil@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols; ///&lt; may nil@property (nonatomic, assign, readonly) SEL getter; ///&lt; getter (nonnull)@property (nonatomic, assign, readonly) SEL setter; ///&lt; setter (nonnull)@end YYClassInfo则与OC中类的结构相似，包含了父类指针、元类指针、是否是元类以及属性、方法、ivar列表等属性。12345678910111213141516@interface YYClassInfo : NSObject@property (nonatomic, assign, readonly) Class cls; ///&lt; class object@property (nullable, nonatomic, assign, readonly) Class superCls; ///&lt; super class object@property (nullable, nonatomic, assign, readonly) Class metaCls; ///&lt; class&apos;s meta class object@property (nonatomic, readonly) BOOL isMeta; ///&lt; whether this class is meta class@property (nonatomic, strong, readonly) NSString *name; ///&lt; class name@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///&lt; super class&apos;s class info@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos; ///&lt; ivars@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos; ///&lt; methods@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos; ///&lt; properties- (void)setNeedUpdate;- (BOOL)needUpdate;+ (nullable instancetype)classInfoWithClass:(Class)cls;+ (nullable instancetype)classInfoWithClassName:(NSString *)className;@end ivar是objc_ivar类型的实例变量指针，而属性则是objc_property。 随后通过+ (instancetype)metaWithClass:(Class)cls;进行元类初始化。此方法中主要涉及内存缓存和锁，涉及的知识点如下： CFMutableDictionaryRef是Core Foundation中的类，此处使用它而不使用NSMuatableDictionary可能是因为底层类库的需要 dispatch_semaphore信号量，包括dispatch_semaphore_create，dispatch_semaphore_wait，dispatch_semaphore_signal等用法，可查看资料1资料2 两个时间宏#define DISPATCH_TIME_NOW (0ull)#define DISPATCH_TIME_FOREVER (~0ull)0ull是unsigned long long类型的0，~则表示二进制否运算，因此~0ull是0ull取非，因此是2^64，一个无符号的极大数 真正的初始化方法是- (instancetype)initWithClass:(Class)cls;，其流程如下： 获取YYClassInfo。 获取黑名单。 获取白名单。 获取用户自定义属性。 循环获取所有属性，生成_YYModelPropertyMeta实例，将其存入_allPropertyMetas、_keyPathPropertyMetas、_multiKeysPropertyMetas。 设置属性映射mapper。 至此已获取YYModel元类，包括key/value属性映射关系，回到- (BOOL)modelSetWithDictionary:(NSDictionary *)dic;进行JSON转化。如下，根据_YYModelMeta对json进行递归，将value依次设置到model属性中。12345678910111213141516171819202122232425262728293031ModelSetContext context = &#123;0&#125;;context.modelMeta = (__bridge void *)(modelMeta);context.model = (__bridge void *)(self);context.dictionary = (__bridge void *)(dic);if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123; CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context); if (modelMeta-&gt;_keyPathPropertyMetas) &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; if (modelMeta-&gt;_multiKeysPropertyMetas) &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125;&#125; else &#123; CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas, CFRangeMake(0, modelMeta-&gt;_keyMappedCount), ModelSetWithPropertyMetaArrayFunction, &amp;context);&#125;typedef struct &#123; void *modelMeta; ///&lt; _YYModelMeta void *model; ///&lt; id (self) void *dictionary; ///&lt; NSDictionary (json)&#125; ModelSetContext; SEL即selector，可通过@selector或NSSelectorFromString创建，是一种方法选择器，描述了方法的格式，但并不真正指向方法。IMP即implement，指向函数，包含接收消息对象、SEL、入参、返回值等。 KVC(key value coding)KVC涉及以下4个方法1234- (nullable id)valueForKey:(NSString *)key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 iOS开发技巧系列—详解KVC KVO(key value obeserveing)KVO涉及以下2种方法，addObserver和removeObserver，用于监听对象属性的变化。12- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; IOS 开发中的KVC 和KVO 扩展阅读：看 YYModel 源码的一些收获 性能优化Tip缓存Model JSON 转换过程中需要很多类的元数据，如果数据足够小，则全部缓存到内存中。查表当遇到多项选择的条件时，要尽量使用查表法实现，比如 switch/case，C Array，如果查表条件是对象，则可以用 NSDictionary 来实现。避免 KVCKey-Value Coding 使用起来非常方便，但性能上要差于直接调用 Getter/Setter，所以如果能避免 KVC 而用 Getter/Setter 代替，性能会有较大提升。避免 Getter/Setter 调用如果能直接访问 ivar，则尽量使用 ivar 而不要使用 Getter/Setter 这样也能节省一部分开销。避免多余的内存管理方法在 ARC 条件下，默认声明的对象是 strong 类型的，赋值时有可能会产生 retain/release 调用，如果一个变量在其生命周期内不会被释放，则使用 unsafe_unretained 会节省很大的开销。访问具有 weak 属性的变量时，实际上会调用 objc_loadWeak() 和 objc_storeWeak() 来完成，这也会带来很大的开销，所以要避免使用 weak 属性。创建和使用对象时，要尽量避免对象进入 autoreleasepool，以避免额外的资源开销。遍历容器类时，选择更高效的方法相对于 Foundation 的方法来说，CoreFoundation 的方法有更高的性能，用 CFArrayApplyFunction() 和 CFDictionaryApplyFunction() 方法来遍历容器类能带来不少性能提升，但代码写起来会非常麻烦。尽量用纯 C 函数、内联函数使用纯 C 函数可以避免 ObjC 的消息发送带来的开销。如果 C 函数比较小，使用 inline 可以避免一部分压栈弹栈等函数调用的开销。减少遍历的循环次数在 JSON 和 Model 转换前，Model 的属性个数和 JSON 的属性个数都是已知的，这时选择数量较少的那一方进行遍历，会节省很多时间。]]></content>
      <categories>
        <category>开源库阅读笔记</category>
      </categories>
      <tags>
        <tag>YYModel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：UIViewController生命周期]]></title>
    <url>%2F2017%2F01%2F04%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9AUIViewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[UIViewController生命周期 init loadView viewDidLoad viewWillAppear viewWillLayoutSubviews viewDidLayoutSubviews viewDidAppear viewWillDisappear viewDidDisappear dealloc UIView layoutSubviews方法触发条件layoutSubviews触发条件 init does not cause layoutSubviews to be called (duh) addSubview: causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view) Resizing a view will call layoutSubviews on its superview 在UIViewController中使用UIView时，layoutSubviews的触发时机测试代码ViewController.m123456789101112131415161718192021222324252627282930313233343536373839404142#import &quot;ViewController.h&quot;#import &quot;LKView.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; LKView *view = [[LKView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)]; [self.view addSubview:view]; NSLog(@&quot;1...&quot;);&#125;- (void)viewWillLayoutSubviews&#123; [super viewWillLayoutSubviews]; NSLog(@&quot;3...&quot;);&#125;- (void)viewDidLayoutSubviews&#123; [super viewDidLayoutSubviews]; NSLog(@&quot;4...&quot;);&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; NSLog(@&quot;2...&quot;);&#125;- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; NSLog(@&quot;5...&quot;);&#125;@end LKView.m123456789101112131415161718192021#import &quot;LKView.h&quot;@implementation LKView- (instancetype)initWithFrame:(CGRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 20, 10)]; [self addSubview:btn]; &#125; return self;&#125;- (void)layoutSubviews&#123; NSLog(@&quot;lay out...&quot;);&#125;@end 测试结果1234562017-01-04 11:34:07.557 LKTestApp[39746:2070216] 1...2017-01-04 11:34:07.557 LKTestApp[39746:2070216] 2...2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 3...2017-01-04 11:34:07.561 LKTestApp[39746:2070216] 4...2017-01-04 11:34:07.562 LKTestApp[39746:2070216] lay out...2017-01-04 11:34:07.564 LKTestApp[39746:2070216] 5... 在UIViewController viewDidLayoutSubviews生命周期结束后，才会触发子view的layoutSubviews方法。]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>UIViewController</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记：iOS中踩坑记录]]></title>
    <url>%2F2016%2F12%2F19%2F%E7%AC%94%E8%AE%B0%EF%BC%9AiOS%E4%B8%AD%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[NSNumber类型判断是否为0不能使用aIntegerNum == 0，而应使用[aIntegerNum isEqualToNumber:@0]，前者比较地址，后者比较值。 UITableView无数据源时，numberOfSections是1，但[tableView numberOfRowsInSection:0]是0。 时间戳转换时间时会相差8小时，需要计算时区。 iOS10中UISwitch的特异性 快速便利Array\Set时，对元素进行操作必挂 在block中使用成员变量，会导致循环引用 iOS10以下导航栏问题http://www.jianshu.com/p/e4448c24d900 http://www.jianshu.com/p/4b8af425a7d0 __block相当于unsafe_unretain，在某些情况下，会导致crash 1234self.string1 = @&quot;String 1&quot;; self.string2 = self.string1; // unsafe_unretainself.string1 = nil; NSLog(@&quot;String 2 = %@&quot;, self.string2); MRC goto语法，目标语句中的代码，与switch中的finally类似，正常执行。 A页面跳B页面，iOS11先走B页面的viewDidLoad再走A页面的viewWillDisappear，iOS10先走A页面的viewWillDisappear再走B页面的viewDidLoad，拓展：viewDidAppear和viewDidDisappear的执行顺序iOS–viewDidAppear和viewDidDisappear调用顺序。 iOS10及以下系统，在viewDidLoad中设置导航栏标题的透明度是无效的，会被系统重设；而在iOS11中是生效的，但是，在滑动返回过程中，alpha会被重设为1。 Notification在主线程中是同步执行的。 若给UIButton高亮状态设置了backgroundImage，则需要相应地设置高亮状态icon及字色。 iOS8以上系统加在Window上的UIViewController会自动调整frame，而iOS8不会。 虽然GCD和UIViewAnimation不会造成循环引用，但是dispatch_after会持有对象使其无法释放。 一个页面中有多个UIScrollView时，scrollsToTop需仅开启一个，否则状态栏返回顶部功能失效。 UIButton的点击态有UIControlStateHighlighted和UIControlStateSelected | UIControlStateHighlighted，参照https://www.jianshu.com/p/57b2c41448bf。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>踩坑记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：UIControlState]]></title>
    <url>%2F2016%2F10%2F08%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9AUIControlState%2F</url>
    <content type="text"><![CDATA[以UIButton为例，我们为button的UIControlStateSelected状态设置一个实心五角星，为UIControlStateNormal状态设置一个空心五角星，最后为其设置UIControlEventTouchUpInside事件的action。 在一些业务场景中，我们需要为其设置一个点击态（按下但没有松开手指）时的样式，该如何做呢？ 看一下UIControlState的定义：123456789typedef NS_OPTIONS(NSUInteger, UIControlState) &#123; UIControlStateNormal = 0, UIControlStateHighlighted = 1 &lt;&lt; 0, // used when UIControl isHighlighted is set UIControlStateDisabled = 1 &lt;&lt; 1, UIControlStateSelected = 1 &lt;&lt; 2, // flag usable by app (see below) UIControlStateFocused NS_ENUM_AVAILABLE_IOS(9_0) = 1 &lt;&lt; 3, // Applicable only when the screen supports focus UIControlStateApplication = 0x00FF0000, // additional flags available for application use UIControlStateReserved = 0xFF000000 // flags reserved for internal framework use&#125;; 需要注意，这是一个NS_OPTIONS类型，而不是NS_ENUM这几种状态转化成二进制实际上是：12345 0 1 10 1001000 这意味着我们可以对其进行位操作，比如：[button setImage:selectedImage forState:UIControlStateSelected | UIControlStateHighlighted];以上表示，设置按钮被选中且高亮时的图片。]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>UIControlState</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记-UISwitch在iOS 10中的BUG]]></title>
    <url>%2F2016%2F09%2F29%2FUISwitch%E5%9C%A8iOS%2010%E4%B8%AD%E7%9A%84BUG%2F</url>
    <content type="text"><![CDATA[UISwitchUISwitch是UIControl的子类，定义如下：1234567891011121314151617181920212223242526#import &lt;Foundation/Foundation.h&gt;#import &lt;CoreGraphics/CoreGraphics.h&gt;#import &lt;UIKit/UIControl.h&gt;#import &lt;UIKit/UIKitDefines.h&gt;NS_ASSUME_NONNULL_BEGINNS_CLASS_AVAILABLE_IOS(2_0) __TVOS_PROHIBITED @interface UISwitch : UIControl &lt;NSCoding&gt;@property(nullable, nonatomic, strong) UIColor *onTintColor NS_AVAILABLE_IOS(5_0) UI_APPEARANCE_SELECTOR;@property(null_resettable, nonatomic, strong) UIColor *tintColor NS_AVAILABLE_IOS(6_0);@property(nullable, nonatomic, strong) UIColor *thumbTintColor NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@property(nullable, nonatomic, strong) UIImage *onImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@property(nullable, nonatomic, strong) UIImage *offImage NS_AVAILABLE_IOS(6_0) UI_APPEARANCE_SELECTOR;@property(nonatomic,getter=isOn) BOOL on;- (instancetype)initWithFrame:(CGRect)frame NS_DESIGNATED_INITIALIZER; // This class enforces a size appropriate for the control, and so the frame size is ignored.- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action@endNS_ASSUME_NONNULL_END 方法定义中有一个- (void)setOn:(BOOL)on animated:(BOOL)animated; // does not send action，如注释所说不发送action。 iOS 9下表现接下来在iOS 9中进行验证：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#import &quot;ViewController.h&quot;@interface ViewController ()@property (nonatomic, strong) UISwitch *lkSwitch;@property (nonatomic, strong) UISwitch *lkSwitch1;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _lkSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 50, 31)]; [_lkSwitch addTarget:self action:@selector(onSwitch:) forControlEvents:UIControlEventValueChanged]; [self.view addSubview:_lkSwitch]; UIButton *button = [[UIButton alloc] initWithFrame:CGRectMake(50, 150, 50, 31)]; [button addTarget:self action:@selector(onButton:) forControlEvents:UIControlEventTouchUpInside]; button.backgroundColor = [UIColor redColor]; [self.view addSubview:button]; _lkSwitch1 = [[UISwitch alloc] initWithFrame:CGRectMake(150, 100, 50, 31)]; [_lkSwitch1 addTarget:self action:@selector(onSwitch1:) forControlEvents:UIControlEventValueChanged]; [self.view addSubview:_lkSwitch1]; UIButton *button1 = [[UIButton alloc] initWithFrame:CGRectMake(150, 150, 50, 31)]; [button1 addTarget:self action:@selector(onButton1:) forControlEvents:UIControlEventTouchUpInside]; button1.backgroundColor = [UIColor redColor]; [self.view addSubview:button1];&#125;- (void)onSwitch:(UISwitch *)sender &#123; [sender setOn:!sender.isOn];&#125;- (void)onButton:(UIButton *)sender &#123; [_lkSwitch setOn:!_lkSwitch.isOn];&#125;- (void)onSwitch1:(UISwitch *)sender &#123; [sender setOn:!sender.isOn animated:YES];&#125;- (void)onButton1:(UIButton *)sender &#123; [_lkSwitch1 setOn:!_lkSwitch1.isOn animated:YES];&#125;@end 验证结果：无论是setOn方法还是setOn:_animated:_方法，都不会触发onSwitch。 iOS 10下表现然而，在iOS 10中，测试结果显示，在onSwitch方法中调用setOn或setOn:_animated:_，均会再次触发onSwitch。 结论也就是说，UISwitch中on属性的set方法在iOS 10中的表现与iOS 10以下不同，如果监听事件为UIControlEventValueChanged，将额外触发一次action（为什么不是不停地来回触发直到crash呢？思考…）。 解决方案在action中需要改变按钮状态时，将setOn方法在主队列中异步执行。 曾提出另一个解决方案，自定义一个XXSwitch继承UISwitch，重写setOn和setOn:_animated:_方法，但是这样带来的风险是，dispatch queue以后的语句会先于setOn执行，若此时获取isOn，将无法得到预期的结果。 因此最终决定在业务逻辑层局部进行修改。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>iOS 10</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置：SublimeText]]></title>
    <url>%2F2016%2F09%2F21%2F%E9%85%8D%E7%BD%AE%EF%BC%9ASublimeText%2F</url>
    <content type="text"><![CDATA[快捷键（Eclipse风格）Sublime Text -&gt; Preferences -&gt; Key Bindings - User12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[ /** * 代码格式化 */ &#123; &quot;keys&quot;: [&quot;command+r&quot;], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123; &quot;target&quot;: &quot;browser&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;alt+shift+f&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;, /** * json格式化 */ &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;tidy_xml&quot; &#125;, &#123; &quot;keys&quot;: [&quot;command+shift+j&quot;], &quot;command&quot;: &quot;pretty_json&quot; &#125;, &#123; &quot;keys&quot;: [&quot;command+shift+m&quot;], &quot;command&quot;: &quot;un_pretty_json&quot; &#125;, /** * 适配eclipse快捷键 */ &#123; &quot;keys&quot;: [&quot;alt+/&quot;], &quot;command&quot;: &quot;auto_complete&quot; &#125;, &#123; &quot;keys&quot;: [&quot;command+i&quot;], &quot;command&quot;: &quot;reindent&quot; &#125;, // 当前行和下面一行交互位置 &#123; &quot;keys&quot;: [&quot;alt+up&quot;], &quot;command&quot;: &quot;swap_line_up&quot; &#125;, &#123; &quot;keys&quot;: [&quot;alt+down&quot;], &quot;command&quot;: &quot;swap_line_down&quot; &#125;, // 复制当前行到上一行 &#123; &quot;keys&quot;: [&quot;command+alt+up&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;, // 复制当前行到下一行 &#123; &quot;keys&quot;: [&quot;command+alt+down&quot;], &quot;command&quot;: &quot;duplicate_line&quot; &#125;, // 删除整行 &#123; &quot;keys&quot;: [&quot;command+d&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Delete Line.sublime-macro&quot;&#125; &#125;, // 光标移动到指定行 &#123; &quot;keys&quot;: [&quot;command+l&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;, // 快速定位到选中的文字 &#123; &quot;keys&quot;: [&quot;command+k&quot;], &quot;command&quot;: &quot;find_under_expand_skip&quot; &#125;, // &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;swap_case&quot; &#125;, &#123; &quot;keys&quot;: [&quot;command+shift+x&quot;], &quot;command&quot;: &quot;upper_case&quot; &#125;, &#123; &quot;keys&quot;: [&quot;command+shift+y&quot;], &quot;command&quot;: &quot;lower_case&quot; &#125;, // 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置, 不一定是最后) &#123; &quot;keys&quot;: [&quot;shift+enter&quot;], &quot;command&quot;: &quot;run_macro_file&quot;, &quot;args&quot;: &#123;&quot;file&quot;: &quot;Packages/Default/Add Line.sublime-macro&quot;&#125; &#125;, // 定位到对于的匹配符(譬如&#123;&#125;)(从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) &#123; &quot;keys&quot;: [&quot;command+p&quot;], &quot;command&quot;: &quot;move_to&quot;, &quot;args&quot;: &#123;&quot;to&quot;: &quot;brackets&quot;&#125; &#125;, // outline &#123; &quot;keys&quot;: [&quot;command+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;@&quot;&#125; &#125;, // 当前文件中的关键字(方便快速查找内容) &#123; &quot;keys&quot;: [&quot;command+alt+o&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;#&quot;&#125; &#125;, // open resource &#123; &quot;keys&quot;: [&quot;command+shift+r&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;show_files&quot;: true&#125; &#125;, // 文件内查找/替换 &#123; &quot;keys&quot;: [&quot;command+f&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;replace&quot;&#125; &#125;, // 全局查找/替换, 在查询结果中双击跳转到匹配位置 &#123;&quot;keys&quot;: [&quot;command+h&quot;], &quot;command&quot;: &quot;show_panel&quot;, &quot;args&quot;: &#123;&quot;panel&quot;: &quot;find_in_files&quot;&#125; &#125;, // plugin配置 &#123; &quot;keys&quot;: [&quot;alt+a&quot;], &quot;command&quot;: &quot;alignment&quot; &#125;, &#123;&quot;keys&quot;: [&quot;command+shift+f&quot;], &quot;command&quot;: &quot;js_format&quot;&#125;] Color SchemeMonokai Package Control安装方法各版本不同，以最新搜索结果为准。 常用插件Markdown PreviewMarkdown EditingPretty Json(也可以在chrome浏览器中安装JSON Formatter插件) 激活原则上支持正版XD。]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置：Vim、Git、SVN]]></title>
    <url>%2F2016%2F09%2F21%2F%E9%85%8D%E7%BD%AE%EF%BC%9AVim%E3%80%81Git%E3%80%81SVN%2F</url>
    <content type="text"><![CDATA[bashvim /etc/profile，添加如下12# basealias ll=&quot;ls -la&quot; Vimvim /etc/profile，添加export TERM=xterm。 样式vim ~/.vimrc，配置如下12345678910111213syntax onset tabstop=4set softtabstop=4set shiftwidth=4set autoindentset cindentset cinoptions=&#123;0,1s,t0,n-2,p2s,(03s,=.5s,&gt;1s,=1s,:1sif &amp;term==&quot;xterm&quot;set t_Co=8set t_Sb=^[[4%dmset t_Sf=^[[3%dmendif 命令vim命令大全 Gitalias1vim ~/.gitconfig 12345678910111213141516171819202122232425[alias] co = checkout ad = add aa = add -A au = add -u ci = commit ca = commit -a st = status pl = pull pr = pull --rebase ps = push dt = difftool l = log --stat cp = cherry-pick b = branch lg = log --stat lgp = log --stat -p lgg = log --graph lgga = log --graph --decorate --all lgm = log --graph --max-count=10 lo = log --oneline --decorate lol = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit lola = log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --all log = log --oneline --decorate --graph loga = log --oneline --decorate --graph --all p.s.1234567# 三种add命令的区别1. git add -A 保存所有的修改2. git add . 保存新的添加和修改，但是不包括删除3. git add -u 保存修改和删除，但是不包括新建文件# 查看命令帮助git xxx -h 添加中文支持bash中输入git config --global core.quotepath false（已使用UTF-8字符集）。 ignorevim ~/.gitignore_global添加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465*~.DS_Store# Xcode## gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore &amp; Swift.gitignore## Build generated#build/DerivedData/## Various settings*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata/*.xcuserdatad## Other*.moved-aside*.xcuserstate## Obj-C/Swift specific*.hmap*.ipa*.dSYM.zip*.dSYM# CocoaPods## We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control## Pods/# Carthage## Add this line if you want to avoid checking in source code from Carthage dependencies.# Carthage/CheckoutsCarthage/Build# fastlane## It is recommended to not store the screenshots in the git repo. Instead, use fastlane to re-generate the # screenshots whenever they are needed.# For more information about the recommended setup visit:# https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Gitignore.mdfastlane/report.xmlfastlane/Preview.htmlfastlane/screenshotsfastlane/test_output# Code Injection## After new code Injection tools there&apos;s a generated folder /iOSInjectionProject# https://github.com/johnno1962/injectionforxcodeiOSInjectionProject/ Gerrit审查模式配置切换到相应的git库目录下，执行git config remote.origin.push refs/heads/*:refs/for/*命令，此后git push操作会默认推送到remote库中的refs/for/xxx审查分支。 p.s.删除误提交的xcuserdata12345// -n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。git rm -r -n --cached */src/\*// 删除文件的版本控制git rm -r --cached */src/\* SVNvim /etc/profile，添加export SVN_EDITOR=vim。全局和局部参数配置用户信息，略。]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>Vim</tag>
        <tag>Git</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置：Xcode快捷键]]></title>
    <url>%2F2016%2F09%2F21%2F%E9%85%8D%E7%BD%AE%EF%BC%9AXcode%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[部分内容来自：简书：为Xcode添加删除当前行、复制当前行快捷键 感谢作者的分享。本文仅为记录个人的开发配置。 Xcode8以后，不再支持plugins，因此之前用来设置快捷键的boost等插件都已失效。有一些eclipse带过来的快捷键习惯该如何设置呢？ 上下移动当前行Xcode -&gt; Preference -&gt; Key Bindings -&gt; Move Line Up &amp; Move Line Down 复制当前行修改权限123sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plistsudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/ 添加快捷键1open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist 在Insertions and Indentations中添加Duplicate Current Line - selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward: 设置快捷键重启后Xcode -&gt; Preference -&gt; Key Bindings -&gt; Insertions and Indentations 删除当前行添加快捷键1open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist 在Deletions中添加Delete Current Line - deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine: 设置快捷键重启后Xcode -&gt; Preference -&gt; Key Bindings -&gt; Delete Current Line]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：OC基础知识小结]]></title>
    <url>%2F2016%2F09%2F17%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9AOC%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[内存 堆栈栈区（stack）由编译器自动分配释放 ，当一个函数被调用,一个stack frame(栈帧)就会被压到stack里，包含函数的参数、局部变量、返回地址等。当函数返回后,这个栈帧就会被销毁。 堆区(heap)heap的空间需要手动分配。heap与动态内存分配相关,内存可以随时在堆中分配和销毁。我们需要明确请求内存分配与内存销毁。 全局区（static）全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 。 文字常量区常量字符串就是放在这里的。 程序结束后由系统释放。 程序代码区存放函数体的二进制代码。 引用计数4个原则 自己生成的对象，自己持有。 非自己生成的对象，自己也能持有。 不再需要自己持有的对象时释放。 非自己持有的对象无法释放。 对象操作 对象操作 Objective-C方法 生成并持有对象 alloc/new/copy/mutableCopy 持有对象 retain 释放对象 release 废弃对象 dealloc ARCARC(Automatic Reference Counting): 只要还有一个变量指向对象，对象就会保持在内存中。 自动释放池对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。 对象执行autorelease方法时会将对象添加到自动释放池中。 当自动释放池销毁时自动释放池中所有对象作release操作。 对象执行autorelease方法后自身引用计数器不会改变，而且会返回对象本身。 属性参数 assign: （相当于__unsafe_unretained所有权修饰符）简单赋值，用于基础数据类型和C数据类型。 retain: （指针拷贝）拷贝一个对象，地址相同，内容相同。 copy: （内容拷贝）拷贝一个对象，创建一个新对象，内容相同（若copy数组，则仅复制子元素的指针）。 unsafe_unretained:若没有strong类型指针指向时，对象被释放，不自动置为nil。 weak: （多用于解决循环引用）若没有strong类型指针指向时，对象被释放并且自动置为nil。 strong: （ARC中默认属性类型）相当于retain。 实例测试11234567891011#import &lt;Foundation/Foundation.h&gt;@interface TestARC : NSObject@property (nonatomic, strong) NSString *string;@property (nonatomic, assign) NSString *stringAssign;@property (nonatomic, retain) NSString *stringRetain;@property (nonatomic, copy) NSString *stringCopy;@property (nonatomic, unsafe_unretained) NSString *stringUnsafe;@property (nonatomic, weak) NSString *stringWeak;@property (nonatomic, strong) NSString *stringStrong;@end 1234567891011121314151617#import &quot;TestARC.h&quot;int main(int argc, const char * argv[]) &#123; TestARC *testObj; @autoreleasepool &#123; testObj = [[TestARC alloc] init]; testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;]; testObj.stringAssign = testObj.string; testObj.string = nil; &#125; NSLog(@&quot;string = %@&quot;, testObj.string); NSLog(@&quot;stringAssign = %@&quot;, testObj.stringAssign); return 0;&#125; stringAssign被释放，但是没有被置为nil，形成悬垂指针（dangling pointer），程序异常终止。 测试2123456789101112131415161718#import &quot;TestARC.h&quot;int main(int argc, const char * argv[]) &#123; TestARC *testObj; @autoreleasepool &#123; testObj = [[TestARC alloc] init]; testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;]; testObj.stringWeak = testObj.string;// testObj.stringStrong = testObj.string; testObj.string = nil; &#125; NSLog(@&quot;string = %@&quot;, testObj.string); NSLog(@&quot;stringWeak = %@&quot;, testObj.stringWeak); return 0;&#125; 122016-09-17 22:26:17.603 LKTestPracticeClass[31191:5393359] string = (null)2016-09-17 22:26:17.604 LKTestPracticeClass[31191:5393359] stringWeak = (null) 122016-09-17 22:26:52.780 LKTestPracticeClass[31216:5399359] string = (null)2016-09-17 22:26:52.781 LKTestPracticeClass[31216:5399359] stringStrong = string1 强指针指向对象时，内存没有被释放。 测试312345678910111213141516#import &quot;TestARC.h&quot;int main(int argc, const char * argv[]) &#123; TestARC *testObj; @autoreleasepool &#123; testObj = [[TestARC alloc] init]; testObj.string = [NSMutableString stringWithFormat:@&quot;string1&quot;]; testObj.stringRetain = testObj.string; testObj.stringCopy = testObj.string; testObj.stringStrong = testObj.string; testObj.string = nil; &#125; return 0;&#125; 12345678(lldb) p testObj.string(NSString *) $0 = nil(lldb) p testObj.stringRetain(__NSCFString *) $1 = 0x00000001005036c0 @&quot;string1&quot;(lldb) p testObj.stringCopy(NSTaggedPointerString *) $2 = 0x31676e6972747375 @&quot;string1&quot;(lldb) p testObj.stringStrong(__NSCFString *) $3 = 0x00000001005036c0 @&quot;string1&quot; Block带有自动变量（局部变量）的匿名函数。形如int (^count)(int) = ^int (int count){return count+1;};声明部分从左到右依次为：1. 返回值类型（不可省略，无返回值时为void）；2. block名称；3. 参数列表（不可省略）。赋值部分从左到右依次为：1. 返回值类型（无返回值时可省略，省略时根据block中return类型决定返回值，无return则为void）；2. 参数列表（无参数时可省略）；3. 表达式。 类型 _NSConcretGlobalBlock: 全局静态block不会访问任何外部静态变量：这种不捕捉外界变量的block是不需要内存管理的，这种block不存在于heap或是stack而是作为代码片段存在，类似于C函数。 _NSConcretStackBlock: 保存在栈中的block，但函数返回时被销毁，需要涉及到外界变量的block在创建的时候是在stack上面分配空间的，一旦所在函数返回，则会被摧毁。如果我们希望保存这个block或者是返回它，则需要将其放到堆上。 _NSConcretMallocBlock: 保存在堆中的block，当引用计数为0时会被销毁。拷贝到堆后，block的生命周期就与一般的OC对象一样了，我们通过引用计数来对其进行内存管理。 注意点 block会截获外部自动变量的瞬间值。 block只能保存自动变量的瞬间值，而不能改写。若想改写，可以为自动变量添加__block修饰符。此外，静态变量、全局变量、静态全局变量这些全局区中的变量可以在block中改写值。 使用block时很容易出现两个对象互相持有、循环引用的情况，这会导致内存泄漏，可以通过如__weak typeof(self) weakSelf = self;新建一个指针的方式解决，在block内部使用__weak类型的对象。 block属性的声明，首先需要用copy修饰符，因为只有copy后的block才会在堆中，栈中的block的生命周期是和栈绑定的。在ARC下,即使你声明的修饰符是strong，实际上效果是与声明为copy一样的。因此在ARC情况下,创建的block仍然是NSConcreteStackBlock类型，只不过当block被引用或返回时，ARC帮助我们完成了copy和内存管理的工作。 实例12345678#import &lt;Foundation/Foundation.h&gt;@interface TestBlock : NSObjecttypedef NSString *(^testBlockStruct)(NSString *);@property (nonatomic, strong) testBlockStruct completionBlock;- (void)handleBlock:(NSString *)string;@end 123456789#import &quot;TestBlock.h&quot;@implementation TestBlock- (void)handleBlock:(NSString *)string &#123; if (self.completionBlock) &#123; NSLog(@&quot;%@&quot;, self.completionBlock(string)); &#125;&#125;@end 1234567891011121314151617#import &quot;TestBlock.h&quot;int main(int argc, const char * argv[]) &#123; TestBlock *testBlock = [[TestBlock alloc] init]; NSString *tempString = @&quot;Baidu&quot;; testBlock.completionBlock = ^NSString *(NSString *string)&#123; // 使用外部的局部变量tempString NSLog(@&quot;Block is here with %@ at %@.&quot;, string, tempString); return @&quot;Block is completed.&quot;; &#125;; // 改变局部变量tempString，打印出的block截获了其瞬间值&quot;Baidu&quot; tempString = @&quot;Beijing&quot;; [testBlock handleBlock:@&quot;LeOuf&quot;]; return 0;&#125; 122016-09-17 22:33:05.425 LKTestPracticeClass[31278:5428415] Block is here with LeOuf at Baidu.2016-09-17 22:33:05.426 LKTestPracticeClass[31278:5428415] Block is completed. GCDGCD(Grand Central Dispatch)是异步执行任务的技术之一。允许开发者将自定义任务追加到适当的Dispatch Queue。 Dispatch Queue DISPATCH_QUEUE_SERIAL: 串行队列，FIFO，队列中0…n任务执行结束后，n+1个任务才可以开始。 DISPATCH_QUEUE_CONCURRENT: 并发队列（并发不一定能并行），FIFO，队列中0…n任务开始执行后，n+1个任务才可以开始。 获取Dispatch Queue方法: dispatch_get_main_queue() dispatch_get_global_queue() dispatch_queue_create() 方法列表 补充 MRC不能使用weak，使用什么替代？ NSString为什么要使用copy? block底层forwarding实现 那些部分不能使用async操作 ARC和MRC下的循环引用 如何检测VC的循环引用 Category的好处，Category中是否可以加property？ 类别和扩展的区别？为啥要使用扩展 Category中一定添加property，如何实现？ Category中添加和原有类的方法，是否覆盖？ assign 因为NSString可以持有NSMutableString对象，如果将NSMutableString对象赋值给一个NSString，使用copy可以防止前者的修改引起后者值发生变化（NSString应该是immutable）。 __Block_byref_val_0结构体实例有一个成员变量__forwarding持有只想该实例自身的指针。static void _Block_byref_assign_copy(void dest, const void arg, const int flags) { struct Block_byref destp = (struct Block_byref )dest; struct Block_byref src = (struct Block_byref )arg; // src points to stack struct Block_byref copy = (struct Block_byref )_Block_allocator(src-&gt;size, false, isWeak); copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier) src-&gt;forwarding = copy; // patch stack to point to heap copy copy-&gt;size = src-&gt;size; // assign byref data block pointer into new Block _Block_assign(src-&gt;forwarding, (void **)destp);}根据以上代码可看到，该函数在堆上新建了一个对象copy，将堆上copy对象的forwarding和栈上原始对象的forwarding都指向copy对象。以保证无论是在堆上还是在栈上，我们通过forwarding访问到的都是同一个对象。 UI部分。 ARC中可以新建一个weak修饰符修饰的指针（如weak typeof(self) weakSelf=self;），防止两个对象互相持有；MRC可以用block修饰（如block typeof(self) weakSelf = self;）。 (1) Product-&gt;Profile，查看Leaks，如： (2) lldb直接print，查看对象是否为nil。7&amp;9. 优点：不使用继承而为现有类添加新方法。Category用常规方法添加property即使实现了get set方法，在调用时也会报错，但是可以通过objc_getAssociatedObject和objc_setAssociatedObject这两个函数或@dynamic在运行时添加property。8&amp;10. （1）类别：类别中无法添加新的实例变量；类别中的方法与现有方法的命名冲突时，类别中的方法将会取代初始方法；类别主要用于将类的实现分散到不同的文件中、创建对私有方法的前向引用、向对象添加非正式协议。（2）扩展：一种匿名的类别；私有的属性和方法可以通过扩展的方式声明；扩展中定义的方法必须在@implementaion中实现。]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置：迁移hexo]]></title>
    <url>%2F2016%2F09%2F03%2F%E9%85%8D%E7%BD%AE%EF%BC%9A%E8%BF%81%E7%A7%BBhexo%2F</url>
    <content type="text"><![CDATA[Blog托管在github，拉取代码后。 下载nodejs，Node.js官网 安装hexo，sudo npm install -g hexo 保留原有deploy配置，执行sudo npm install hexo-deployer-git --save 安装server，sudo npm install hexo-server 如发生github pages init错误，删除.deploy_git文件 theme中配置_config.yml文件，将被墙资源改为cdn资源。另外，360前端cdn资源已经不再提供服务，Google资源服务器已经回到北京，不再需要通过镜像或反向代理等方法获取fonts和jQuery。目前可以达到秒开博客的效果，Google回归中国似乎指日可待啊。 记录NEXT theme中一个bug：post_details.js中的方法会导致点击右侧文章目录后，整个目录收起并锚点到某个不可预知的位置，而不是锚点到指定的目录位置。123456789101112131415// 旧方法存在bug，无法选中指定toc// $(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123;// e.preventDefault();// var targetSelector = NexT.utils.escapeSelector(this.getAttribute(&apos;href&apos;));// var offset = $(targetSelector).offset().top;// hasVelocity ?// html.velocity(&apos;stop&apos;).velocity(&apos;scroll&apos;, &#123;// offset: offset + &apos;px&apos;,// mobileHA: false// &#125;) :// $(&apos;html, body&apos;).stop().animate(&#123;// scrollTop: offset// &#125;, 500);// &#125;); 修改如下：123456$(&apos;.post-toc a&apos;).on(&apos;click&apos;, function (e) &#123; e.preventDefault(); $(&apos;html, body&apos;).animate(&#123; scrollTop: $( $.attr(this, &apos;href&apos;) ).offset().top &#125;, 500);&#125;); 如遇到hexo g无法生成source的情况，npm ls --depth 0列出缺失包，npm install xxx --save逐个下载入职百度第一周，充实且兴奋。保持良好工作效率的同时，希望能保持更新博客的习惯。]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：初学OC]]></title>
    <url>%2F2016%2F08%2F16%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%88%9D%E5%AD%A6OC%2F</url>
    <content type="text"><![CDATA[我们知道iOS中的frame由x, y, width, height决定的一个个矩形。接下来尝试用一个矩形类来探究如何使用类中的属性和方法。 坐标类XYPoint。123456789#import &lt;Foundation/Foundation.h&gt;@interface XYPoint : NSObject@property int x, y;- (void)setX:(int)xVal andY:(int)yVal;@end 12345678910#import &quot;XYPoint.h&quot;@implementation XYPoint-(void)setX:(int)xVal andY:(int)yVal &#123; _x = xVal; _y = yVal;&#125;@end 矩形类MyRect12345678910111213#import &lt;Foundation/Foundation.h&gt;#import &quot;XYPoint.h&quot;@interface MyRect : NSObject@property (nonatomic) int width, height;@property (nonatomic) XYPoint *origin;- (void)setWidth:(int)w andHeight:(int)h;- (int)area;- (int)perimeter;@end 1234567891011121314151617181920212223242526#import &quot;MyRect.h&quot;@implementation MyRect- (XYPoint *)origin &#123; return _origin;&#125;- (void)setOrigin:(XYPoint *)origin &#123; _origin = origin;&#125;- (void)setWidth:(int)w andHeight:(int)h &#123; _width = w; _height = h;&#125;- (int)area &#123; return _width * _height;&#125;- (int)perimeter &#123; return (_width + _height) * 2;&#125;@end main函数12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import &quot;MyRect.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyRect *rect = [[MyRect alloc] init]; XYPoint *point = [[XYPoint alloc] init]; [point setX:100 andY:200]; [rect setWidth:5 andHeight:8]; rect.origin = point; NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height); NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y); [point setX:50 andY:50]; NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y);// NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]); &#125; return 0;&#125; XYPoint类非常简单，x，y属性，加上其set方法。MyRect类中有width，height以及一个XYPoint属性，加上一些方法。main函数中是我们编写的测试代码，做一些初始化，赋值，输出的操作。 我们的重点在于MyRect类，这段代码是有问题的。首先看头文件，利用@property自动声明get\set方法。再看实现文件，在get方法中报Use of undeclared indentifier &#39;_origin&#39;error。说好的在Xcode4.5以后可以省略@synthesize呢？现在我们删除get方法和set方法其中之一，发现error消失了。实际上编译器确实自动添加了@synthesize，默认的实例变量名为&quot;_&quot; + 属性名。但是当我们同时重写了get\set方法时，系统就不再自动帮我生成实例变量了。 现在我们加上@synthesize origin = _origin;。error彻底消失，我们也可以自由地重写get\set方法了。运行main函数得到结果。12342016-08-16 15:59:45.763 LKTestPracticeClass[39983:6991728] Rect w = 5, h = 82016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (100, 200)2016-08-16 15:59:45.764 LKTestPracticeClass[39983:6991728] Origin at (50, 50)Program ended with exit code: 0 回到main函数，我们将point对象赋值给rect的属性origin，然后改变point对象的值，为什么rect的origin属性值也随之改变了呢？我们知道C语言中函数的参数都是值传递，那么来看MyRect类中origin的set方法，123- (void)setOrigin:(XYPoint *)origin &#123; _origin = origin;&#125; origin是(XYPoint *)类型，这是一个XYPoint类型对象的引用/地址，而_origin = origin;只是将这个对象的地址赋值给了实例变量_origin，现在，它们指向了同一个内存地址，那么我们改变了这个地址所指向的值，则point对象和rect对象的origin对象值都同时改变了。 如何解决这个问题呢，这里有一个重点的思想，rect对象应该持有一个XYPoint类型的对象，这是它的横纵坐标，这个对象应该有它自己的内存空间，而不是指向一块与rect对象无关的内存。 第一个方案，改造setOrigin方法。1234567- (void)setOrigin:(XYPoint *)origin &#123; if (!_origin) &#123; _origin = [[XYPoint alloc] init]; &#125; _origin.x = origin.x; _origin.y = origin.y;&#125; 当我们给origin set值时，实例化一块内存空间，然后将传递过来的point对象中x，y一一赋值给新的origin对象。运行结果：12342016-08-16 16:09:37.557 LKTestPracticeClass[40037:6999091] Rect w = 5, h = 82016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)2016-08-16 16:09:37.558 LKTestPracticeClass[40037:6999091] Origin at (100, 200)Program ended with exit code: 0 很明显，这生效了，但是在set方法中实例化这让人难受，更舒服的做法是每当我获取origin属性的时候，再做实例化，因为我可能并不会重写set方法，或许我不止这一个set方法，总之set方法太“上游”了，我希望在更底层、更统一的地方做init操作。因此，我们把实例化的代码移动到get中，这也叫做惰性实例化。1234567891011- (XYPoint *)origin &#123; if (!_origin) &#123; _origin = [[XYPoint alloc] init]; &#125; return _origin;&#125;- (void)setOrigin:(XYPoint *)origin &#123; _origin.x = origin.x; _origin.y = origin.y;&#125; 运行代码，期待…12342016-08-16 16:14:26.337 LKTestPracticeClass[40065:7002556] Rect w = 5, h = 82016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)2016-08-16 16:14:26.338 LKTestPracticeClass[40065:7002556] Origin at (0, 0)Program ended with exit code: 0 然而结果是这样的，x，y的值从始至终都是0。 我们检查一下main函数，原来我们从未调用过get方法，origin属性从未指向任何内存，也就是nil，而nil对象中值是从0开始的。那么，让我们在setOrigin之前调用一个get吧。12rect.origin;rect.origin = point; 运行，12342016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Rect w = 5, h = 82016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)2016-08-16 16:17:18.664 LKTestPracticeClass[40097:7005323] Origin at (100, 200)Program ended with exit code: 0 很棒，实现了我们的目的。 可是这个get方法调用得莫名其妙，异常丑陋，让我们删掉它，再研究一下MyRect类。我们在set方法中调用一下get不就实现了我们的目的吗？于是…12345678910111213@synthesize origin = _origin;- (XYPoint *)origin &#123; if (!_origin) &#123; _origin = [[XYPoint alloc] init]; &#125; return _origin;&#125;- (void)setOrigin:(XYPoint *)origin &#123; self.origin.x = origin.x; self.origin.y = origin.y;&#125; 这里的self.origin就是origin的get方法（我们只在获取property时用点操作符，其他时候仍然用方括号）。 最后，整理一下思路，MyRect类中有一个origin属性，我们在它的实现中为它指定了实例变量_origin作为它的存储空间。然后我们重写了它的get\set方法，在get方法中，我们采取惰性实例化，没有重写init方法在一开始就为实例变量开辟空间，而是直到我们不得不去获取它的值时，才进行初始化。接下来，在其他的方法中，我们一律用get方法获取_origin实例变量，它是实例变量的入口，不管我们想要获取它的值，还是改变它的值，都能够确保它开辟了一块内存空间用于存储，而且是在最后一刻万不得已时才初始化的，在不必要的时候没有浪费一丝内存。另一方面，对于int类型的width和height来说，则没有惰性实例化这一概念，因为它们是数字字符常量，处于常量区中，一直都持有着属于它们的内存空间。 来看一下改造完的代码。MyRect类实现。1234567891011121314151617181920212223242526272829303132#import &quot;MyRect.h&quot;@implementation MyRect@synthesize origin = _origin;- (XYPoint *)origin &#123; if (!_origin) &#123; _origin = [[XYPoint alloc] init]; &#125; return _origin;&#125;- (void)setOrigin:(XYPoint *)origin &#123; self.origin.x = origin.x; self.origin.y = origin.y;&#125;- (void)setWidth:(int)w andHeight:(int)h &#123; self.width = w; self.height = h;&#125;- (int)area &#123; return self.width * self.height;&#125;- (int)perimeter &#123; return (self.width + self.height) * 2;&#125;@end main函数12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import &quot;MyRect.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; MyRect *rect = [[MyRect alloc] init]; XYPoint *point = [[XYPoint alloc] init]; [point setX:100 andY:200]; [rect setWidth:5 andHeight:8]; rect.origin = point; NSLog(@&quot;Rect w = %i, h = %i&quot;, rect.width, rect.height); NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y); [point setX:50 andY:50]; NSLog(@&quot;Origin at (%i, %i)&quot;, rect.origin.x, rect.origin.y); NSLog(@&quot;Area = %i, Perimeter = %i&quot;, [rect area], [rect perimeter]); &#125; return 0;&#125; 运行结果123452016-08-16 16:44:37.009 LKTestPracticeClass[40218:7027614] Rect w = 5, h = 82016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Origin at (100, 200)2016-08-16 16:44:37.010 LKTestPracticeClass[40218:7027614] Area = 40, Perimeter = 26Program ended with exit code: 0]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>类</tag>
        <tag>属性</tag>
        <tag>方法</tag>
        <tag>惰性实例化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：类、对象和方法.md]]></title>
    <url>%2F2016%2F08%2F14%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文是在阅读Objective-C程序设计 第6版一书过程中写的学习笔记，文中出现的大部分代码基本与书中相同。 什么是对象我们知道，OC是在C的基础上设计的面向对象的程序设计语言，而C则是过程性语言。以我的理解，所谓的过程性语言，是为了实现某种功能所设计的，比如我想要将两个整数累加，返回它们的和，这是我的目的，所以C语言中完成这种目的一段代码称为函数，这个函数的功能是累加两个整数。而所谓的面相对象，这个函数则被看作一个真实存在的物件，这里我们叫它计算器，当我们想要累加两个整数时，创建了一个计算器对象，然后再调用它本身的功能（方法）来实现我们的目的。 我认为可以这样理解，过程性语言中，“我”是主体，当“我”想要做什么时，创建了“我”需要的函数然后去使用它；而面向对象，每个对象都是独立存在的主体，它们可以为“我”服务。 类、方法Fraction类123456789#import &lt;Foundation/Foundation.h&gt;@interface Fraction : NSObject- (void)print;- (void)setNumerator: (int)n;- (void)setDenominator: (int)d;@end 12345678910111213141516171819#import &quot;Fraction.h&quot;@implementation Fraction &#123; int numerator; int denominator;&#125;- (void)print &#123; NSLog(@&quot;%i / %i&quot;, numerator, denominator);&#125;- (void)setNumerator:(int)n &#123; numerator = n;&#125;- (void)setDenominator:(int)d &#123; denominator = d;&#125;@end main函数1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import &quot;Fraction.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... Fraction *fraction; fraction = [[Fraction alloc] init]; [fraction setNumerator:1]; [fraction setDenominator:3]; NSLog(@&quot;The value of fracton is: &quot;); [fraction print]; &#125; return 0;&#125; 先看Fraction类，这里我们只关注它的头文件，这个对象告诉我们，它的功能是通过分子和分母获得一个分数，它有3个对外部可见的方法，打印分数、获得分子、获得分母。这里我们可以完全不必理会它的实现，只需要获知并且相信它很好地实现了这三个功能。另外@符号在””前，表示这是常量NSString对象。 然后来看main函数。第一行中，我们就看到了@autoreleasepool，这是什么呢？ autoreleasepool嵌套在其后的代码块会被放在“自动释放池”这一语境中执行。什么是“自动释放池”？首先我们需要知道什么是Runloop，Runloop是一个while循环，当然这是一个很复杂的循环。可以理解为一个App中有许多个Runloop，它们在监听着用户操作、管理着内存以及执行一些操作。以后我们再来关心Runloop的具体实现。 对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个象CallStack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。 以下对于autoreleasepool的分析参考了@雷纯锋的技术博客文中的实验在部分新设备上已经不再成立，因此结合自己的想法重新做一遍测试。 首先，从上文我们可以知道，autoreleasepool就是延迟调用了realease，那么我们来实验一下它到底是什么时候realease的。 场景112345678910111213141516171819202122232425__weak NSString *string_weak_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 1.1 NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;]; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); string_weak_ = string; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; NSLog(@&quot;string_weak_@viewWillAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);&#125;- (void)viewDidAppear:(BOOL)animated &#123; [super viewDidAppear:animated]; NSLog(@&quot;string_weak_@viewDidAppear: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);&#125; 123456789101112131415__strong NSString *string_strong_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 1.2 NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;]; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); string_strong_ = string; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;string_strong_@viewDidLoad: %@ with retainCount: %@&quot;, string_strong_, [string_strong_ valueForKey:@&quot;retainCount&quot;]);&#125;// ...省略 12345678910111213__weak Fraction *fraction_weak_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 1.3 Fraction *fraction = [[Fraction alloc] init]; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); fraction_weak_ = fraction; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);&#125; 12345678910111213__strong Fraction *fraction_strong_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 1.4 Fraction *fraction = [[Fraction alloc] init]; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); fraction_strong_ = fraction; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;fraction_strong_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_strong_, [fraction_strong_ valueForKey:@&quot;retainCount&quot;]);&#125; 123456789101112131415161718192021222324252627// 场景1.1(__weak NSString *) 结果 2016-08-15 14:26:03.193 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 22016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string@viewDidLoad: I&apos;m here! with retainCount: 22016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 42016-08-15 14:26:03.194 LKTestAutoreleasePool[36540:6293792] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 32016-08-15 14:26:03.198 LKTestAutoreleasePool[36540:6293792] string_weak_@viewDidAppear: (null) with retainCount: (null)// 场景1.2(__strong NSString *) 结果 2016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 22016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string@viewDidLoad: I&apos;m here! with retainCount: 32016-08-15 14:27:06.619 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidLoad: I&apos;m here! with retainCount: 32016-08-15 14:27:06.620 LKTestAutoreleasePool[36567:6295671] string_strong_@viewWillAppear: I&apos;m here! with retainCount: 22016-08-15 14:27:06.623 LKTestAutoreleasePool[36567:6295671] string_strong_@viewDidAppear: I&apos;m here! with retainCount: 1// 场景1.3(__weak Fraction *) 结果2016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 12016-08-15 14:31:36.558 LKTestAutoreleasePool[36655:6301737] fraction@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 12016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fd942f1dfd0&gt; with retainCount: 32016-08-15 14:31:36.559 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewWillAppear: (null) with retainCount: (null)2016-08-15 14:31:36.564 LKTestAutoreleasePool[36655:6301737] fraction_weak_@viewDidAppear: (null) with retainCount: (null)// 场景1.4(__strong Fraction *) 结果2016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 12016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 22016-08-15 14:32:09.509 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidLoad: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 22016-08-15 14:32:09.510 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewWillAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 12016-08-15 14:32:09.514 LKTestAutoreleasePool[36681:6303031] fraction_strong_@viewDidAppear: &lt;Fraction: 0x7fd9e9d9ec90&gt; with retainCount: 1 我们使用了一个全局的 weak 变量 string_weak_ 来指向它。因为 weak 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。 最初的两个测试使用了NSString对象，但是常量NSString对象存在常量区，不会dealloc影响了测试，于是换成了前文中的分数类进行测试。场景1.3中fraction_weak_对象被自动添加到当前的autorealeasepool，当viewDidLoad返回时，被回收。 场景212345678910111213141516__weak NSString *string_weak_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 2.1 @autoreleasepool &#123; NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;]; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); string_weak_ = string; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]); &#125; NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);&#125; 12345678910111213141516__weak Fraction *fraction_weak_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 2.2 @autoreleasepool &#123; Fraction *fraction = [[Fraction alloc] init]; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); fraction_weak_ = fraction; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]); &#125; NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);&#125; 123456789101112131415// 场景2.1(__weak NSString *) 结果2016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 22016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string@viewDidLoad: I&apos;m here! with retainCount: 22016-08-15 14:58:39.531 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 42016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidLoad: (null) with retainCount: (null)2016-08-15 14:58:39.532 LKTestAutoreleasePool[36863:6327169] string_weak_@viewWillAppear: (null) with retainCount: (null)2016-08-15 14:58:39.536 LKTestAutoreleasePool[36863:6327169] string_weak_@viewDidAppear: (null) with retainCount: (null)// 场景2.2(__weak Fraction *) 结果2016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 12016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 12016-08-15 14:52:03.420 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7fe429f425e0&gt; with retainCount: 32016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidLoad: (null) with retainCount: (null)2016-08-15 14:52:03.421 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewWillAppear: (null) with retainCount: (null)2016-08-15 14:52:03.426 LKTestAutoreleasePool[36795:6319455] fraction_weak_@viewDidAppear: (null) with retainCount: (null) 场景31234567891011121314151617__weak NSString *string_weak_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 3.1 NSString *string = [NSString stringWithFormat:@&quot;I&apos;m here!&quot;]; @autoreleasepool &#123; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); string_weak_ = string; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]); &#125; NSLog(@&quot;string@viewDidLoad: %@ with retainCount: %@&quot;, string, [string valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;string_weak_@viewDidLoad: %@ with retainCount: %@&quot;, string_weak_, [string_weak_ valueForKey:@&quot;retainCount&quot;]);&#125; 1234567891011121314151617__weak Fraction *fraction_weak_ = nil;- (void)viewDidLoad &#123; [super viewDidLoad]; // 场景 3.2 Fraction *fraction = [[Fraction alloc] init]; @autoreleasepool &#123; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); fraction_weak_ = fraction; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]); &#125; NSLog(@&quot;fraction@viewDidLoad: %@ with retainCount: %@&quot;, fraction, [fraction valueForKey:@&quot;retainCount&quot;]); NSLog(@&quot;fraction_weak_@viewDidLoad: %@ with retainCount: %@&quot;, fraction_weak_, [fraction_weak_ valueForKey:@&quot;retainCount&quot;]);&#125; 1234567891011121314151617// 场景3.1(__weak NSString *) 结果2016-08-15 15:02:00.662 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 22016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 22016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 42016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string@viewDidLoad: I&apos;m here! with retainCount: 22016-08-15 15:02:00.663 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidLoad: I&apos;m here! with retainCount: 42016-08-15 15:02:00.664 LKTestAutoreleasePool[36934:6331215] string_weak_@viewWillAppear: I&apos;m here! with retainCount: 32016-08-15 15:02:00.667 LKTestAutoreleasePool[36934:6331215] string_weak_@viewDidAppear: (null) with retainCount: (null)// 场景3.2(__weak Fraction *) 结果2016-08-15 14:54:43.872 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 12016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 12016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 32016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 12016-08-15 14:54:43.873 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidLoad: &lt;Fraction: 0x7ff031737ab0&gt; with retainCount: 32016-08-15 14:54:43.874 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewWillAppear: (null) with retainCount: (null)2016-08-15 14:54:43.878 LKTestAutoreleasePool[36821:6322969] fraction_weak_@viewDidAppear: (null) with retainCount: (null) 再来看@autoreleasepool之后的代码，fraction = [[Fraction alloc] init];向Fraction类发送alloc消息，alloc方法我们并未定义，这来自于Fraction的父类NSObject的类方法，为一个Fraction对象分配了内存空间，并返回一个实例对象：1234+ (instancetype)new OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);+ (instancetype)allocWithZone:(struct _NSZone *)zone OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);+ (instancetype)alloc OBJC_SWIFT_UNAVAILABLE(&quot;use object initializers instead&quot;);- (void)dealloc OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;deinit&apos; to define a de-initializer&quot;); 随后调用了init方法，同样，这来自于NSObject的实例方法。 fraction对象前的*表示fraction是Fraction对象的指针（引用），就是说fraction并不存储Fraction数据，而是保存了一个Fraction对象在内存中的地址。 而这个fraction对象在初始化时之时分配了空间，获得了他的内存地址，却没有设置值，因此我们setValue，print，得出了分数的值。OC中调用方法可以理解为发送消息，因为在程序运行过程中所有OC代码都会被转化为runtime的C语言代码，[target doSomething];会被转化成objc_msgSend(target, @selector(doSomething));我们知道实例是对象，而类也是一个对象，而类在runtime中是一个结构体，会通过链表保存它的变量列表和方法列表等，在初始化时，也是根据结构体的数据结构为其分配内存。 提前阅读一些runtime的知识iOS~runtime理解iOS中的runtime应用]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>类</tag>
        <tag>方法</tag>
        <tag>对象</tag>
        <tag>autoreleasepool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS基础：GCD]]></title>
    <url>%2F2016%2F08%2F11%2FiOS%E5%9F%BA%E7%A1%80%EF%BC%9AGCD%2F</url>
    <content type="text"><![CDATA[GCD是老生常谈了，不过作为一个新手这个基础乃是重中之重，光看他人的blog总是难以消化，因此自己做些笔记总结实验一下，如有偏差还望指正。 前提 代码是顺序执行的。 queue是FIFO（先进先出）的数据结构。 线程之间是并行的。 串行队列：任务不能同时进行，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。 并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。 void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。 void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。（在下文的推演中，发现其并不总是在其他线程中执行）（p.s. 在实际推演和API中，发现6、7两条中对于线程的描述均是错误的，block在哪个线程中运行取决于queue） 验证1. 代码是顺序执行的。12NSLog(@&quot;step0&quot;);NSLog(@&quot;step1&quot;); 122016-08-12 22:29:49.002 MyPractice[25215:3752290] step02016-08-12 22:29:49.002 MyPractice[25215:3752290] step1 可以看到确实是顺序执行的（严肃脸）。 2. queue是FIFO（先进先出）的数据结构。3. 线程之间是并行的。4. 串行队列：任务不能同时进行，这意味着第n+1个任务必须等待0…n个任务全部完成后才会开始。首先来看什么是DISPATCH_QUEUE_SERIAL。12345/*! * @const DISPATCH_QUEUE_SERIAL * @discussion A dispatch queue that invokes blocks serially in FIFO order. */#define DISPATCH_QUEUE_SERIAL NULL 该队列以先进先出的顺序串行调用blocks。 123456789101112dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]); &#125;);&#125;NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 123452016-08-13 22:49:03.733 MyPractice[32046:5376787] step0 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;2016-08-13 22:49:03.734 MyPractice[32046:5376787] step2 finished! - &lt;NSThread: 0x7fac03602dd0&gt;&#123;number = 1, name = main&#125;2016-08-13 22:49:04.737 MyPractice[32046:5376906] step1.0 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;2016-08-13 22:49:05.741 MyPractice[32046:5376906] step1.1 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125;2016-08-13 22:49:06.747 MyPractice[32046:5376906] step1.2 finished! - &lt;NSThread: 0x7fac034a0690&gt;&#123;number = 2, name = (null)&#125; 可以看到1大类中的三个任务顺序执行。 5. 并发队列：任务可以同时进行，这意味着只要0…n个任务开始执行，那么第n+1个任务也可以开始。123456789101112dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(queue, ^&#123; [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1.%d finished! - %@&quot;, i, [NSThread currentThread]); &#125;);&#125;NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 123452016-08-13 04:21:14.000 MyPractice[27321:4331458] step0 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;2016-08-13 04:21:14.001 MyPractice[27321:4331458] step2 finished! - &lt;NSThread: 0x7f9c08c059f0&gt;&#123;number = 1, name = main&#125;2016-08-13 04:21:15.005 MyPractice[27321:4331587] step1.1 finished! - &lt;NSThread: 0x7f9c08f04540&gt;&#123;number = 3, name = (null)&#125;2016-08-13 04:21:15.005 MyPractice[27321:4331577] step1.0 finished! - &lt;NSThread: 0x7f9c08d0acc0&gt;&#123;number = 2, name = (null)&#125;2016-08-13 04:21:15.005 MyPractice[27321:4331593] step1.2 finished! - &lt;NSThread: 0x7f9c08e0b560&gt;&#123;number = 4, name = (null)&#125; 可以看到1大类中的三个任务同时执行。 6. void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);：将任务（也就是block）放到队列中，同步执行，也就是说在当前线程中执行任务，阻塞当前线程。dispatch_sync任务到其它串行队列中。1234567891011dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);dispatch_sync(queue, ^&#123; // block1 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);&#125;);[NSThread sleepForTimeInterval:2];NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 1232016-08-13 04:28:39.621 MyPractice[27486:4339739] step0 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;2016-08-13 04:28:40.622 MyPractice[27486:4339739] step1 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125;2016-08-13 04:28:42.623 MyPractice[27486:4339739] step2 finished! - &lt;NSThread: 0x7f8050606ad0&gt;&#123;number = 1, name = main&#125; block1处于用于用户自定义串行队列中，由当前线程（主线程）执行，阻塞主线程，step2必须等待block1返回后方可开始执行。 dispatch_sync任务到当前串行队列中。1234567891011dispatch_queue_t queue = dispatch_get_main_queue();NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);dispatch_sync(queue, ^&#123; // block1 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);&#125;);[NSThread sleepForTimeInterval:2];NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 12016-08-13 04:35:51.992 MyPractice[27577:4345752] step0 finished! - &lt;NSThread: 0x7f80d8701fc0&gt;&#123;number = 1, name = main&#125; 整体为主队列中的block0，执行完step0后等待block1返回，然后才可执行step2；同时block1插入主队列，阻塞主线程，此时主队列中还有未完成的任务block0，因此block1开始等待block1完成。至此，block0与block1循环等待，死锁。 dispatch_sync任务到其它并发队列中。1234567891011dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);dispatch_sync(queue, ^&#123; // block1 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);&#125;);[NSThread sleepForTimeInterval:2];NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 1232016-08-13 04:41:45.625 MyPractice[27630:4348773] step0 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;2016-08-13 04:41:46.625 MyPractice[27630:4348773] step1 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125;2016-08-13 04:41:48.627 MyPractice[27630:4348773] step2 finished! - &lt;NSThread: 0x7faec9403070&gt;&#123;number = 1, name = main&#125; step0执行完毕，block1插入用户自定义并发队列，仍在当前线程（主线程）执行，因此阻塞主线程，此时的并发队列前没有其它任务，block1正常执行完毕返回，开始执行step2。 总结123456789101112131415161718192021222324252627282930313233343536/*! * @function dispatch_sync * * @abstract * Submits a block for synchronous execution on a dispatch queue. * * @discussion * Submits a block to a dispatch queue like dispatch_async(), however * dispatch_sync() will not return until the block has finished. * * Calls to dispatch_sync() targeting the current queue will result * in dead-lock. Use of dispatch_sync() is also subject to the same * multi-party dead-lock problems that may result from the use of a mutex. * Use of dispatch_async() is preferred. * * Unlike dispatch_async(), no retain is performed on the target queue. Because * calls to this function are synchronous, the dispatch_sync() &quot;borrows&quot; the * reference of the caller. * * As an optimization, dispatch_sync() invokes the block on the current * thread when possible. * * @param queue * The target dispatch queue to which the block is submitted. * The result of passing NULL in this parameter is undefined. * * @param block * The block to be invoked on the target dispatch queue. * The result of passing NULL in this parameter is undefined. */#ifdef __BLOCKS____OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROWvoiddispatch_sync(dispatch_queue_t queue, dispatch_block_t block);#endif dispatch_sync()在block结束前不会返回。 dispatch_sync()任务到当前队列中会引起死锁。 系统不会retain目标队列，因为dispatch_sync()是同步执行的，它“借”走了其调度者的引用。（这里我理解为，同步执行的任务不完成不会返回，因此引用从外部跟着它进入了block内部，在任务完成后再回到外部）。 dispatch_sync()可能会无视queue的类型，优先在当前线程执行任务。（不知在什么情况下不会在当前线程执行，此处留个心眼）。 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。 7. void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);：将任务放到队列中，异步执行，也就是说在其他线程中执行任务，不阻塞当前线程。dispatch_async任务到其它串行队列中。1234567891011dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);dispatch_async(queue, ^&#123; // block1 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);&#125;);[NSThread sleepForTimeInterval:2];NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 1232016-08-13 05:06:15.123 MyPractice[27791:4366095] step0 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125;2016-08-13 05:06:16.129 MyPractice[27791:4366129] step1 finished! - &lt;NSThread: 0x7fe7196a2f50&gt;&#123;number = 2, name = (null)&#125;2016-08-13 05:06:17.125 MyPractice[27791:4366095] step2 finished! - &lt;NSThread: 0x7fe7196022e0&gt;&#123;number = 1, name = main&#125; 执行顺序为step0 -&gt; step1 -&gt; step2，step1在其它线程上执行，注意step2与step0时差2秒，step1与step0时差1秒，也就是说step1与step2并行。程序运行到step0，step1插入用户自定义串行队列，在其它线程执行，不阻塞当前线程（主线程），并立即返回，于是step2开始执行。 dispatch_async任务到当前串行队列中。1234567891011dispatch_queue_t queue = dispatch_get_main_queue();NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);dispatch_async(queue, ^&#123; // block1 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1 finished! - %@&quot;, [NSThread currentThread]);&#125;);[NSThread sleepForTimeInterval:2];NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 1232016-08-13 05:10:43.516 MyPractice[27830:4369848] step0 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;2016-08-13 05:10:45.518 MyPractice[27830:4369848] step2 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125;2016-08-13 05:10:46.524 MyPractice[27830:4369848] step1 finished! - &lt;NSThread: 0x7fc280d07d30&gt;&#123;number = 1, name = main&#125; 执行顺序为step0 -&gt; step2 -&gt; step1，step1在主线程上执行（这与我们猜想的新开线程不一致，说明我们的猜想错了，至于为什么，先放一放，后面再说），从执行时间来看任务是串行执行的。执行完step0，step1插入主队列，不阻塞当前线程（主线程）并立即返回，开始执行step2，但是block1却必须等待block0执行完毕，因此step1在step2结束后开始执行。 dispatch_async任务到其他并发队列中。已经在5. xxx中实验过，3个任务在3个不同的线程上异步执行。 总结12345678910111213141516171819202122232425262728293031323334/*! * @function dispatch_async * * @abstract * Submits a block for asynchronous execution on a dispatch queue. * * @discussion * The dispatch_async() function is the fundamental mechanism for submitting * blocks to a dispatch queue. * * Calls to dispatch_async() always return immediately after the block has * been submitted, and never wait for the block to be invoked. * * The target queue determines whether the block will be invoked serially or * concurrently with respect to other blocks submitted to that same queue. * Serial queues are processed concurrently with respect to each other. * * @param queue * The target dispatch queue to which the block is submitted. * The system will hold a reference on the target queue until the block * has finished. * The result of passing NULL in this parameter is undefined. * * @param block * The block to submit to the target dispatch queue. This function performs * Block_copy() and Block_release() on behalf of callers. * The result of passing NULL in this parameter is undefined. */#ifdef __BLOCKS____OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_4_0)DISPATCH_EXPORT DISPATCH_NONNULL_ALL DISPATCH_NOTHROWvoiddispatch_async(dispatch_queue_t queue, dispatch_block_t block);#endif dispatch_async()的机制是把blocks任务提交到队列中。 dispatch_async()会立即返回而不会等待block完成。 目标队列的类型决定任务是按照队列里任务的顺序串行或并发地执行；串行队列之间是并发的。这里我的理解是，如果dispatch_async任务到一个并发队列中，那么任务就会被委派到一个新线程中执行，而如果放入一个串行队列，那么它有可能在当前线程执行，也有可能在其他线程执行。在上文实验中出现特例的是主队列，同时它也是当前队列，而主队列又是特殊的串行队列，它只在主线程上执行。这里的主队列比较特殊，不能根据它做出准确结论，我们需要再做一些实验123456789101112131415161718192021dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);dispatch_async(queue, ^&#123; // block1.1 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1.1 finished! - %@&quot;, [NSThread currentThread]); dispatch_async(queue, ^&#123; // block1.2 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1.2 finished! - %@&quot;, [NSThread currentThread]); &#125;);&#125;);dispatch_async(queue, ^&#123; // block1.3 [NSThread sleepForTimeInterval:1]; NSLog(@&quot;step1.3 finished! - %@&quot;, [NSThread currentThread]);&#125;);[NSThread sleepForTimeInterval:3];NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 123452016-08-13 11:03:07.821 MyPractice[28927:4454751] step0 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;2016-08-13 11:03:08.827 MyPractice[28927:4454778] step1.1 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;2016-08-13 11:03:09.831 MyPractice[28927:4454778] step1.3 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125;2016-08-13 11:03:10.823 MyPractice[28927:4454751] step2 finished! - &lt;NSThread: 0x7fbe786079a0&gt;&#123;number = 1, name = main&#125;2016-08-13 11:03:10.832 MyPractice[28927:4454778] step1.2 finished! - &lt;NSThread: 0x7fbe78419320&gt;&#123;number = 2, name = (null)&#125; block1.1不在当前线程（主线程）中执行，而是在新线程（0x7fbe78419320）中，从当前线程切换到了新线程；block1.2仍然在当前线程（0x7fbe78419320）中执行；另外，block1.3也在（0x7fbe78419320）这一线程中执行，同样没有进入一个新线程； 结合实验的结果和一些blog的说法，我认为block在哪个线程取决于queue，对于每个queue来说，它和线程池有某种对应关系： 主队列对应着主线程； 并发队列对应多条线程（非主线程）； 串行队列对应着一条线程（非主线程）； dispatch_sync&amp;dispatch_async：调度对应线程池中的线程； 接下来继续解读官方API 系统会保留目标队列的引用直到block结束。（queue中有任务时不会释放） 参数queue － block任务提交的目标队列；如果传递进来的queue为NULL，返回结果为undefined。 dispatch_async()会代替它的调用者执行Block_copy()和Block_realease()。（block进入queue时会copy，出queue时会realease） 参数block － 将要在目标队列中执行的任务；如果传递进来的block为NULL，返回结果为undedined。 最后对自己提个问题，既然UI的实现没有多线程支持，那么将UI操作放入一个自定义的队列时，它在哪个线程执行呢？1234567891011121314dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);__weak ViewController* weakSelf = self;dispatch_async(queue, ^&#123; // block1 NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]); [NSThread sleepForTimeInterval:1]; weakSelf.view.backgroundColor = [UIColor blueColor]; NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);&#125;);[NSThread sleepForTimeInterval:2];NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 12342016-08-13 11:21:46.485 MyPractice[29211:4475426] step0 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125;2016-08-13 11:21:46.486 MyPractice[29211:4475474] before step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;2016-08-13 11:21:47.489 MyPractice[29211:4475474] after step1! - &lt;NSThread: 0x7fd5e1523bb0&gt;&#123;number = 2, name = (null)&#125;2016-08-13 11:21:48.486 MyPractice[29211:4475426] step2 finished! - &lt;NSThread: 0x7fd5e1403450&gt;&#123;number = 1, name = main&#125; 1234567891011121314dispatch_queue_t queue = dispatch_queue_create(&quot;cn.edu.bjtu.myQueue&quot;, DISPATCH_QUEUE_SERIAL);NSLog(@&quot;step0 finished! - %@&quot;, [NSThread currentThread]);__weak ViewController* weakSelf = self;dispatch_sync(queue, ^&#123; // block1 NSLog(@&quot;before step1! - %@&quot;, [NSThread currentThread]); [NSThread sleepForTimeInterval:1]; weakSelf.view.backgroundColor = [UIColor blueColor]; NSLog(@&quot;after step1! - %@&quot;, [NSThread currentThread]);&#125;);[NSThread sleepForTimeInterval:2];NSLog(@&quot;step2 finished! - %@&quot;, [NSThread currentThread]); 12342016-08-13 11:22:20.948 MyPractice[29246:4476879] step0 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;2016-08-13 11:22:20.949 MyPractice[29246:4476879] before step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;2016-08-13 11:22:21.950 MyPractice[29246:4476879] after step1! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125;2016-08-13 11:22:23.952 MyPractice[29246:4476879] step2 finished! - &lt;NSThread: 0x7f8962402ee0&gt;&#123;number = 1, name = main&#125; 可以看到仍然和之前总结的一样，在哪个线程执行仍然取决于queue的类型。此处迷茫++，还得继续研究啊…]]></content>
      <categories>
        <category>iOS基础知识</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
</search>
